ğŸ“ Arborescence du projet

â”œâ”€â”€ public
â”‚   â”œâ”€â”€ icon-192x192.png
â”‚   â”œâ”€â”€ icon-512x512.png
â”‚   â””â”€â”€ manifest.json
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ components
â”‚   â”‚   â”œâ”€â”€ ChatWindow.tsx
â”‚   â”‚   â”œâ”€â”€ Editor.tsx
â”‚   â”‚   â”œâ”€â”€ EmojiPicker.tsx
â”‚   â”‚   â”œâ”€â”€ FileContextMenu.tsx
â”‚   â”‚   â”œâ”€â”€ FileTree.tsx
â”‚   â”‚   â”œâ”€â”€ ImageGallery.tsx
â”‚   â”‚   â”œâ”€â”€ ImageUploader.tsx
â”‚   â”‚   â”œâ”€â”€ MapCapture.tsx
â”‚   â”‚   â”œâ”€â”€ ProjectModal.tsx
â”‚   â”‚   â”œâ”€â”€ ProjectPanel.tsx
â”‚   â”‚   â”œâ”€â”€ SearchModal.tsx
â”‚   â”‚   â”œâ”€â”€ SettingsModal.tsx
â”‚   â”‚   â”œâ”€â”€ Sidebar.tsx
â”‚   â”‚   â””â”€â”€ WebcamCapture.tsx
â”‚   â”œâ”€â”€ hooks
â”‚   â”‚   â”œâ”€â”€ useFileSystem.ts
â”‚   â”‚   â””â”€â”€ useKeyboardShortcuts.ts
â”‚   â”œâ”€â”€ services
â”‚   â”‚   â””â”€â”€ ai.ts
â”‚   â”œâ”€â”€ utils
â”‚   â”‚   â”œâ”€â”€ format.ts
â”‚   â”‚   â”œâ”€â”€ offlineMessages.ts
â”‚   â”‚   â””â”€â”€ processOfflineMessages.ts
â”‚   â”œâ”€â”€ App.tsx
â”‚   â”œâ”€â”€ index.css
â”‚   â”œâ”€â”€ main.tsx
â”‚   â”œâ”€â”€ store.ts
â”‚   â”œâ”€â”€ sw-custom.js
â”‚   â”œâ”€â”€ types.ts
â”‚   â””â”€â”€ vite-env.d.ts
â”œâ”€â”€ .gitignore
â”œâ”€â”€ eslint.config.js
â”œâ”€â”€ index.html
â”œâ”€â”€ package.json
â”œâ”€â”€ postcss.config.js
â”œâ”€â”€ project-bolt-sb1-jzrce3dn.zip
â”œâ”€â”€ README.md
â”œâ”€â”€ tailwind.config.js
â”œâ”€â”€ tsconfig.app.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ tsconfig.node.json
â””â”€â”€ vite.config.ts

ğŸ“„ Contenu des fichiers

.gitignore:
```
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

```

eslint.config.js:
```
import js from '@eslint/js';
import globals from 'globals';
import reactHooks from 'eslint-plugin-react-hooks';
import reactRefresh from 'eslint-plugin-react-refresh';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  }
);

```

index.html:
```
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/icon-192x192.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#0A0A0A" />
    <meta name="description" content="Application de chat avec diffÃ©rentes IAs" />
    <link rel="apple-touch-icon" href="/icon-192x192.png" />
    <link rel="manifest" href="/manifest.json" />
    <title>AI Chat App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```

package.json:
```
{
  "name": "ai-chat-app",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@headlessui/react": "^1.7.18",
    "@monaco-editor/react": "^4.6.0",
    "chalk": "^5.4.1",
    "highlight.js": "^11.9.0",
    "html2canvas": "^1.4.1",
    "inquirer": "^12.4.1",
    "leaflet": "^1.9.4",
    "lucide-react": "^0.344.0",
    "marked": "^12.0.0",
    "openai": "^4.28.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-leaflet": "^4.2.1",
    "react-swipeable": "^7.0.2",
    "strip-ansi": "^7.1.0",
    "zustand": "^4.5.2"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.1",
    "@tailwindcss/typography": "^0.5.10",
    "@types/leaflet": "^1.9.16",
    "@types/react": "^18.3.5",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1",
    "autoprefixer": "^10.4.18",
    "eslint": "^9.9.1",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.11",
    "globals": "^15.9.0",
    "postcss": "^8.4.35",
    "tailwindcss": "^3.4.1",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.3.0",
    "vite": "^5.4.2",
    "vite-plugin-pwa": "^0.19.2"
  }
}

```

postcss.config.js:
```
import tailwindcss from 'tailwindcss';
import autoprefixer from 'autoprefixer';

export default {
  plugins: {
    tailwindcss,
    autoprefixer,
  },
};
```

project-bolt-sb1-jzrce3dn.zip:
```
[CONTENU NON AFFICHÃ‰ - FICHIER BINAIRE]
```

public\icon-192x192.png:
```
[CONTENU NON AFFICHÃ‰ - FICHIER BINAIRE]
```

public\icon-512x512.png:
```
[CONTENU NON AFFICHÃ‰ - FICHIER BINAIRE]
```

public\manifest.json:
```
{
    "name": "AI Chat App",
    "short_name": "AI Chat",
    "description": "Application de chat avec diffÃ©rentes IAs",
    "start_url": "/",
    "display": "standalone",
    "background_color": "#0A0A0A",
    "theme_color": "#0A0A0A",
    "icons": [
      {
        "src": "/icon-192x192.png",
        "sizes": "192x192",
        "type": "image/png",
        "purpose": "any maskable"
      },
      {
        "src": "/icon-512x512.png",
        "sizes": "512x512",
        "type": "image/png",
        "purpose": "any maskable"
      }
    ]
  }
```

README.md:
```
# AI Chat App ğŸ¤–

Une application de chat moderne et Ã©lÃ©gante permettant d'interagir avec diffÃ©rents modÃ¨les d'IA (GPT-4, Claude, Mistral), avec support PWA pour une installation sur desktop et mobile.

![Version](https://img.shields.io/badge/version-1.0.0-blue.svg)
![License](https://img.shields.io/badge/license-MIT-green.svg)

## âœ¨ FonctionnalitÃ©s

- ğŸ’¬ Chat avec diffÃ©rents modÃ¨les d'IA (GPT-4, Claude, Mistral)
- ğŸ“± Progressive Web App (PWA) installable
- ğŸŒ™ ThÃ¨me sombre natif
- ğŸ“‚ Gestion de projets et fichiers
- ğŸ–¼ï¸ Support des images avec description automatique
- ğŸ’¾ Sauvegarde locale des conversations
- âš¡ Streaming des rÃ©ponses en temps rÃ©el
- ğŸ“ Fonctionne hors-ligne
- ğŸ”„ Mise Ã  jour automatique

## ğŸš€ Installation

1. Clonez le repository :
```bash
git clone https://github.com/Onitsag/Chatbot
cd Chatbot
```

2. Installez les dÃ©pendances :
```bash
npm install
```

3. CrÃ©ez un fichier `.env` Ã  la racine du projet avec vos clÃ©s API :
```env
VITE_OPENAI_API_KEY=votre_clÃ©_openai
VITE_ANTHROPIC_API_KEY=votre_clÃ©_anthropic
VITE_MISTRAL_API_KEY=votre_clÃ©_mistral
```

4. Lancez le serveur de dÃ©veloppement :
```bash
npm run dev
```

## ğŸ—ï¸ Build et dÃ©ploiement

1. CrÃ©ez une version de production :
```bash
npm run build
```

2. Testez la version de production localement :
```bash
npm run preview
```

## ğŸ“± Installation PWA

### Sur Desktop (Chrome, Edge, etc.)

1. Ouvrez l'application dans votre navigateur
2. Cliquez sur l'icÃ´ne d'installation dans la barre d'adresse (ğŸ”½)
3. Suivez les instructions d'installation

### Sur Android

1. Ouvrez l'application dans Chrome
2. Appuyez sur "Ajouter Ã  l'Ã©cran d'accueil"
3. Suivez les instructions d'installation

### Sur iOS

1. Ouvrez l'application dans Safari
2. Appuyez sur le bouton Partager (ğŸ“¤)
3. SÃ©lectionnez "Sur l'Ã©cran d'accueil"
4. Confirmez l'installation

## ğŸ§ª Test de la PWA

Pour tester les fonctionnalitÃ©s PWA :

1. **Mode hors-ligne** :
   - Ouvrez les DevTools (F12)
   - Allez dans l'onglet "Network"
   - Activez "Offline"
   - L'application devrait continuer Ã  fonctionner

2. **Mise en cache** :
   - Les ressources sont automatiquement mises en cache
   - Les appels API sont mis en cache pour 24h
   - VÃ©rifiez dans DevTools > Application > Cache Storage

3. **Mise Ã  jour** :
   - L'application se met Ã  jour automatiquement
   - Une notification apparaÃ®t lors des mises Ã  jour

## ğŸ› ï¸ Technologies utilisÃ©es

- React 18
- TypeScript
- Vite
- Tailwind CSS
- Zustand (State management)
- Marked (Markdown parsing)
- Lucide React (Icons)
- PWA (vite-plugin-pwa)

## ğŸ“ Configuration

### Manifest PWA

Le fichier `manifest.json` configure l'apparence et le comportement de l'application installÃ©e :

```json
{
  "name": "AI Chat App",
  "short_name": "AI Chat",
  "description": "Application de chat avec diffÃ©rentes IAs",
  "theme_color": "#0A0A0A",
  "background_color": "#0A0A0A",
  "display": "standalone"
}
```

### Service Worker

Le service worker est gÃ©nÃ©rÃ© automatiquement par `vite-plugin-pwa` et gÃ¨re :
- La mise en cache des ressources
- Le fonctionnement hors-ligne
- Les stratÃ©gies de cache pour les API
- Les mises Ã  jour automatiques

## ğŸ“„ License

MIT License - voir le fichier [LICENSE](LICENSE) pour plus de dÃ©tails.
```

src\App.tsx:
```
// src/App.tsx
import React, { useEffect, useState } from 'react';
import { Sidebar } from './components/Sidebar';
import { ChatWindow } from './components/ChatWindow';
import { ProjectPanel } from './components/ProjectPanel';
import { useStore } from './store';
import {
  MessageSquare,
  FolderOpen,
  ChevronLeft,
  ChevronRight,
  Settings
} from 'lucide-react';
import { SettingsModal } from './components/SettingsModal';
import { processOfflineMessages } from './utils/processOfflineMessages';
import { useSwipeable } from 'react-swipeable';

export default function App() {
  const { currentProjectId } = useStore();
  const [view, setView] = useState<'chat' | 'project'>('chat');
  const [isSidebarCollapsed, setIsSidebarCollapsed] = useState(false);
  const [isSettingsOpen, setIsSettingsOpen] = useState(false);

  // Demander la permission pour les notifications au dÃ©marrage
  useEffect(() => {
    if ("Notification" in window && Notification.permission !== "granted") {
      Notification.requestPermission();
    }
  }, []);

  // Ã‰couter les messages du service worker pour dÃ©clencher la synchronisation hors ligne
  useEffect(() => {
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.addEventListener('message', (event) => {
        if (event.data && event.data.type === 'SYNC_OFFLINE_MESSAGES') {
          processOfflineMessages();
        }
      });
    }
  }, []);

  // Lorsqu'on repasse en ligne, lancer la synchronisation
  useEffect(() => {
    const handleOnline = () => {
      processOfflineMessages();
    };
    window.addEventListener('online', handleOnline);
    return () => window.removeEventListener('online', handleOnline);
  }, []);

  // Utilisation de react-swipeable pour gÃ©rer l'ouverture/fermeture de la sidebar en mobile
  const swipeHandlers = useSwipeable({
    onSwipedLeft: () => {
      if (window.innerWidth < 768) {
        setIsSidebarCollapsed(true);
      }
    },
    onSwipedRight: () => {
      if (window.innerWidth < 768) {
        setIsSidebarCollapsed(false);
      }
    },
    trackMouse: true // Pour tester avec la souris
  });

  return (
    <div className="flex h-screen bg-gray-900 text-white">
      {/* Sidebar principale avec swipe (sur mobile) */}
      <div
        {...swipeHandlers}
        className={`fixed left-0 top-0 h-screen overflow-y-auto z-50 transition-all duration-300 ease-in-out ${
          isSidebarCollapsed ? 'w-16' : 'w-72'
        }`}
      >
        <div
          className={`flex flex-col w-full h-full bg-gray-900 border-r border-gray-700 ${
            isSidebarCollapsed ? 'items-center' : ''
          }`}
        >
          {/* Navigation principale */}
          <div
            className={`flex p-2 gap-2 border-b border-gray-700 ${
              isSidebarCollapsed ? 'flex-col' : ''
            }`}
          >
            <div className={`flex gap-2 ${isSidebarCollapsed ? 'flex-col' : 'flex-1'}`}>
              <button
                onClick={() => setView('chat')}
                className={`flex items-center gap-2 ${
                  isSidebarCollapsed ? 'w-12 h-12 justify-center' : 'flex-1'
                } px-4 py-2 rounded-lg transition-colors ${
                  view === 'chat'
                    ? 'bg-blue-600 text-white'
                    : 'bg-gray-800 text-gray-300 hover:bg-gray-700'
                }`}
              >
                <MessageSquare size={20} />
                {!isSidebarCollapsed && 'Chat'}
              </button>
              <button
                onClick={() => setView('project')}
                className={`flex items-center gap-2 ${
                  isSidebarCollapsed ? 'w-12 h-12 justify-center' : 'flex-1'
                } px-4 py-2 rounded-lg transition-colors ${
                  view === 'project'
                    ? 'bg-blue-600 text-white'
                    : 'bg-gray-800 text-gray-300 hover:bg-gray-700'
                }`}
              >
                <FolderOpen size={20} />
                {!isSidebarCollapsed && 'Projet'}
              </button>
            </div>
            <button
              onClick={() => setIsSettingsOpen(true)}
              className={`flex items-center justify-center ${
                isSidebarCollapsed ? 'w-12 h-12' : 'w-12'
              } text-gray-400 hover:text-white hover:bg-gray-800 rounded-lg transition-colors`}
              title="ParamÃ¨tres"
            >
              <Settings size={20} />
            </button>
          </div>

          {/* Sidebar spÃ©cifique Ã  la vue */}
          <div className="flex-1 overflow-hidden">
            <Sidebar onViewChange={setView} currentView={view} isCollapsed={isSidebarCollapsed} />
          </div>

          {/* Bouton pour plier/dÃ©plier la sidebar */}
          <button
            onClick={() => setIsSidebarCollapsed(!isSidebarCollapsed)}
            className="absolute -right-3 top-1/2 transform -translate-y-1/2 w-6 h-12 bg-gray-900 text-gray-300 hover:text-white rounded-r-lg flex items-center justify-center border-t border-r border-b border-gray-700"
          >
            {isSidebarCollapsed ? <ChevronRight size={16} /> : <ChevronLeft size={16} />}
          </button>
        </div>
      </div>

      {/* Contenu principal avec marge Ã  gauche pour la sidebar */}
      <div className={`flex-1 ${isSidebarCollapsed ? 'ml-16' : 'ml-72'} transition-all duration-300 overflow-hidden`}>
        {view === 'chat' ? <ChatWindow /> : <ProjectPanel />}
      </div>

      <SettingsModal isOpen={isSettingsOpen} onClose={() => setIsSettingsOpen(false)} />
    </div>
  );
}

```

src\components\ChatWindow.tsx:
```
import React from 'react';
import { Send, Edit2, Check, X, Loader, ChevronDown, ToggleLeft, ToggleRight, RotateCw, Camera, MapPin } from 'lucide-react';
import { useStore } from '../store';
import { sendMessage, generateImageDescription, AI_MODELS, streamResponse, handleFunctionCallsAndRespond } from '../services/ai';
import { marked } from 'marked';
import { ProjectFile, ChatImage, AIModel } from '../types';
import { WebcamCapture } from './WebcamCapture';
import { MapCapture } from './MapCapture';
import { storePendingMessage } from '../utils/offlineMessages';
import 'highlight.js/styles/github-dark.css';

/**
 * ChatWindow
 * - Envoie un message system invisible comme 1er message (prompt system).
 * - Permet de choisir la taille d'historique (2 Ã  30).
 * - @NomImage: pas de description visible, description seulement pour l'IA.
 */
export function ChatWindow({
  projectFiles,
  systemPrompt
}: {
  projectFiles?: ProjectFile[];
  systemPrompt?: string;
}) {
  const {
    chats,
    currentChatId,
    apiKeys,
    addMessage,
    updateMessage,
    setMessageEditing,
    updateChat,
    addImageToChat,
    deleteImageFromChat
  } = useStore();

  // Ã‰tat local
  const [input, setInput] = React.useState('');
  const [isLoading, setIsLoading] = React.useState(false);
  const [isImageLoading, setIsImageLoading] = React.useState(false);
  const [editingContent, setEditingContent] = React.useState('');
  const [error, setError] = React.useState<string | null>(null);
  const [selectedImages, setSelectedImages] = React.useState<ChatImage[]>([]);
  const [showImageSuggestions, setShowImageSuggestions] = React.useState(false);
  const [cursorPosition, setCursorPosition] = React.useState(0);
  const [isDragging, setIsDragging] = React.useState(false);
  const [isModelDropdownOpen, setIsModelDropdownOpen] = React.useState(false);
  const [streamingEnabled, setStreamingEnabled] = React.useState(true);
  const [currentResponse, setCurrentResponse] = React.useState('');
  const [isWebcamOpen, setIsWebcamOpen] = React.useState(false);
  const [isMapOpen, setIsMapOpen] = React.useState(false);


  // Nouvelle fonctionnalitÃ© : limiter l'historique
  // On lit localStorage si prÃ©sent, sinon 15
  const [historySize, setHistorySize] = React.useState(() => {
    const saved = localStorage.getItem('historySize');
    return saved ? parseInt(saved, 10) : 15;
  });

  const [isHistoryDropdownOpen, setIsHistoryDropdownOpen] = React.useState(false);

  const messagesEndRef = React.useRef<HTMLDivElement>(null);
  const suggestionRef = React.useRef<HTMLDivElement>(null);
  const chatContainerRef = React.useRef<HTMLDivElement>(null);
  const dropdownRef = React.useRef<HTMLDivElement>(null);
  const historyDropdownRef = React.useRef<HTMLDivElement>(null);
  const textareaRef = React.useRef<HTMLTextAreaElement>(null);

  // Liste locale d'images
  const [localImages, setLocalImages] = React.useState<ChatImage[]>([]);


  const webcamSupported = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
  const geolocationSupported = 'geolocation' in navigator;


  // SÃ©lection du chat
  const currentChat = chats.find(chat => chat.id === currentChatId);

  React.useEffect(() => {
    localStorage.setItem('historySize', historySize.toString());
  }, [historySize]);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 1) Synchronisation localImages
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  React.useEffect(() => {
    if (currentChat) {
      setLocalImages([...currentChat.images]);
    }
  }, [currentChat?.id, currentChat?.images.length]);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Fonctions utilitaires
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function convertToBase64(file: File): Promise<string> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.readAsDataURL(file);
      reader.onload = () => resolve(reader.result as string);
      reader.onerror = (err) => reject(err);
    });
  }

  function getRandomSuffix(length: number = 5): string {
    return Math.random().toString(36).substring(2, 2 + length);
  }

  function getRandomizedName(originalName: string): string {
    const dotIndex = originalName.lastIndexOf('.');
    let base = originalName;
    let ext = '';
    if (dotIndex !== -1) {
      base = originalName.slice(0, dotIndex);
      ext = originalName.slice(dotIndex);
    }
    const suffix = getRandomSuffix(5);
    return `${base}-${suffix}${ext}`;
  }

  // Convertir MarkDown => HTML
  function toHtml(markdown: string) {
    return marked.parse(markdown, { breaks: true }) as string;
  }

  // RepÃ¨re @NomImage dans un message => renvoie la liste des images
  function getMentionedImages(content: string): ChatImage[] {
    const mentionRegex = /@([^\s]+)/g;
    const result: ChatImage[] = [];
    let match;
    while ((match = mentionRegex.exec(content)) !== null) {
      const imageName = match[1];
      const found = localImages.find(i => i.name === imageName);
      if (found && !result.some(x => x.id === found.id)) {
        result.push(found);
      }
    }
    return result;
  }

  function triggerNotification(message: string) {
    if ("Notification" in window) {
      if (Notification.permission === "granted") {
        new Notification(message);
      } else if (Notification.permission !== "denied") {
        Notification.requestPermission().then(permission => {
          if (permission === "granted") {
            new Notification(message);
          }
        });
      }
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 2) Divers useEffects
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Focus auto
  React.useEffect(() => {
    const handleKeyPress = (e: KeyboardEvent) => {
      if (e.ctrlKey || e.altKey || e.metaKey) return;
      if (e.key.length === 1) {
        const activeElem = document.activeElement as HTMLElement | null;
        if (!activeElem) return;
        const tag = activeElem.tagName.toLowerCase();
        if (tag !== 'textarea' && tag !== 'input') {
          textareaRef.current?.focus();
        }
      }
    };
    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, []);

  // Scroll auto
  React.useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [currentChat?.messages]);

  // Fermer suggestions
  React.useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (suggestionRef.current && !suggestionRef.current.contains(e.target as Node)) {
        setShowImageSuggestions(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  // Coller image
  React.useEffect(() => {
    const handlePaste = async (e: ClipboardEvent) => {
      const items = Array.from(e.clipboardData?.items || []);
      const imageItem = items.find(it => it.type.startsWith('image/'));
      if (imageItem) {
        e.preventDefault();
        const file = imageItem.getAsFile();
        if (file) {
          await processImage(file);
        }
      }
    };
    document.addEventListener('paste', handlePaste);
    return () => document.removeEventListener('paste', handlePaste);
  }, [currentChat?.id, apiKeys]);

  // Fermer dropdown IA
  React.useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(e.target as Node)) {
        setIsModelDropdownOpen(false);
      }
      if (historyDropdownRef.current && !historyDropdownRef.current.contains(e.target as Node)) {
        setIsHistoryDropdownOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 3) Pas de chat => ...
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (!currentChat) {
    return (
      <div className="flex-1 flex items-center justify-center bg-gray-800">
        <div className="text-center">
          <p className="text-xl text-gray-300 font-medium">Aucune conversation sÃ©lectionnÃ©e</p>
          <p className="mt-2 text-gray-400">SÃ©lectionnez ou crÃ©ez une conversation pour commencer</p>
        </div>
      </div>
    );
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // processImage => rename + desc + store
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  async function processImage(file: File) {
    if (!file.type.startsWith('image/')) {
      setError('Le fichier doit Ãªtre une image');
      return;
    }
    if (file.size > 5 * 1024 * 1024) {
      setError('L\'image ne doit pas dÃ©passer 5MB');
      return;
    }
    try {
      setError(null);
      setIsImageLoading(true);

      const rName = getRandomizedName(file.name);
      console.log(`[processImage] rename "${file.name}" => "${rName}"`);

      const base64 = await convertToBase64(file);
      if (!currentChat) {
        setError('Aucune conversation sÃ©lectionnÃ©e');
        return;
      }
      const desc = await generateImageDescription(apiKeys[currentChat.model.id], base64);

      const newImg: ChatImage = {
        id: crypto.randomUUID(),
        base64,
        description: desc,
        name: rName,
        timestamp: Date.now()
      };

      setLocalImages(prev => [...prev, newImg]);
      await addImageToChat(currentChat.id, {
        base64,
        description: desc,
        name: rName,
        timestamp: Date.now()
      });
      console.log('[processImage] Image added =>', rName);
    } catch (err: any) {
      setError(err.message);
      console.error('Erreur lors du traitement de l\'image:', err);
    } finally {
      setIsImageLoading(false);
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // handleStreamingToggle
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function handleStreamingToggle() {
    const newVal = !streamingEnabled;
    setStreamingEnabled(newVal);
    if (!currentChat) {
      setError('Aucune conversation sÃ©lectionnÃ©e');
      return;
    }
    updateChat(currentChat.id, { streamingEnabled: newVal });
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // handleSubmit => envoi
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    if (!input.trim() && selectedImages.length === 0) return;
    if (isLoading) return;

    if (!currentChat) {
      setError('Aucune conversation sÃ©lectionnÃ©e');
      return;
    }
    const apiKey = apiKeys[currentChat.model.id];
    if (!apiKey) {
      setError(`Veuillez entrer une clÃ© API pour ${currentChat.model.name}`);
      return;
    }
    setError(null);

    // PrÃ©parer le message en intÃ©grant les descriptions d'images
    const userTyped = input.trim();
    let msgForAI = userTyped;
    for (const img of localImages) {
      const mention = '@' + img.name;
      if (msgForAI.includes(mention)) {
        msgForAI = msgForAI.replace(mention, mention + ` (${img.description})`);
      }
    }
    setInput('');
    setSelectedImages([]);

    // Si hors ligne, on ajoute immÃ©diatement le message avec le flag offline
    if (!navigator.onLine) {
      const offlineId = crypto.randomUUID();
      // Ajout du message avec offline=true (sans modifier le contenu)
      addMessage(currentChat.id, 'user', msgForAI, undefined, offlineId, true);
      // Stocker dans IndexedDB pour la synchronisation ultÃ©rieure
      await storePendingMessage({
        id: offlineId,
        chatId: currentChat.id,
        content: msgForAI,
        timestamp: Date.now()
      });
      // Demander la background sync
      if ('serviceWorker' in navigator && 'SyncManager' in window) {
        const reg = await navigator.serviceWorker.ready;
        await (reg as any).sync.register('sync-messages');
      }
      // Notifier une seule fois (stockage dans localStorage pour Ã©viter les doublons)
      if (Notification.permission === "granted" && !localStorage.getItem('offlineSyncNotified')) {
        new Notification("Vous Ãªtes hors ligne. Vos messages seront synchronisÃ©s dÃ¨s le retour de connexion.");
        localStorage.setItem('offlineSyncNotified', 'true');
      }
      return;
    }

    // Si en ligne, envoyer le message normalement (il est affichÃ© dÃ¨s la saisie)
    addMessage(currentChat.id, 'user', userTyped);
    setIsLoading(true);
    setCurrentResponse('');

    try {
      // PrÃ©paration du message systÃ¨me et de l'historique
      const systemBase = `Tu es un assistant IA. RÃ©ponds briÃ¨vement. L'utilisateur peut t'envoyer des images en mentionnant leur nom, exemple "@image.png". Tu peux voir l'image grÃ¢ce Ã  la description qui se trouve automatiquement entre parenthÃ¨ses aprÃ¨s la mention de l'image en question.\n`;
      const fullSystem = systemPrompt ? systemBase + "\n" + systemPrompt : systemBase;
      const systemMsg = { role: 'system' as const, content: fullSystem };

      const visibleHistory = currentChat.messages.filter(m => m.role !== 'system');
      const lastMessages = visibleHistory.slice(-historySize);

      const finalMessages = [
        systemMsg,
        ...lastMessages.map(m => ({ role: m.role, content: m.content })),
        { role: 'user' as const, content: msgForAI }
      ];

      if (streamingEnabled && currentChat.model.supportsStreaming) {
        const finalToolCalls: Record<number, { name: string; arguments: string }> = {};
        const streamGen = streamResponse(currentChat.model, apiKey, finalMessages, finalToolCalls);
        let accum = '';
        for await (const chunk of streamGen) {
          accum += chunk;
          setCurrentResponse(accum);
        }
        const addRes = await handleFunctionCallsAndRespond(
          currentChat.model,
          apiKey,
          [...finalMessages, { role: 'assistant', content: accum }],
          finalToolCalls
        );
        let finalAnswer = accum.trim();
        if (addRes.trim()) finalAnswer += '\n\n' + addRes.trim();

        if (finalAnswer) {
          addMessage(currentChat.id, 'assistant', finalAnswer);
        }
      } else {
        const resp = await sendMessage(
          currentChat.model,
          apiKey,
          finalMessages,
          currentChat.images,
          false
        );
        addMessage(currentChat.id, 'assistant', resp);
      }
    } catch (err: any) {
      const msg = err.message || 'Une erreur est survenue';
      setError(msg);
      addMessage(currentChat.id, 'assistant', `âš ï¸ ${msg}`);
    } finally {
      setIsLoading(false);
      setCurrentResponse('');
    }
  }




  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Ã‰dition
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function handleEdit(msg: any) {
    setEditingContent(msg.content);
    if (!currentChat) {
      setError('Aucune conversation sÃ©lectionnÃ©e');
      return;
    }
    setMessageEditing(currentChat.id, msg.id, true);
  }
  async function handleSaveEdit(msgId: string) {
    // 1. Mettre Ã  jour le contenu du message et sortir du mode Ã©dition
    if (!currentChat) {
      setError('Aucune conversation sÃ©lectionnÃ©e');
      return;
    }
    updateMessage(currentChat.id, msgId, editingContent);
    setMessageEditing(currentChat.id, msgId, false);

    // 2. RÃ©acquÃ©rir l'Ã©tat mis Ã  jour du chat depuis le store
    const updatedChat = useStore.getState().chats.find(chat => chat.id === currentChat.id);
    if (!updatedChat) return;

    // 3. Trouver l'index du message modifiÃ© dans l'Ã©tat actualisÃ©
    const index = updatedChat.messages.findIndex(m => m.id === msgId);
    if (index === -1) return;

    // 4. Tronquer les messages postÃ©rieurs au message modifiÃ©
    const trimmedMessages = updatedChat.messages.slice(0, index + 1);
    updateChat(updatedChat.id, { messages: trimmedMessages });

    // 5. RÃ©initialiser l'Ã©tat local d'Ã©dition si nÃ©cessaire
    setEditingContent('');

    // 6. GÃ©nÃ©rer une nouvelle rÃ©ponse de l'IA basÃ©e sur le message modifiÃ©
    await generateResponseForLastUser();
  }


  function handleCancelEdit(msgId: string) {
    if (!currentChat) {
      setError('Aucune conversation sÃ©lectionnÃ©e');
      return;
    }
    setMessageEditing(currentChat.id, msgId, false);
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Regenerate
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  async function regenerateMessage(assistantMsgId: string) {
    if (!currentChat) {
      setError('Aucune conversation sÃ©lectionnÃ©e');
      return;
    }
    const idx = currentChat.messages.findIndex(m => m.id === assistantMsgId);
    if (idx === -1) return;

    // Vider le contenu du message existant avant rÃ©gÃ©nÃ©ration
    updateMessage(currentChat.id, assistantMsgId, '');

    // Trouver l'index du message utilisateur prÃ©cÃ©dent
    const userIdx = idx - 1;
    if (userIdx < 0 || currentChat.messages[userIdx].role !== 'user') return;

    const userMsg = currentChat.messages[userIdx].content;
    setInput('');
    setIsLoading(true);

    try {
      const apiKey = apiKeys[currentChat.model.id];
      if (!apiKey) {
        setError(`Veuillez entrer une clÃ© API pour ${currentChat.model.name}`);
        return;
      }

      // Construction du message systÃ¨me
      const systemBase = "Tu es Georges, un assistant IA. RÃ©ponds briÃ¨vement.\n";
      const fullSystem = systemPrompt ? systemBase + "\n" + systemPrompt : systemBase;
      const systemMsg = { role: 'system' as const, content: fullSystem };

      // PrÃ©paration de l'historique et rÃ©cupÃ©ration des X derniers messages
      const visibleHistory = currentChat.messages.filter(m => m.role !== 'system');
      const lastMessages = visibleHistory.slice(0, idx).slice(-historySize);

      // IntÃ©gration des descriptions d'images dans le message utilisateur si nÃ©cessaire
      let userForAI = userMsg;
      for (const img of localImages) {
        const mention = '@' + img.name;
        if (userForAI.includes(mention)) {
          userForAI = userForAI.replace(mention, mention + ` (${img.description})`);
        }
      }

      const finalMessages = [
        systemMsg,
        ...lastMessages.map(m => ({ role: m.role, content: m.content })),
        { role: 'user' as const, content: userForAI }
      ];

      if (streamingEnabled && currentChat.model.supportsStreaming) {
        const finalToolCalls: Record<number, { name: string; arguments: string }> = {};
        const streamGen = streamResponse(currentChat.model, apiKey, finalMessages, finalToolCalls);

        let accum = '';
        for await (const chunk of streamGen) {
          accum += chunk;
          // Mise Ã  jour directe du message existant pendant le streaming
          updateMessage(currentChat.id, assistantMsgId, accum);
        }

        const addRes = await handleFunctionCallsAndRespond(
          currentChat.model,
          apiKey,
          [...finalMessages, { role: 'assistant', content: accum }],
          finalToolCalls
        );

        let finalAnswer = accum.trim();
        if (addRes.trim()) finalAnswer += '\n\n' + addRes.trim();

        if (finalAnswer) {
          // Mise Ã  jour finale du message avec la rÃ©ponse complÃ¨te
          updateMessage(currentChat.id, assistantMsgId, finalAnswer);
        }
      } else {
        const resp = await sendMessage(
          currentChat.model,
          apiKey,
          finalMessages,
          currentChat.images,
          false
        );
        updateMessage(currentChat.id, assistantMsgId, resp);
      }
    } catch (err: any) {
      const msg = err.message || 'Une erreur est survenue';
      setError(msg);
      updateMessage(currentChat.id, assistantMsgId, `âš ï¸ ${msg}`);
    } finally {
      setIsLoading(false);
    }
  }

  async function generateResponseForLastUser() {
    // Rechercher le chat actuel directement depuis le store pour obtenir la version mise Ã  jour
    const updatedChat = useStore.getState().chats.find(chat => chat.id === currentChatId);
    if (!updatedChat) return;

    const lastMsg = updatedChat.messages[updatedChat.messages.length - 1];
    if (!lastMsg || lastMsg.role !== 'user') return;

    const apiKey = apiKeys[updatedChat.model.id];
    if (!apiKey) {
      setError(`Veuillez entrer une clÃ© API pour ${updatedChat.model.name}`);
      return;
    }

    setError(null);
    setIsLoading(true);
    setCurrentResponse('');

    // Construction du message systÃ¨me et prÃ©paration de lâ€™historique
    const systemBase = "Tu es Georges, un assistant IA. RÃ©ponds briÃ¨vement.\n";
    const fullSystem = systemPrompt ? systemBase + "\n" + systemPrompt : systemBase;
    const systemMsg = { role: 'system' as const, content: fullSystem };

    // Utiliser updatedChat pour construire l'historique
    const visibleHistory = updatedChat.messages.filter(m => m.role !== 'system');
    const lastMessages = visibleHistory.slice(-historySize);

    // PrÃ©paration du message utilisateur pour lâ€™IA (intÃ©gration des descriptions dâ€™images si nÃ©cessaire)
    let msgForAI = lastMsg.content;
    for (const img of localImages) {
      const mention = '@' + img.name;
      if (msgForAI.includes(mention)) {
        msgForAI = msgForAI.replace(mention, mention + ` (${img.description})`);
      }
    }

    const finalMessages = [
      systemMsg,
      ...lastMessages.map(m => ({ role: m.role, content: m.content })),
      { role: 'user' as const, content: msgForAI }
    ];

    try {
      if (streamingEnabled && updatedChat.model.supportsStreaming) {
        const finalToolCalls: Record<number, { name: string; arguments: string }> = {};
        const streamGen = streamResponse(updatedChat.model, apiKey, finalMessages, finalToolCalls);

        let accum = '';
        for await (const chunk of streamGen) {
          accum += chunk;
          setCurrentResponse(accum);
        }

        const addRes = await handleFunctionCallsAndRespond(
          updatedChat.model,
          apiKey,
          [...finalMessages, { role: 'assistant', content: accum }],
          finalToolCalls
        );

        let finalAnswer = accum.trim();
        if (addRes.trim()) finalAnswer += '\n\n' + addRes.trim();

        if (finalAnswer) {
          addMessage(updatedChat.id, 'assistant', finalAnswer);
        }
      } else {
        const resp = await sendMessage(updatedChat.model, apiKey, finalMessages, updatedChat.images, false);
        addMessage(updatedChat.id, 'assistant', resp);
      }
    } catch (err: any) {
      const msg = err.message || 'Une erreur est survenue';
      setError(msg);
      addMessage(updatedChat.id, 'assistant', `âš ï¸ ${msg}`);
    } finally {
      setIsLoading(false);
      setCurrentResponse('');
    }
  }



  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // handleInputKeyDown + handleInputChange
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function handleInputKeyDown(e: React.KeyboardEvent<HTMLTextAreaElement>) {
    if (e.key === 'Enter' && e.shiftKey) {
      e.stopPropagation();
      return;
    }
    if (e.key === 'Enter' && !e.shiftKey) {
      if (showImageSuggestions) {
        e.preventDefault();
        const arr = getFilteredImages();
        if (arr.length > 0) {
          insertImageMention(arr[0]);
        }
        return;
      }
      e.preventDefault();
      handleSubmit(e);
    }
  }
  function handleInputChange(e: React.ChangeEvent<HTMLTextAreaElement>) {
    const val = e.target.value;
    const pos = e.target.selectionStart || 0;
    setInput(val);
    setCursorPosition(pos);

    // auto-resize
    e.currentTarget.style.height = 'auto';
    const maxHeight = 200;
    e.currentTarget.style.height = Math.min(e.currentTarget.scrollHeight, maxHeight) + 'px';
    if (e.currentTarget.scrollHeight > maxHeight) {
      e.currentTarget.style.overflowY = 'auto';
    } else {
      e.currentTarget.style.overflowY = 'hidden';
    }

    // suggestions
    const textBefore = val.substring(0, pos);
    const lastAt = textBefore.lastIndexOf('@');
    if (lastAt !== -1 && !textBefore.includes(' ', lastAt)) {
      const term = textBefore.substring(lastAt + 1).toLowerCase();
      const found = localImages.some(i => i.name.toLowerCase().includes(term));
      setShowImageSuggestions(found);
    } else {
      setShowImageSuggestions(false);
    }
  }

  // Mentions
  function insertImageMention(img: ChatImage) {
    if (!textareaRef.current) return;
    const text = textareaRef.current.value;
    const lastAtSymbol = text.lastIndexOf('@');
    if (lastAtSymbol !== -1) {
      const before = text.substring(0, lastAtSymbol);
      const after = text.substring(lastAtSymbol);
      const spaceIndex = after.indexOf(' ');
      const newText = before + `@${img.name}` + (spaceIndex >= 0 ? after.substring(spaceIndex) : '');
      setInput(newText);
      setTimeout(() => textareaRef.current?.focus(), 0);
    } else {
      setInput(text + `@${img.name}`);
    }
    setSelectedImages(prev => {
      if (!prev.find(i => i.id === img.id)) {
        return [...prev, img];
      }
      return prev;
    });
    setShowImageSuggestions(false);
  }

  function getFilteredImages() {
    const txt = input.substring(0, cursorPosition);
    const lastAt = txt.lastIndexOf('@');
    if (lastAt === -1) return localImages;
    const searchTerm = txt.substring(lastAt + 1).toLowerCase();
    return localImages.filter(i => i.name.toLowerCase().includes(searchTerm));
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Drag & drop
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function handleDragOver(e: React.DragEvent) {
    e.preventDefault();
    setIsDragging(true);
  }
  function handleDragLeave(e: React.DragEvent) {
    e.preventDefault();
    setIsDragging(false);
  }
  async function handleDrop(e: React.DragEvent) {
    e.preventDefault();
    setIsDragging(false);
    const items = Array.from(e.dataTransfer.items);
    const files = items
      .filter(i => i.kind === 'file')
      .map(i => i.getAsFile())
      .filter((f): f is File => f !== null);
    for (const file of files) {
      await processImage(file);
    }
  }

  // handleModelChange
  function handleModelChange(model: AIModel) {
    if (!currentChat) {
      setError('Aucune conversation sÃ©lectionnÃ©e');
      return;
    }
    updateChat(currentChat.id, { model });
    setIsModelDropdownOpen(false);
  }

  // Handle history size
  function handleHistorySizeChange(size: number) {
    setHistorySize(size);
    setIsHistoryDropdownOpen(false);
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Rendu
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  return (
    <div
      ref={chatContainerRef}
      className="flex flex-col h-full bg-gray-800 relative overflow-hidden"
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
    >
      {/* Barre d'en-tÃªte */}
      <div className="flex items-center justify-between px-6 py-4 border-b border-gray-700">
        <h1 className="text-xl font-semibold text-white">{currentChat.title}</h1>

        <div className="flex items-center gap-4 relative">
          {/* Switch streaming */}
          {currentChat.model.id === 'gpt' && (
            <button
              onClick={handleStreamingToggle}
              className="flex items-center gap-2 px-4 py-2 bg-gray-700 
                         hover:bg-gray-600 rounded-lg text-sm text-white transition-colors"
              title={streamingEnabled ? 'DÃ©sactiver le streaming' : 'Activer le streaming'}
            >
              {streamingEnabled ? (
                <ToggleRight size={16} className="text-blue-500" />
              ) : (
                <ToggleLeft size={16} />
              )}
              <span>Streaming</span>
            </button>

          )}

          {/* Choix du modÃ¨le */}
          <div className="relative" ref={dropdownRef}>
            <button
              onClick={() => setIsModelDropdownOpen(!isModelDropdownOpen)}
              className="flex items-center gap-2 px-4 py-2 bg-gray-700 
                         hover:bg-gray-600 rounded-lg text-sm text-white transition-colors"
            >
              <span>{currentChat.model.name}</span>
              <ChevronDown
                size={16}
                className={`text-gray-400 transition-transform ${isModelDropdownOpen ? 'rotate-180' : ''
                  }`}
              />
            </button>
            {isModelDropdownOpen && (
              <div
                className="absolute right-0 mt-2 w-48 bg-gray-700 rounded-lg shadow-lg
                           border border-gray-600 py-1 z-50"
              >
                {AI_MODELS.map((m) => (
                  <button
                    key={m.id}
                    onClick={() => handleModelChange(m)}
                    className={`w-full px-4 py-2 text-left hover:bg-gray-600 transition-colors ${currentChat.model.id === m.id ? 'bg-gray-600 text-white' : 'text-gray-200'
                      }`}
                  >
                    {m.name}
                  </button>
                ))}
              </div>
            )}
          </div>


          {/* Choix de la taille d'historique */}
          <div className="relative" ref={historyDropdownRef}>
            <button
              onClick={() => setIsHistoryDropdownOpen(!isHistoryDropdownOpen)}
              className="flex items-center gap-2 px-4 py-2 bg-gray-700 
                         hover:bg-gray-600 rounded-lg text-sm text-white transition-colors"
              title="Nombre de messages de l'historique"
            >
              <span>Hist: {historySize}</span>
              <ChevronDown
                size={16}
                className={`text-gray-400 transition-transform ${isHistoryDropdownOpen ? 'rotate-180' : ''
                  }`}
              />
            </button>
            {isHistoryDropdownOpen && (
              <div
                className="absolute right-0 mt-2 w-20 bg-gray-700 rounded-lg shadow-lg
                           border border-gray-600 py-1 z-50 max-h-48 overflow-y-auto"
              >
                {[...Array(29)].map((_, i) => i + 2).map((num) => (
                  <button
                    key={num}
                    onClick={() => handleHistorySizeChange(num)}
                    className={`w-full px-4 py-1 text-left hover:bg-gray-600 transition-colors ${historySize === num ? 'bg-gray-600 text-white' : 'text-gray-200'
                      }`}
                  >
                    {num}
                  </button>
                ))}
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Overlay drag & drop */}
      {isDragging && (
        <div className="absolute inset-0 bg-blue-500/10 border-2 border-blue-500 border-dashed
                       rounded-lg flex items-center justify-center z-50"
        >
          <div className="text-blue-500 text-lg font-medium">
            DÃ©posez votre image ici
          </div>
        </div>
      )}

      {/* Overlay chargement d'image */}
      {isImageLoading && (
        <div className="absolute inset-0 bg-black/50 flex items-center justify-center z-50">
          <div className="bg-gray-800 rounded-lg p-4 flex items-center gap-3">
            <Loader className="animate-spin text-blue-500" size={24} />
            <span className="text-white">Analyse de l'image en cours...</span>
          </div>
        </div>
      )}

      {/* Erreur */}
      {error && (
        <div className="m-4 bg-red-500/10 border border-red-500/50 text-red-500 px-4 py-2 rounded-lg">
          {error}
        </div>
      )}

      {/* Liste de messages */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {currentChat.messages.map((message, idx) => {
          // On ignore role=system visuellement
          if (message.role === 'system') return null;

          const isLastAssistant = (message.role === 'assistant') && (idx === currentChat.messages.length - 1);
          const senderName = (message.role === 'user') ? 'Vous' : currentChat.model.name;

          // On convertit en HTML
          const html = toHtml(message.content);
          // Images mentionnÃ©es
          const mentionImages = getMentionedImages(message.content);

          return (
            <div
              key={message.id}
              className={`group max-w-2xl ${message.role === 'user' ? 'ml-auto' : 'mr-auto'}`}
            >
              <div
                className={`
                  rounded-lg p-4 relative
                  ${message.role === 'user' ? 'bg-blue-600 text-white' : 'bg-gray-700 text-white'}
                `}
                style={{ paddingTop: '3rem' }}
              >
                {/* Nom + actions */}
                <div className="absolute top-2 left-2 flex items-center gap-2">
                  <span className="font-bold text-sm text-gray-100">{senderName}</span>
                  {message.role === 'user' && message.offline && (
                    <span className="text-red-500" title="Message non synchronisÃ©">&#x26A0;</span>
                  )}
                </div>
                <div className="absolute top-2 right-2 flex items-center gap-2">
                  <button
                    onClick={() => handleEdit(message)}
                    className="text-gray-300 hover:text-white transition-colors"
                    title="Ã‰diter ce message"
                  >
                    <Edit2 size={16} />
                  </button>
                  {isLastAssistant && message.role === 'assistant' && (
                    <button
                      onClick={() => regenerateMessage(message.id)}
                      className="text-gray-300 hover:text-white transition-colors"
                      title="RegÃ©nÃ©rer ce message"
                    >
                      <RotateCw size={16} />
                    </button>
                  )}
                </div>

                {message.isEditing ? (
                  <div className="space-y-2">
                    <textarea
                      value={editingContent}
                      onChange={e => setEditingContent(e.target.value)}
                      className="w-full bg-gray-800 text-white rounded p-2 min-h-[100px]"
                    />
                    <div className="flex justify-end gap-2">
                      <button
                        onClick={() => handleSaveEdit(message.id)}
                        className="text-green-500 hover:text-green-400"
                      >
                        <Check size={20} />
                      </button>
                      <button
                        onClick={() => handleCancelEdit(message.id)}
                        className="text-red-500 hover:text-red-400"
                      >
                        <X size={20} />
                      </button>
                    </div>
                  </div>
                ) : (
                  <div
                    dangerouslySetInnerHTML={{ __html: html }}
                    className="prose prose-invert max-w-none"
                  />
                )}
              </div>

              {/* Miniatures d'images mentionnÃ©es */}
              {mentionImages.length > 0 && (
                <div className={`flex gap-2 mt-2 ${message.role === 'user' ? 'justify-end' : ''}`}>
                  {mentionImages.map(img => (
                    <div key={img.id} className="w-12 h-12 rounded-lg overflow-hidden">
                      <img
                        src={img.base64}
                        alt={img.description}
                        className="w-full h-full object-cover"
                      />
                    </div>
                  ))}
                </div>
              )}
            </div>
          );
        })}

        {/* Affichage streaming */}
        {isLoading && currentResponse && (
          <div className="group max-w-2xl mr-auto">
            <div className="rounded-lg p-4 bg-gray-700 text-white">
              {currentResponse}
            </div>
          </div>
        )}

        <div ref={messagesEndRef} />
      </div>

      {/* Galerie images en bas */}
      {localImages.length > 0 && (
        <div className="p-2 border-t border-gray-700 bg-gray-850">
          <div className="flex items-center gap-2 overflow-x-auto pb-2 scrollbar-thin scrollbar-thumb-gray-700">
            {localImages.map((img) => (
              <div
                key={img.id}
                className={`
                  flex-shrink-0 group relative w-12 h-12 rounded-lg overflow-hidden
                  ${selectedImages.find(i => i.id === img.id) ? 'ring-2 ring-blue-500' : ''}
                `}
              >
                <div
                  onClick={() => insertImageMention(img)}
                  className="w-full h-full cursor-pointer"
                  title={img.description}
                >
                  <img
                    src={img.base64}
                    alt={img.description}
                    className="w-full h-full object-cover"
                  />
                </div>
                <button
                  onClick={() => {
                    deleteImageFromChat(currentChat.id, img.id);
                    setLocalImages(prev => prev.filter(i => i.id !== img.id));
                    setSelectedImages(prev => prev.filter(i => i.id !== img.id));
                  }}
                  className="absolute top-0.5 right-0.5 p-0.5 bg-red-500
                             text-white rounded-full transition-opacity"
                >
                  <X size={10} />
                </button>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Formulaire de saisie */}
      <form onSubmit={handleSubmit} className="relative p-4 border-t border-gray-700">
        {showImageSuggestions && (
          <div
            ref={suggestionRef}
            className="absolute bottom-full mb-2 w-full bg-gray-800
                       rounded-lg border border-gray-700 shadow-lg
                       max-h-48 overflow-y-auto"
          >
            {getFilteredImages().map(img => (
              <div
                key={img.id}
                onClick={() => insertImageMention(img)}
                className="flex items-center gap-2 p-2 hover:bg-gray-700 cursor-pointer"
              >
                <div className="w-8 h-8 rounded overflow-hidden flex-shrink-0">
                  <img
                    src={img.base64}
                    alt={img.description}
                    className="w-full h-full object-cover"
                  />
                </div>
                <div className="flex flex-col">
                  <span className="text-sm text-white font-medium">{img.name}</span>
                  <span className="text-xs text-gray-400 truncate">{img.description}</span>
                </div>
              </div>
            ))}
          </div>
        )}

        <div className="flex gap-4">
          <textarea
            ref={textareaRef}
            value={input}
            onChange={handleInputChange}
            onKeyDown={handleInputKeyDown}
            placeholder="Ã‰crivez votre message... (Shift+EntrÃ©e pour une nouvelle ligne, EntrÃ©e pour envoyer)"
            className="flex-1 bg-gray-700 text-white rounded-lg px-4 py-3 focus:outline-none focus:ring-2 focus:ring-blue-500"
            style={{
              minHeight: '50px',
              maxHeight: '200px',
              resize: 'vertical',
              overflowY: 'hidden'
            }}
            rows={1}
            disabled={isLoading}
          />
          {webcamSupported ? (
            <button
              type="button"
              onClick={() => setIsWebcamOpen(true)}
              className="bg-gray-700 text-white rounded-lg px-4 py-3 hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
              title="Prendre une photo avec la webcam"
            >
              <Camera size={20} />
            </button>
          ) : (
            <button
              type="button"
              disabled
              className="bg-gray-500 text-gray-300 rounded-lg px-4 py-3 cursor-not-allowed"
              title="Votre navigateur ne supporte pas la webcam"
            >
              <Camera size={20} />
            </button>
          )}

          {/* Bouton Carte */}
          {geolocationSupported ? (
            <button
              type="button"
              onClick={() => setIsMapOpen(true)}
              className="bg-gray-700 text-white rounded-lg px-4 py-3 hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
              title="Ouvrir la carte"
            >
              <MapPin size={20} />
            </button>
          ) : (
            <button
              type="button"
              disabled
              className="bg-gray-500 text-gray-300 rounded-lg px-4 py-3 cursor-not-allowed"
              title="La gÃ©olocalisation n'est pas supportÃ©e sur ce navigateur"
            >
              <MapPin size={20} />
            </button>
          )}
          <button
            type="submit"
            disabled={isLoading || (!input.trim() && selectedImages.length === 0)}
            className="bg-blue-600 text-white rounded-lg px-6 py-3 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50 disabled:hover:bg-blue-600"
          >
            <Send size={20} className={isLoading ? 'animate-spin' : ''} />
          </button>
        </div>
      </form>
      {isWebcamOpen && (
        <WebcamCapture
          onCapture={(file: File) => {
            processImage(file).then(() => {
              triggerNotification("Photo prise avec la webcam");
            });
          }}
          onClose={() => setIsWebcamOpen(false)}
        />
      )}
      {isMapOpen && (
        <MapCapture
          onCapture={(file: File) => {
            processImage(file).then(() => {
              triggerNotification("Photo prise depuis la carte");
            });
          }}
          onClose={() => setIsMapOpen(false)}
        />
      )}


    </div>
  );
}
```

src\components\Editor.tsx:
```
import { Editor as MonacoEditor } from '@monaco-editor/react';

interface EditorProps {
  value: string;
  language: string;
  onChange: (value: string) => void;
}

export function Editor({ value, language, onChange }: EditorProps) {
  return (
    <MonacoEditor
      height="100%"
      language={language}
      value={value}
      onChange={(value) => onChange(value || '')}
      theme="vs-dark"
      options={{
        minimap: { enabled: true },
        fontSize: 14,
        wordWrap: 'on',
        automaticLayout: true,
        tabSize: 2,
        scrollBeyondLastLine: false,
        renderWhitespace: 'selection',
        formatOnPaste: true,
        formatOnType: true
      }}
    />
  );
}
```

src\components\EmojiPicker.tsx:
```
import { X } from 'lucide-react';

const EMOJI_CATEGORIES = {
  'RÃ©cents': ['ğŸ’¬', 'ğŸ¤–', 'ğŸ’¡', 'ğŸ“', 'ğŸ¯', 'ğŸ”', 'ğŸ“š', 'ğŸ’»'],
  'Visages': ['ğŸ˜Š', 'ğŸ¤”', 'ğŸ¤“', 'ğŸ§', 'ğŸ¤–', 'ğŸ‘¾', 'ğŸ¤¯', 'ğŸ¥³'],
  'Objets': ['ğŸ’¡', 'ğŸ“', 'ğŸ“š', 'ğŸ’»', 'ğŸ”', 'ğŸ¯', 'ğŸ¨', 'ğŸ®'],
  'Symboles': ['âœ¨', 'ğŸ’«', 'ğŸŒŸ', 'â­', 'ğŸ’­', 'ğŸ—¨ï¸', 'ğŸ’¬', 'ğŸ”†']
};

interface EmojiPickerProps {
  onSelect: (emoji: string) => void;
  onClose: () => void;
}

export function EmojiPicker({ onSelect, onClose }: EmojiPickerProps) {
  return (
    <div className="absolute left-0 top-0 z-50 bg-gray-800 rounded-lg shadow-lg border border-gray-700 p-4 w-64">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-sm font-medium text-gray-200">Choisir un Ã©moji</h3>
        <button
          onClick={onClose}
          className="text-gray-400 hover:text-white transition-colors"
        >
          <X size={16} />
        </button>
      </div>

      <div className="space-y-4">
        {Object.entries(EMOJI_CATEGORIES).map(([category, emojis]) => (
          <div key={category}>
            <h4 className="text-xs font-medium text-gray-400 mb-2">{category}</h4>
            <div className="grid grid-cols-8 gap-1">
              {emojis.map((emoji) => (
                <button
                  key={emoji}
                  onClick={() => {
                    onSelect(emoji);
                    onClose();
                  }}
                  className="w-6 h-6 flex items-center justify-center hover:bg-gray-700 rounded transition-colors"
                >
                  {emoji}
                </button>
              ))}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
```

src\components\FileContextMenu.tsx:
```
import { File, FolderOpen, Edit2, Trash2 } from 'lucide-react';

interface FileContextMenuProps {
  path: string;
  isDirectory: boolean;
  onCreateFile: (path: string) => void;
  onCreateDirectory: (path: string) => void;
  onRename: (path: string) => void;
  onDelete: (path: string) => void;
  onMove: (oldPath: string, newPath: string) => void;  // Ajout de cette ligne
  onCopy: (sourcePath: string, destPath: string) => void;  // Ajout de cette ligne
  position: { x: number; y: number };
}


export function FileContextMenu({
  path,
  isDirectory,
  onCreateFile,
  onCreateDirectory,
  onRename,
  onDelete,
  position
}: FileContextMenuProps) {
  return (
    <div
      className="fixed z-50 w-56 bg-gray-800 rounded-lg shadow-lg border border-gray-700 py-1"
      style={{ top: position.y, left: position.x }}
    >
      {isDirectory && (
        <>
          <button
            className="flex items-center w-full px-4 py-2 text-sm text-gray-300 hover:bg-gray-700"
            onClick={() => onCreateFile(`${path}/nouveau-fichier.txt`)}
          >
            <File size={16} className="mr-2" />
            Nouveau fichier
          </button>
          <button
            className="flex items-center w-full px-4 py-2 text-sm text-gray-300 hover:bg-gray-700"
            onClick={() => onCreateDirectory(`${path}/nouveau-dossier`)}
          >
            <FolderOpen size={16} className="mr-2" />
            Nouveau dossier
          </button>
          <div className="border-t border-gray-700 my-1" />
        </>
      )}
      <button
        className="flex items-center w-full px-4 py-2 text-sm text-gray-300 hover:bg-gray-700"
        onClick={() => onRename(path)}
      >
        <Edit2 size={16} className="mr-2" />
        Renommer
      </button>
      <button
        className="flex items-center w-full px-4 py-2 text-sm text-red-400 hover:bg-gray-700"
        onClick={() => onDelete(path)}
      >
        <Trash2 size={16} className="mr-2" />
        Supprimer
      </button>
    </div>
  );
}
```

src\components\FileTree.tsx:
```
import { useState, useEffect, useRef } from 'react';
import { File, FolderOpen, ChevronRight, Search } from 'lucide-react';
import { FileContextMenu } from './FileContextMenu';

interface FileTreeProps {
  tree: any;
  basePath?: string;
  onFileSelect: (path: string) => void;
  onCreateFile: (path: string) => void;
  onCreateDirectory: (path: string) => void;
  onRename: (path: string) => void;
  onDelete: (path: string) => void;
  onMove: (oldPath: string, newPath: string) => void;
  onCopy: (sourcePath: string, destPath: string) => void;
  expandedFolders: Set<string>;
  onToggleFolder: (path: string) => void;
  rootDirectory?: string;
  fileStats?: Record<string, { size: number; lastModified: number; type: string }>;
  onSearch?: (query: string) => void;
  searchResults?: string[];
  selectedFiles: Set<string>;
  onFileSelectionChange: (path: string, selected: boolean, isDirectory?: boolean) => void;
}

export function FileTree({
  tree,
  basePath = '',
  onFileSelect,
  onCreateFile,
  onCreateDirectory,
  onRename,
  onDelete,
  onMove,
  onCopy,
  expandedFolders,
  onToggleFolder,
  rootDirectory,
  onSearch,
  searchResults,
  selectedFiles,
  onFileSelectionChange
}: FileTreeProps) {
  const [contextMenu, setContextMenu] = useState<{
    path: string;
    isDirectory: boolean;
    position: { x: number; y: number };
  } | null>(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [isDragging, setIsDragging] = useState(false);
  const [draggedItem, setDraggedItem] = useState<string | null>(null);
  const [dropTarget, setDropTarget] = useState<string | null>(null);

  const searchInputRef = useRef<HTMLInputElement>(null);
  const treeRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleClickOutside = () => setContextMenu(null);
    window.addEventListener('click', handleClickOutside);
    return () => window.removeEventListener('click', handleClickOutside);
  }, []);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
        e.preventDefault();
        searchInputRef.current?.focus();
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);

  const handleContextMenu = (e: React.MouseEvent, path: string, isDirectory: boolean) => {
    e.preventDefault();
    setContextMenu({
      path,
      isDirectory,
      position: { x: e.clientX, y: e.clientY }
    });
  };

  const handleDragStart = (e: React.DragEvent, path: string) => {
    setDraggedItem(path);
    setIsDragging(true);
    e.dataTransfer.setData('text/plain', path);
    e.dataTransfer.effectAllowed = 'copyMove';
  };

  const handleDragOver = (e: React.DragEvent, path: string) => {
    e.preventDefault();
    setDropTarget(path);
    e.dataTransfer.dropEffect = e.ctrlKey || e.metaKey ? 'copy' : 'move';
  };

  const handleDrop = async (e: React.DragEvent, targetPath: string) => {
    e.preventDefault();
    setIsDragging(false);
    setDropTarget(null);

    if (!draggedItem) return;

    const sourcePath = draggedItem;
    if (sourcePath === targetPath) return;

    if (e.ctrlKey || e.metaKey) {
      await onCopy(sourcePath, `${targetPath}/${sourcePath.split('/').pop()}`);
    } else {
      await onMove(sourcePath, `${targetPath}/${sourcePath.split('/').pop()}`);
    }

    setDraggedItem(null);
  };

  const handleSearch = (query: string) => {
    setSearchQuery(query);
    onSearch?.(query);
  };

  const renderFileEntry = (name: string, path: string) => (
    <div
      key={path}
      className={`group flex items-center px-2 py-1.5 hover:bg-gray-800/50 rounded-md cursor-pointer transition-colors ${
        dropTarget === path ? 'bg-blue-500/10 border border-blue-500/50' : ''
      }`}
      onClick={(e) => {
        e.stopPropagation();
        onFileSelect(path);
      }}
      onContextMenu={(e) => handleContextMenu(e, path, false)}
      draggable
      onDragStart={(e) => handleDragStart(e, path)}
      onDragOver={(e) => handleDragOver(e, path)}
      onDrop={(e) => handleDrop(e, path)}
    >
      <input
        type="checkbox"
        className="mr-2 h-3 w-3 rounded border-gray-500 text-blue-500 focus:ring-blue-500/50"
        checked={selectedFiles.has(path)}
        onChange={(e) => {
          e.stopPropagation();
          onFileSelectionChange(path, e.target.checked, false);
        }}
        onClick={(e) => e.stopPropagation()}
      />
      <File size={14} className="text-gray-400 flex-shrink-0 mr-2" />
      <span className="truncate text-xs text-gray-200">{name}</span>
    </div>
  );

  const renderFolderContent = (content: any, path: string) => (
    <div className="ml-4 space-y-0.5">
      {Object.entries(content).map(([childName, childValue]) => {
        const childPath = `${path}/${childName}`;
        const isDirectory = typeof childValue === 'object';
        const isChildExpanded = expandedFolders.has(childPath);

        return isDirectory
          ? renderFolderEntry(childName, childPath, childValue, isChildExpanded)
          : renderFileEntry(childName, childPath);
      })}
    </div>
  );

  const renderFolderEntry = (name: string, path: string, content: any, isExpanded: boolean) => (
    <div key={path} className="space-y-0.5">
      <div
        className={`group flex items-center px-2 py-1.5 hover:bg-gray-800/50 rounded-md cursor-pointer transition-colors ${
          dropTarget === path ? 'bg-blue-500/10 border border-blue-500/50' : ''
        }`}
        onClick={(e) => {
          e.stopPropagation();
          onToggleFolder(path);
        }}
        onContextMenu={(e) => handleContextMenu(e, path, true)}
        draggable
        onDragStart={(e) => handleDragStart(e, path)}
        onDragOver={(e) => handleDragOver(e, path)}
        onDrop={(e) => handleDrop(e, path)}
      >
        <input
          type="checkbox"
          className="mr-2 h-3 w-3 rounded border-gray-500 text-blue-500 focus:ring-blue-500/50"
          checked={selectedFiles.has(path)}
          onChange={(e) => {
            e.stopPropagation();
            onFileSelectionChange(path, e.target.checked, true);
          }}
          onClick={(e) => e.stopPropagation()}
        />
        <ChevronRight
          size={14}
          className={`text-gray-400 transition-transform ${isExpanded ? 'rotate-90' : ''} mr-1`}
        />
        <FolderOpen size={14} className="text-yellow-500 mr-2" />
        <span className="truncate text-xs text-gray-200">{name}</span>
      </div>
      {isExpanded && renderFolderContent(content, path)}
    </div>
  );

  return (
    <div className="h-full flex flex-col bg-gray-900" ref={treeRef}>
      {/* Barre de recherche */}
      <div className="sticky top-0 z-10 bg-gray-900/95 backdrop-blur-sm border-b border-gray-700/50 p-3">
        <div className="relative">
          <Search size={14} className="absolute left-2.5 top-1/2 transform -translate-y-1/2 text-gray-400" />
          <input
            ref={searchInputRef}
            type="text"
            value={searchQuery}
            onChange={(e) => handleSearch(e.target.value)}
            placeholder="Rechercher... (Ctrl+F)"
            className="w-full bg-gray-800/50 text-white rounded-md pl-8 pr-3 py-1.5 text-xs focus:outline-none focus:ring-1 focus:ring-blue-500/50"
          />
        </div>
      </div>

      {/* Titre du dossier racine */}
      {rootDirectory && (
        <div className="px-3 pt-3">
          <h2 className="text-sm font-medium text-gray-300">{rootDirectory}</h2>
        </div>
      )}
      
      {/* Liste des fichiers */}
      <div className="flex-1 overflow-y-auto p-3 space-y-0.5">
        {searchQuery ? (
          searchResults && searchResults.length > 0 ? (
            <div className="space-y-0.5">
              {searchResults.map((path) => {
                const name = path.split('/').pop() || '';
                return renderFileEntry(name, path);
              })}
            </div>
          ) : (
            <div className="flex items-center justify-center h-32 text-xs text-gray-400">
              Aucun rÃ©sultat pour "{searchQuery}"
            </div>
          )
        ) : rootDirectory ? (
          <div className="space-y-0.5">
            {renderFolderContent(tree, rootDirectory)}
          </div>
        ) : (
          Object.entries(tree).map(([name, value]) => {
            const path = name;
            const isDirectory = typeof value === 'object';
            const isExpanded = expandedFolders.has(path);

            return isDirectory
              ? renderFolderEntry(name, path, value, isExpanded)
              : renderFileEntry(name, path);
          })
        )}
      </div>

      {/* Menu contextuel */}
      {contextMenu && (
        <FileContextMenu
          path={contextMenu.path}
          isDirectory={contextMenu.isDirectory}
          onCreateFile={onCreateFile}
          onCreateDirectory={onCreateDirectory}
          onRename={onRename}
          onDelete={onDelete}
          onMove={onMove}
          onCopy={onCopy}
          position={contextMenu.position}
        />
      )}
    </div>
  );
}
```

src\components\ImageGallery.tsx:
```
import React from 'react';
import { X } from 'lucide-react';
import { ChatImage } from '../types';

interface ImageGalleryProps {
  images: ChatImage[];
  selectedImages?: string[];
  onImageSelect?: (imageId: string) => void;
  onImageDelete?: (imageId: string) => void;
  isSelectable?: boolean;
}

export function ImageGallery({
  images,
  selectedImages = [],
  onImageSelect,
  onImageDelete,
  isSelectable = false
}: ImageGalleryProps) {
  const handleImageClick = (imageId: string) => {
    if (isSelectable && onImageSelect) {
      onImageSelect(imageId);
      const textArea = document.querySelector('textarea, input[type="text"]') as HTMLTextAreaElement | HTMLInputElement | null;
      if (textArea) {
        const imageRef = `[Image ${imageId}]`;
        const cursorPos = textArea.selectionStart || 0;
        const textBefore = textArea.value.substring(0, cursorPos);
        const textAfter = textArea.value.substring(cursorPos);
        textArea.value = textBefore + imageRef + textAfter;
        textArea.focus();
        textArea.selectionStart = textArea.selectionEnd = cursorPos + imageRef.length;
      }
    }
  };

  if (images.length === 0) return null;

  return (
    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4">
      {images.map((image) => (
        <div
          key={image.id}
          className={`relative group ${
            isSelectable ? 'cursor-pointer' : ''
          } ${
            selectedImages.includes(image.id)
              ? 'ring-2 ring-blue-500'
              : ''
          }`}
          onClick={() => handleImageClick(image.id)}
        >
          <div className="aspect-square relative overflow-hidden rounded-lg">
            <img
              src={image.base64}
              alt={image.description}
              className="object-cover w-full h-full"
            />
            {onImageDelete && (
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  onImageDelete(image.id);
                }}
                className="absolute top-2 right-2 p-1 bg-red-500 text-white rounded-full opacity-0 group-hover:opacity-100 transition-opacity"
              >
                <X size={14} />
              </button>
            )}
          </div>
          <div className="mt-2 text-sm text-gray-300 line-clamp-2">
            {image.description}
          </div>
        </div>
      ))}
    </div>
  );
}
```

src\components\ImageUploader.tsx:
```
import React from 'react';
import { Upload, X } from 'lucide-react';
import { generateImageDescription } from '../services/ai';

interface ImageUploaderProps {
  onImageUpload: (image: { base64: string; description: string; name: string }) => void;
  apiKey: string;
}

export function ImageUploader({ onImageUpload, apiKey }: ImageUploaderProps) {
  const [isDragging, setIsDragging] = React.useState(false);
  const [isUploading, setIsUploading] = React.useState(false);
  const [error, setError] = React.useState<string | null>(null);

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(true);
  };

  const handleDragLeave = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
  };

  const convertToBase64 = (file: File): Promise<string> => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.readAsDataURL(file);
      reader.onload = () => resolve(reader.result as string);
      reader.onerror = error => reject(error);
    });
  };

  const processImage = async (file: File) => {
    try {
      setIsUploading(true);
      setError(null);

      if (!file.type.startsWith('image/')) {
        throw new Error('Le fichier doit Ãªtre une image');
      }

      if (file.size > 5 * 1024 * 1024) {
        throw new Error('L\'image ne doit pas dÃ©passer 5MB');
      }

      // Convertir l'image en base64
      const base64 = await convertToBase64(file);

      // GÃ©nÃ©rer la description avec GPT-4 Vision
      const description = await generateImageDescription(apiKey, base64);

      // Envoyer l'image et sa description
      onImageUpload({ base64, description, name: file.name });
    } catch (error: any) {
      setError(error.message);
      console.error('Erreur lors du traitement de l\'image:', error);
    } finally {
      setIsUploading(false);
      setIsDragging(false);
    }
  };

  const handleDrop = async (e: React.DragEvent) => {
    e.preventDefault();
    const file = e.dataTransfer.files[0];
    if (file) {
      await processImage(file);
    }
  };

  const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      await processImage(file);
    }
  };

  return (
    <div className="relative">
      <div
        className={`p-4 border-2 border-dashed rounded-lg transition-colors ${
          isDragging
            ? 'border-blue-500 bg-blue-500/10'
            : 'border-gray-700 hover:border-gray-600'
        }`}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
      >
        <input
          type="file"
          accept="image/*"
          onChange={handleFileSelect}
          className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
          disabled={isUploading}
        />
        <div className="flex flex-col items-center justify-center text-gray-400">
          <Upload size={24} className={`mb-2 ${isUploading ? 'animate-bounce' : ''}`} />
          <p className="text-sm text-center">
            {isUploading
              ? 'Analyse de l\'image en cours...'
              : 'Cliquez ou glissez une image ici'}
          </p>
        </div>
      </div>

      {error && (
        <div className="mt-2 p-2 bg-red-500/10 border border-red-500/50 text-red-500 rounded text-sm flex items-center gap-2">
          <X size={14} />
          {error}
        </div>
      )}
    </div>
  );
}
```

src\components\MapCapture.tsx:
```
import React, { useEffect, useState, useRef } from 'react';
import { X, Check } from 'lucide-react';
import { MapContainer, TileLayer, Marker, useMap } from 'react-leaflet';
import { LatLngExpression } from 'leaflet';
import 'leaflet/dist/leaflet.css';
import html2canvas from 'html2canvas';
import L from 'leaflet';

// Correction des icÃ´nes par dÃ©faut de Leaflet
L.Icon.Default.mergeOptions({
  iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon-2x.png',
  iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png',
  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png'
});

interface MapCaptureProps {
  onCapture: (file: File) => void;
  onClose: () => void;
}

const DEFAULT_POSITION: LatLngExpression = [46.603354, 1.888333]; // Centre de la France

// Composant pour mettre Ã  jour la vue de la carte
function SetMapView({ position, zoom }: { position: LatLngExpression; zoom: number }) {
  const map = useMap();
  useEffect(() => {
    map.setView(position, zoom);
  }, [position, zoom, map]);
  return null;
}

export function MapCapture({ onCapture, onClose }: MapCaptureProps) {
  const [position, setPosition] = useState<LatLngExpression>(DEFAULT_POSITION);
  const [zoom, setZoom] = useState(13);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const mapRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          setPosition([pos.coords.latitude, pos.coords.longitude]);
          setZoom(16); // Zoom plus important pour se rapprocher
          setLoading(false);
        },
        (err) => {
          console.error("Erreur de gÃ©olocalisation :", err);
          setError("Impossible de rÃ©cupÃ©rer votre position, utilisation du centre de la France.");
          setLoading(false);
        }
      );
    } else {
      setError("La gÃ©olocalisation n'est pas supportÃ©e par votre navigateur.");
      setLoading(false);
    }
  }, []);

  // Capture de la carte via html2canvas avec options CORS
  const handleCapture = async () => {
    if (mapRef.current) {
      try {
        const canvas = await html2canvas(mapRef.current, { useCORS: true, allowTaint: false });
        canvas.toBlob(blob => {
          if (blob) {
            const file = new File([blob], 'map.png', { type: 'image/png' });
            onCapture(file);
            onClose();
          }
        }, 'image/png');
      } catch (err) {
        console.error("Erreur lors de la capture de la carte :", err);
      }
    }
  };

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-gray-900 p-4 rounded-lg relative w-full max-w-2xl">
        <button onClick={onClose} className="absolute top-2 right-2 text-gray-400 hover:text-white">
          <X size={20} />
        </button>
        <h2 className="text-xl text-white mb-4">SÃ©lectionnez une zone sur la carte</h2>
        {loading ? (
          <div className="text-white">Chargement de la carte...</div>
        ) : (
          <div ref={mapRef} className="h-96 w-full">
            <MapContainer center={position} zoom={zoom} style={{ height: '100%', width: '100%' }}>
              <TileLayer
                attribution="&copy; <a href='http://osm.org/copyright'>OpenStreetMap</a> contributors"
                url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
              />
              <SetMapView position={position} zoom={zoom} />
              <Marker position={position} />
            </MapContainer>
          </div>
        )}
        {error && <div className="text-red-500 mt-2">{error}</div>}
        <div className="mt-4 flex justify-end gap-4">
          <button
            onClick={handleCapture}
            className="flex items-center gap-2 bg-blue-600 hover:bg-blue-700 text-white rounded px-4 py-2 transition-colors"
          >
            <Check size={20} />
            Valider la zone
          </button>
        </div>
      </div>
    </div>
  );
}

```

src\components\ProjectModal.tsx:
```
import React from 'react';
import { X } from 'lucide-react';

interface ProjectModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (data: { name: string; description: string; systemPrompt: string }) => void;
  initialData?: {
    name: string;
    description: string;
    systemPrompt: string;
    selectedFiles?: Set<string>;
    fileContents?: Record<string, string>;
  };
  title: string;
}

export function ProjectModal({ isOpen, onClose, onSubmit, initialData, title }: ProjectModalProps) {
  const [formData, setFormData] = React.useState({
    name: initialData?.name || '',
    description: initialData?.description || '',
    systemPrompt: initialData?.systemPrompt || ''
  });

  // GÃ©nÃ©rer le prompt systÃ¨me complet avec les fichiers sÃ©lectionnÃ©s
  const fullSystemPrompt = React.useMemo(() => {
    let prompt = formData.systemPrompt;

    if (initialData?.selectedFiles?.size && initialData.fileContents) {
      prompt += '\n\nVoici les fichiers du projet :\n';
      
      initialData.selectedFiles.forEach(path => {
        const content = initialData.fileContents ? initialData.fileContents[path] : '';
        if (content) {
          const fileName = path.split('/').pop();
          prompt += `\n\`\`${fileName}\`\`\n\`\`\`\n${content}\n\`\`\`\n`;
        }
      });
    }

    return prompt;
  }, [formData.systemPrompt, initialData?.selectedFiles, initialData?.fileContents]);

  if (!isOpen) return null;

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!formData.name.trim()) return;
    onSubmit(formData);
    onClose();
  };

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-gray-900 rounded-lg w-full max-w-4xl p-6">
        <div className="flex items-center justify-between mb-6">
          <h2 className="text-xl font-semibold text-white">{title}</h2>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-white transition-colors"
          >
            <X size={20} />
          </button>
        </div>

        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-300 mb-1">
              Nom du projet *
            </label>
            <input
              type="text"
              value={formData.name}
              onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
              className="w-full bg-gray-800 text-white rounded-lg p-2.5 border border-gray-700 focus:border-blue-500 focus:ring-1 focus:ring-blue-500"
              required
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-300 mb-1">
              Description
            </label>
            <textarea
              value={formData.description}
              onChange={(e) => setFormData(prev => ({ ...prev, description: e.target.value }))}
              className="w-full bg-gray-800 text-white rounded-lg p-2.5 border border-gray-700 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 min-h-[100px]"
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-300 mb-1">
              Prompt systÃ¨me
            </label>
            <textarea
              value={formData.systemPrompt}
              onChange={(e) => setFormData(prev => ({ ...prev, systemPrompt: e.target.value }))}
              placeholder="Instructions gÃ©nÃ©rales pour l'IA concernant ce projet..."
              className="w-full bg-gray-800 text-white rounded-lg p-2.5 border border-gray-700 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 min-h-[100px]"
            />
          </div>

          {initialData?.selectedFiles?.size ? (
            <div>
              <label className="block text-sm font-medium text-gray-300 mb-1">
                Prompt systÃ¨me complet (avec fichiers sÃ©lectionnÃ©s)
              </label>
              <pre className="w-full bg-gray-800 text-white rounded-lg p-2.5 border border-gray-700 overflow-auto max-h-[400px] text-xs">
                {fullSystemPrompt}
              </pre>
            </div>
          ) : null}

          <div className="flex justify-end gap-4 pt-4">
            <button
              type="button"
              onClick={onClose}
              className="px-4 py-2 text-gray-300 hover:text-white transition-colors"
            >
              Annuler
            </button>
            <button
              type="submit"
              className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors disabled:opacity-50"
              disabled={!formData.name.trim()}
            >
              {initialData ? 'Mettre Ã  jour' : 'CrÃ©er le projet'}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}
```

src\components\ProjectPanel.tsx:
```
import { useStore } from '../store';
import { useFileSystem } from '../hooks/useFileSystem';
import { FileTree } from './FileTree';
import { File, Settings, Plus, Trash2, MessageSquare, Upload, Edit2, Check, X, FolderOpen } from 'lucide-react';
import { ProjectFile } from '../types';
import { Editor } from './Editor';
import { ProjectModal } from './ProjectModal';
import { ChatWindow } from './ChatWindow';
import { AI_MODELS } from '../services/ai';
import { EmojiPicker } from './EmojiPicker';
import { useState, useEffect, useRef } from 'react';

export function ProjectPanel() {
  const {
    projects,
    currentProjectId,
    updateProject,
    addFile,
    updateFile,
    deleteFile,
    chats,
    addChat,
    deleteChat,
    currentChatId,
    setCurrentChat,
    setCurrentProject,
    updateChat,
    updateChatEmoji
  } = useStore();

  const [selectedFile, setSelectedFile] = useState<ProjectFile | null>(null);
  const [isProjectSettingsOpen, setIsProjectSettingsOpen] = useState(false);
  const [showingChat, setShowingChat] = useState(false);
  const [isDragging, setIsDragging] = useState(false);
  const [editingChatId, setEditingChatId] = useState<string | null>(null);
  const [editingChatTitle, setEditingChatTitle] = useState('');
  const [editingEmoji, setEditingEmoji] = useState<string | null>(null);
  const [expandedFolders, setExpandedFolders] = useState<Set<string>>(new Set());
  const [isRenaming, setIsRenaming] = useState<string | null>(null);
  const [newName, setNewName] = useState('');
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const [autoSaveInterval, setAutoSaveInterval] = useState<number | null>(null);
  const [lastSavedContent, setLastSavedContent] = useState<string>('');
  const [selectedFiles, setSelectedFiles] = useState<Set<string>>(new Set());
  const [fileContents, setFileContents] = useState<Record<string, string>>({});

  const renameInputRef = useRef<HTMLInputElement>(null);

  const {
    isPWA,
    hasFileSystemAccess,
    fileTree,
    isLoading,
    requestFileSystemAccess,
    readFileContent,
    writeFileContent,
    createFile,
    createDirectory,
    deleteEntry,
    renameEntry,
    refreshFileTree,
    watchFileChanges,
    moveEntry,
    copyEntry,
    fileStats,
    rootDirectory,
    getAllFilesInDirectory
  } = useFileSystem();

  const currentProject = projects.find(p => p.id === currentProjectId);
  const projectChats = chats.filter(chat => chat.projectId === currentProjectId);

  // Reset du chat courant quand on change de projet
  useEffect(() => {
    setCurrentChat(null);
  }, [currentProjectId, setCurrentChat]);

  // Surveillance des changements de fichiers
  useEffect(() => {
    if (hasFileSystemAccess) {
      const unwatch = watchFileChanges(async (path) => {
        if (selectedFile && path === selectedFile.path) {
          const content = await readFileContent(path);
          setSelectedFile(prev => prev ? { ...prev, content } : null);
        }
        refreshFileTree();
      });
      return unwatch;
    }
  }, [hasFileSystemAccess, selectedFile, watchFileChanges, readFileContent, refreshFileTree]);

  // Auto-save
  useEffect(() => {
    if (hasUnsavedChanges && selectedFile) {
      const interval = window.setInterval(async () => {
        try {
          await handleSaveFile();
          console.log('Auto-saved:', selectedFile.path);
        } catch (error) {
          console.error('Auto-save failed:', error);
        }
      }, 30000);

      setAutoSaveInterval(interval);
      return () => clearInterval(interval);
    }
    return () => {};
  }, [hasUnsavedChanges, selectedFile]);

  // Nettoyage de l'intervalle d'auto-save
  useEffect(() => {
    return () => {
      if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
      }
    };
  }, [autoSaveInterval]);

  // Gestion des raccourcis clavier
  useEffect(() => {
    const handleKeyDown = async (e: KeyboardEvent) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 's' && selectedFile) {
        e.preventDefault();
        await handleSaveFile();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [selectedFile]);

  // Mise Ã  jour des fichiers sÃ©lectionnÃ©s dans le projet
  useEffect(() => {
    if (currentProject && currentProject.selectedFiles) {
      // Convertir l'objet Set sÃ©rialisÃ© en vÃ©ritable Set
      const files = Array.isArray(currentProject.selectedFiles) 
        ? new Set(currentProject.selectedFiles)
        : new Set();
      setSelectedFiles(files);
    } else {
      setSelectedFiles(new Set());
    }
  }, [currentProject]);

  // Chargement du contenu des fichiers sÃ©lectionnÃ©s
  useEffect(() => {
    const loadSelectedFilesContent = async () => {
      const contents: Record<string, string> = {};
      for (const path of selectedFiles) {
        try {
          contents[path] = await readFileContent(path);
        } catch (error) {
          console.error(`Error loading content for ${path}:`, error);
        }
      }
      setFileContents(contents);
    };

    if (selectedFiles.size > 0) {
      loadSelectedFilesContent();
    }
  }, [selectedFiles, readFileContent]);

  // Gestion des chats
  const handleCreateChat = () => {
    if (!currentProject) return;
    addChat(AI_MODELS[0], currentProject.id);
    setShowingChat(true);
  };

  const handleEditChat = (chatId: string, title: string) => {
    setEditingChatId(chatId);
    setEditingChatTitle(title);
  };

  const handleEditChatEmoji = (chatId: string) => {
    setEditingEmoji(chatId);
  };

  const handleSaveChatTitle = (chatId: string) => {
    if (editingChatTitle.trim()) {
      updateChat(chatId, { title: editingChatTitle.trim() });
    }
    setEditingChatId(null);
    setEditingChatTitle('');
  };

  // Gestion des fichiers
  const handleFileSelect = async (path: string) => {
    if (!hasFileSystemAccess) return;

    if (hasUnsavedChanges) {
      const confirm = window.confirm('Vous avez des modifications non sauvegardÃ©es. Voulez-vous continuer ?');
      if (!confirm) return;
    }

    try {
      const content = await readFileContent(path);
      const extension = path.split('.').pop()?.toLowerCase() || '';

      let language = 'plaintext';
      switch (extension) {
        case 'js': language = 'javascript'; break;
        case 'ts':
        case 'tsx': language = 'typescript'; break;
        case 'jsx': language = 'javascript'; break;
        case 'html': language = 'html'; break;
        case 'css': language = 'css'; break;
        case 'json': language = 'json'; break;
        case 'md': language = 'markdown'; break;
        case 'py': language = 'python'; break;
      }

      const file: ProjectFile = {
        id: path,
        name: path.split('/').pop() || '',
        path,
        content,
        language,
        lastModified: Date.now()
      };

      setSelectedFile(file);
      setLastSavedContent(content);
      setHasUnsavedChanges(false);
    } catch (error) {
      console.error('Erreur lors de la lecture du fichier:', error);
    }
  };

  const handleFileChange = async (content: string) => {
    if (!selectedFile) return;
    setSelectedFile(prev => prev ? { ...prev, content } : null);
    setHasUnsavedChanges(content !== lastSavedContent);
  };

  const handleSaveFile = async () => {
    if (!selectedFile || !hasUnsavedChanges) return;

    try {
      await writeFileContent(selectedFile.path, selectedFile.content);
      setLastSavedContent(selectedFile.content);
      setHasUnsavedChanges(false);
      console.log('File saved:', selectedFile.path);
    } catch (error) {
      console.error('Error saving file:', error);
    }
  };

  const handleCreateFile = async (path: string) => {
    try {
      await createFile(path);
      await refreshFileTree();
      handleFileSelect(path);
    } catch (error) {
      console.error('Error creating file:', error);
    }
  };

  const handleCreateDirectory = async (path: string) => {
    try {
      await createDirectory(path);
      await refreshFileTree();
      setExpandedFolders(prev => new Set([...prev, path]));
    } catch (error) {
      console.error('Error creating directory:', error);
    }
  };

  const handleDeleteEntry = async (path: string) => {
    const confirm = window.confirm('ÃŠtes-vous sÃ»r de vouloir supprimer cet Ã©lÃ©ment ?');
    if (!confirm) return;

    try {
      if (selectedFile?.path === path) {
        setSelectedFile(null);
      }
      await deleteEntry(path);
      await refreshFileTree();
    } catch (error) {
      console.error('Error deleting entry:', error);
    }
  };

  const handleRename = (path: string) => {
    setIsRenaming(path);
    setNewName(path.split('/').pop() || '');
    setTimeout(() => renameInputRef.current?.focus(), 0);
  };

  const handleRenameSubmit = async (oldPath: string) => {
    if (!newName.trim()) return;

    try {
      const parts = oldPath.split('/');
      parts.pop();
      const newPath = [...parts, newName].join('/');

      await renameEntry(oldPath, newPath);

      if (selectedFile?.path === oldPath) {
        setSelectedFile(prev => prev ? { ...prev, path: newPath, name: newName } : null);
      }

      setIsRenaming(null);
      setNewName('');
      await refreshFileTree();
    } catch (error) {
      console.error('Error renaming entry:', error);
    }
  };

  const toggleFolder = (path: string) => {
    setExpandedFolders(prev => {
      const next = new Set(prev);
      if (next.has(path)) {
        next.delete(path);
      } else {
        next.add(path);
      }
      return next;
    });
  };

  const handleFileSelectionChange = async (path: string, selected: boolean, isDirectory?: boolean) => {
    const newSelectedFiles = new Set(selectedFiles);
    
    if (isDirectory) {
      try {
        const files = await getAllFilesInDirectory(path);
        if (selected) {
          files.forEach(file => newSelectedFiles.add(file));
          for (const file of files) {
            try {
              const content = await readFileContent(file);
              setFileContents(prev => ({ ...prev, [file]: content }));
            } catch (error) {
              console.error(`Error loading content for ${file}:`, error);
            }
          }
        } else {
          files.forEach(file => {
            newSelectedFiles.delete(file);
            setFileContents(prev => {
              const next = { ...prev };
              delete next[file];
              return next;
            });
          });
        }
      } catch (error) {
        console.error(`Error processing directory ${path}:`, error);
      }
    } else {
      if (selected) {
        newSelectedFiles.add(path);
        try {
          const content = await readFileContent(path);
          setFileContents(prev => ({ ...prev, [path]: content }));
        } catch (error) {
          console.error(`Error loading content for ${path}:`, error);
        }
      } else {
        newSelectedFiles.delete(path);
        setFileContents(prev => {
          const next = { ...prev };
          delete next[path];
          return next;
        });
      }
    }
    
    setSelectedFiles(newSelectedFiles);
    
    if (currentProject) {
      updateProject(currentProject.id, { selectedFiles: newSelectedFiles });
    }
  };

  // Drag & drop
  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(true);
  };

  const handleDragLeave = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
  };

  const handleDrop = async (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);

    if (!hasFileSystemAccess) {
      alert('Veuillez d\'abord sÃ©lectionner un dossier de travail');
      return;
    }

    const items = Array.from(e.dataTransfer.items);
    for (const item of items) {
      if (item.kind === 'file') {
        const file = item.getAsFile();
        if (!file) continue;

        try {
          const content = await file.text();
          await createFile(file.name, content);
        } catch (error) {
          console.error('Error processing dropped file:', error);
        }
      }
    }

    await refreshFileTree();
  };

  if (!currentProject) {
    return (
      <div className="flex-1 flex items-center justify-center bg-gray-800">
        <div className="text-center">
          <p className="text-xl text-gray-300 font-medium">Aucun projet sÃ©lectionnÃ©</p>
          <p className="mt-2 text-gray-400">SÃ©lectionnez ou crÃ©ez un projet pour commencer</p>
        </div>
      </div>
    );
  }

  return (
    <div className="flex flex-1 h-screen overflow-hidden">
      {/* Sidebar gauche */}
      <div className="w-64 border-r border-gray-700 flex flex-col">
        {/* En-tÃªte du projet */}
        <div className="p-4 border-b border-gray-700">
          <div className="flex items-center justify-between mb-4">
            <h1 className="text-xl font-semibold text-white">{currentProject.name}</h1>
            <button
              onClick={() => setIsProjectSettingsOpen(true)}
              className="p-2 text-gray-400 hover:text-white rounded-lg transition-colors"
            >
              <Settings size={20} />
            </button>
          </div>
          <p className="text-gray-400 text-sm mb-4">{currentProject.description}</p>
        </div>

        {/* SÃ©lecteur de vue (Chats/Fichiers) */}
        <div className="p-4 border-b border-gray-700">
          <div className="flex gap-2">
            <button
              onClick={() => setShowingChat(true)}
              className={`flex-1 px-3 py-2 rounded-lg transition-colors ${
                showingChat
                  ? 'bg-blue-600 text-white'
                  : 'bg-gray-800 text-gray-300 hover:bg-gray-700'
              }`}
            >
              Chats
            </button>
            <button
              onClick={() => setShowingChat(false)}
              className={`flex-1 px-3 py-2 rounded-lg transition-colors ${
                !showingChat
                  ? 'bg-blue-600 text-white'
                  : 'bg-gray-800 text-gray-300 hover:bg-gray-700'
              }`}
            >
              Fichiers
            </button>
          </div>
        </div>

        {/* Contenu de la sidebar */}
        <div className="flex-1 overflow-y-auto">
          {showingChat ? (
            <div className="p-4 space-y-2">
              <button
                onClick={handleCreateChat}
                className="flex items-center gap-2 w-full bg-gray-800 hover:bg-gray-700 text-white rounded-lg p-2.5 transition-colors"
              >
                <Plus size={20} />
                Nouveau chat
              </button>

              {projectChats.map((chat) => (
                <div
                  key={chat.id}
                  className={`group flex items-center justify-between p-3 rounded-lg cursor-pointer transition-colors ${
                    chat.id === currentChatId
                      ? 'bg-gray-800 text-white'
                      : 'text-gray-300 hover:bg-gray-800/50'
                  }`}
                  onClick={() => setCurrentChat(chat.id)}
                >
                  {editingChatId === chat.id ? (
                    <div className="flex items-center gap-2 flex-1" onClick={e => e.stopPropagation()}>
                      <input
                        type="text"
                        value={editingChatTitle}
                        onChange={(e) => setEditingChatTitle(e.target.value)}
                        className="flex-1 bg-gray-700 text-white rounded px-2 py-1"
                        autoFocus
                      />
                      <button
                        onClick={() => handleSaveChatTitle(chat.id)}
                        className="text-green-500 hover:text-green-400"
                      >
                        <Check size={16} />
                      </button>
                      <button
                        onClick={() => setEditingChatId(null)}
                        className="text-red-500 hover:text-red-400"
                      >
                        <X size={16} />
                      </button>
                    </div>
                  ) : (
                    <>
                      <div className="flex items-center gap-2 flex-1 min-w-0">
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            handleEditChatEmoji(chat.id);
                          }}
                          className="w-6 h-6 flex items-center justify-center hover:bg-gray-700 rounded transition-colors"
                        >
                          {chat.emoji}
                        </button>
                        {editingEmoji === chat.id && (
                          <div onClick={(e) => e.stopPropagation()}>
                            <EmojiPicker
                              onSelect={(emoji) => {
                                updateChatEmoji(chat.id, emoji);
                                setEditingEmoji(null);
                              }}
                              onClose={() => setEditingEmoji(null)}
                            />
                          </div>
                        )}
                        <span className="truncate">{chat.title}</span>
                      </div>
                      <div className="hidden group-hover:flex items-center gap-2">
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            handleEditChat(chat.id, chat.title);
                          }}
                          className="text-gray-400 hover:text-white transition-colors"
                        >
                          <Edit2 size={14} />
                        </button>
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            deleteChat(chat.id);
                          }}
                          className="text-gray-400 hover:text-red-500 transition-colors"
                        >
                          <Trash2 size={14} />
                        </button>
                      </div>
                    </>
                  )}
                </div>
              ))}
            </div>
          ) : (
            <div className="p-4 space-y-2">
              {isPWA ? (
                hasFileSystemAccess ? (
                  <div
                    className="space-y-2"
                    onDragOver={handleDragOver}
                    onDragLeave={handleDragLeave}
                    onDrop={handleDrop}
                  >
                    {isDragging && (
                      <div className="absolute inset-0 bg-blue-500/10 border-2 border-blue-500 border-dashed rounded-lg flex items-center justify-center z-50">
                        <div className="text-blue-500 text-lg font-medium">
                          DÃ©posez vos fichiers ici
                        </div>
                      </div>
                    )}

                    {fileTree && (
                      <FileTree
                        tree={fileTree}
                        onFileSelect={handleFileSelect}
                        onCreateFile={handleCreateFile}
                        onCreateDirectory={handleCreateDirectory}
                        onRename={handleRename}
                        onDelete={handleDeleteEntry}
                        onMove={moveEntry}
                        onCopy={copyEntry}
                        expandedFolders={expandedFolders}
                        onToggleFolder={toggleFolder}
                        fileStats={fileStats}
                        rootDirectory={rootDirectory}
                        selectedFiles={selectedFiles}
                        onFileSelectionChange={handleFileSelectionChange}
                      />
                    )}
                  </div>
                ) : (
                  <button
                    onClick={requestFileSystemAccess}
                    disabled={isLoading}
                    className="flex items-center gap-2 w-full bg-blue-600 hover:bg-blue-700 text-white rounded-lg p-2.5 transition-colors disabled:opacity-50"
                  >
                    <FolderOpen size={20} />
                    {isLoading ? 'Chargement...' : 'SÃ©lectionner un dossier'}
                  </button>
                )
              ) : (
                <div className="text-center p-4 bg-gray-800 rounded-lg">
                  <p className="text-gray-300 mb-2">
                    Pour accÃ©der aux fichiers de votre systÃ¨me, veuillez installer l'application.
                  </p>
                  <p className="text-sm text-gray-400">
                    Cliquez sur l'icÃ´ne d'installation dans la barre d'adresse de votre navigateur.
                  </p>
                </div>
              )}
            </div>
          )}
        </div>
      </div>

      {/* Zone principale */}
      <div className="flex-1 h-full overflow-hidden">
        {showingChat ? (
          <ChatWindow
            projectFiles={currentProject.files}
            systemPrompt={currentProject.systemPrompt}
          />
        ) : selectedFile ? (
          <div className="flex flex-col h-full">
            <div className="p-4 border-b border-gray-700">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <File size={16} className="text-gray-400" />
                  <span className="text-white font-medium">{selectedFile.path}</span>
                  {hasUnsavedChanges && (
                    <span className="text-yellow-500 text-sm">â€¢</span>
                  )}
                </div>
                <div className="flex items-center gap-4">
                  {hasUnsavedChanges && (
                    <button
                      onClick={handleSaveFile}
                      className="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white rounded transition-colors text-sm"
                    >
                      Sauvegarder
                    </button>
                  )}
                </div>
              </div>
            </div>
            <div className="flex-1 overflow-hidden">
              <Editor
                value={selectedFile.content}
                language={selectedFile.language}
                onChange={handleFileChange}
              />
            </div>
          </div>
        ) : (
          <div className="flex-1 flex items-center justify-center bg-gray-800">
            <div className="text-center">
              <p className="text-xl text-gray-300 font-medium">Aucun fichier sÃ©lectionnÃ©</p>
              <p className="mt-2 text-gray-400">
                {isPWA
                  ? hasFileSystemAccess
                    ? 'SÃ©lectionnez un fichier dans l\'arborescence pour commencer Ã  Ã©diter'
                    : 'SÃ©lectionnez un dossier pour accÃ©der Ã  vos fichiers'
                  : 'Installez l\'application pour accÃ©der Ã  vos fichiers'}
              </p>
            </div>
          </div>
        )}
      </div>

      {/* Modal des paramÃ¨tres du projet */}
      <ProjectModal
        isOpen={isProjectSettingsOpen}
        onClose={() => setIsProjectSettingsOpen(false)}
        onSubmit={(data) => {
          updateProject(currentProject.id, data);
          setIsProjectSettingsOpen(false);
        }}
        initialData={{
          ...currentProject,
          selectedFiles,
          fileContents
        }}
        title="ParamÃ¨tres du projet"
      />
    </div>
  );
}
```

src\components\SearchModal.tsx:
```
import React from 'react';
import { Search, File, MessageSquare, FolderOpen } from 'lucide-react';
import { useStore } from '../store';

interface SearchResult {
  id: string;
  type: 'chat' | 'project' | 'file';
  title: string;
  subtitle?: string;
}

export function SearchModal({ isOpen, onClose }: { isOpen: boolean; onClose: () => void }) {
  const { chats, projects } = useStore();
  const [query, setQuery] = React.useState('');
  const [results, setResults] = React.useState<SearchResult[]>([]);

  React.useEffect(() => {
    if (!query.trim()) {
      setResults([]);
      return;
    }

    const searchResults: SearchResult[] = [];
    const searchTerm = query.toLowerCase();

    // Recherche dans les chats
    chats.forEach(chat => {
      if (chat.title.toLowerCase().includes(searchTerm)) {
        searchResults.push({
          id: chat.id,
          type: 'chat',
          title: chat.title,
          subtitle: `Chat - ${chat.model.name}`
        });
      }
    });

    // Recherche dans les projets et leurs fichiers
    projects.forEach(project => {
      if (project.name.toLowerCase().includes(searchTerm)) {
        searchResults.push({
          id: project.id,
          type: 'project',
          title: project.name,
          subtitle: 'Projet'
        });
      }

      project.files.forEach(file => {
        if (file.name.toLowerCase().includes(searchTerm)) {
          searchResults.push({
            id: file.id,
            type: 'file',
            title: file.name,
            subtitle: `Fichier - ${project.name}`
          });
        }
      });
    });

    setResults(searchResults);
  }, [query, chats, projects]);

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/50 flex items-start justify-center pt-[20vh] z-50 animate-fade-in">
      <div className="w-full max-w-2xl bg-zinc-900 rounded-lg shadow-xl border border-zinc-800">
        <div className="p-4 border-b border-zinc-800">
          <div className="flex items-center gap-3">
            <Search className="text-zinc-400" size={20} />
            <input
              type="text"
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              placeholder="Rechercher..."
              className="flex-1 bg-transparent text-white placeholder-zinc-400 focus:outline-none"
              autoFocus
            />
          </div>
        </div>

        <div className="max-h-[60vh] overflow-y-auto">
          {results.length > 0 ? (
            <div className="p-2">
              {results.map((result) => (
                <div
                  key={result.id}
                  className="flex items-center gap-3 p-3 rounded-lg hover:bg-zinc-800 cursor-pointer"
                >
                  {result.type === 'chat' && <MessageSquare size={18} className="text-zinc-400" />}
                  {result.type === 'project' && <FolderOpen size={18} className="text-zinc-400" />}
                  {result.type === 'file' && <File size={18} className="text-zinc-400" />}
                  <div>
                    <div className="text-white">{result.title}</div>
                    {result.subtitle && (
                      <div className="text-sm text-zinc-400">{result.subtitle}</div>
                    )}
                  </div>
                </div>
              ))}
            </div>
          ) : query ? (
            <div className="p-4 text-center text-zinc-400">
              Aucun rÃ©sultat trouvÃ© pour "{query}"
            </div>
          ) : (
            <div className="p-4 text-center text-zinc-400">
              Commencez Ã  taper pour rechercher
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
```

src\components\SettingsModal.tsx:
```
import { X } from 'lucide-react';
import { useStore } from '../store';
import { AI_MODELS } from '../services/ai';

interface SettingsModalProps {
  isOpen: boolean;
  onClose: () => void;
}

export function SettingsModal({ isOpen, onClose }: SettingsModalProps) {
  const { apiKeys, setApiKey } = useStore();

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-gray-900 rounded-lg w-full max-w-md p-6 relative">
        <button
          onClick={onClose}
          className="absolute top-4 right-4 text-gray-400 hover:text-white"
        >
          <X size={20} />
        </button>

        <h2 className="text-xl font-semibold text-white mb-6">ParamÃ¨tres</h2>

        <div className="space-y-6">
          <div className="space-y-4">
            <h3 className="text-lg font-medium text-white">ClÃ©s API</h3>
            {AI_MODELS.map((model) => (
              <div key={model.id} className="space-y-2">
                <label className="block text-sm font-medium text-gray-300">
                  {model.name}
                </label>
                <input
                  type="password"
                  value={apiKeys[model.id] || ''}
                  onChange={(e) => setApiKey(model.id, e.target.value)}
                  className="w-full bg-gray-800 text-white rounded-lg p-2.5 border border-gray-700 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 transition-colors"
                  placeholder={`ClÃ© API ${model.name}`}
                />
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
  );
}
```

src\components\Sidebar.tsx:
```
import React from 'react';
import { Plus, Trash2, Edit2, Check, X, FolderOpen } from 'lucide-react';
import { useStore } from '../store';
import { AI_MODELS } from '../services/ai';
import { ProjectModal } from './ProjectModal';
import { EmojiPicker } from './EmojiPicker';

interface SidebarProps {
  onViewChange: (view: 'chat' | 'project') => void;
  currentView: 'chat' | 'project';
  isCollapsed: boolean;
}

export function Sidebar({ currentView, onViewChange, isCollapsed }: SidebarProps) {
  const {
    chats,
    currentChatId,
    addChat,
    deleteChat,
    setCurrentChat,
    updateChatTitle,
    updateChatEmoji,
    projects,
    currentProjectId,
    addProject,
    deleteProject,
    setCurrentProject,
    updateProject
  } = useStore();

  const [editingTitle, setEditingTitle] = React.useState<string | null>(null);
  const [tempTitle, setTempTitle] = React.useState('');
  const [selectedModel, setSelectedModel] = React.useState(AI_MODELS[0]);
  const [isProjectModalOpen, setIsProjectModalOpen] = React.useState(false);
  const [editingProject, setEditingProject] = React.useState<string | null>(null);
  const [editingEmoji, setEditingEmoji] = React.useState<string | null>(null);

  const generalChats = chats.filter(chat => !chat.projectId);

  const handleEditTitle = (id: string, title: string) => {
    setEditingTitle(id);
    setTempTitle(title);
  };

  const handleSaveTitle = (id: string) => {
    if (tempTitle.trim()) {
      updateChatTitle(id, tempTitle.trim());
    }
    setEditingTitle(null);
  };

  const handleCreateProject = (data: { name: string; description: string; systemPrompt: string }) => {
    addProject(data.name, data.description, data.systemPrompt);
    onViewChange('project');
  };

  const handleUpdateProject = (data: { name: string; description: string; systemPrompt: string }) => {
    if (editingProject) {
      updateProject(editingProject, data);
      setEditingProject(null);
    }
  };

  const handleEditProject = (projectId: string) => {
    const project = projects.find(p => p.id === projectId);
    if (project) {
      setEditingProject(projectId);
      setIsProjectModalOpen(true);
    }
  };

  return (
    <div className="flex flex-col h-full">
      {currentView === 'chat' ? (
        <>
          <div className={`flex items-center ${isCollapsed ? 'justify-center p-2' : 'justify-between p-4'}`}>
            {isCollapsed ? (
              <button
                onClick={() => addChat(selectedModel)}
                className="w-12 h-12 bg-blue-600 hover:bg-blue-700 text-white rounded-lg flex items-center justify-center transition-colors"
                title="Nouvelle conversation"
              >
                <Plus size={24} />
              </button>
            ) : (
              <button
                onClick={() => addChat(selectedModel)}
                className="flex items-center gap-2 w-full bg-blue-600 hover:bg-blue-700 text-white rounded-lg p-2.5 transition-colors"
              >
                <Plus size={20} />
                Nouvelle conversation
              </button>
            )}
          </div>

          <div className="flex-1 overflow-y-auto space-y-2 p-4">
            {isCollapsed ? (
              <div className="flex flex-col items-center gap-2">
                {generalChats.map((chat) => (
                  <button
                    key={chat.id}
                    onClick={() => setCurrentChat(chat.id)}
                    className={`w-10 h-10 flex items-center justify-center rounded-lg transition-colors ${
                      chat.id === currentChatId
                        ? 'bg-blue-600 text-white'
                        : 'bg-gray-800 text-gray-300 hover:bg-gray-700'
                    }`}
                    title={chat.title}
                  >
                    {chat.emoji}
                  </button>
                ))}
              </div>
            ) : (
              generalChats.map((chat) => (
                <div
                  key={chat.id}
                  className={`group flex items-center justify-between p-3 rounded-lg cursor-pointer transition-colors ${
                    chat.id === currentChatId
                      ? 'bg-gray-800 text-white'
                      : 'text-gray-300 hover:bg-gray-800/50'
                  }`}
                  onClick={() => setCurrentChat(chat.id)}
                >
                  <div className="flex items-center gap-3 flex-1 min-w-0">
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        setEditingEmoji(chat.id);
                      }}
                      className="w-6 h-6 flex items-center justify-center hover:bg-gray-700 rounded transition-colors"
                    >
                      {chat.emoji}
                    </button>
                    {editingEmoji === chat.id && (
                      <div onClick={(e) => e.stopPropagation()}>
                        <EmojiPicker
                          onSelect={(emoji) => {
                            updateChatEmoji(chat.id, emoji);
                            setEditingEmoji(null);
                          }}
                          onClose={() => setEditingEmoji(null)}
                        />
                      </div>
                    )}
                    {editingTitle === chat.id ? (
                      <div className="flex items-center gap-2 flex-1">
                        <input
                          type="text"
                          value={tempTitle}
                          onChange={(e) => setTempTitle(e.target.value)}
                          className="flex-1 bg-gray-700 text-white rounded px-2 py-1"
                          onClick={(e) => e.stopPropagation()}
                        />
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            handleSaveTitle(chat.id);
                          }}
                          className="text-green-500 hover:text-green-400"
                        >
                          <Check size={16} />
                        </button>
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            setEditingTitle(null);
                          }}
                          className="text-red-500 hover:text-red-400"
                        >
                          <X size={16} />
                        </button>
                      </div>
                    ) : (
                      <div className="flex items-center gap-2 flex-1 min-w-0">
                        <span className="truncate">{chat.title}</span>
                        <div className="hidden group-hover:flex items-center gap-2">
                          <button
                            onClick={(e) => {
                              e.stopPropagation();
                              handleEditTitle(chat.id, chat.title);
                            }}
                            className="text-gray-400 hover:text-white transition-colors"
                          >
                            <Edit2 size={14} />
                          </button>
                          <button
                            onClick={(e) => {
                              e.stopPropagation();
                              deleteChat(chat.id);
                            }}
                            className="text-gray-400 hover:text-red-500 transition-colors"
                          >
                            <Trash2 size={14} />
                          </button>
                        </div>
                      </div>
                    )}
                  </div>
                </div>
              ))
            )}
          </div>
        </>
      ) : (
        <div className="flex-1 overflow-y-auto p-4 space-y-2">
          {!isCollapsed && (
            <button
              onClick={() => setIsProjectModalOpen(true)}
              className="flex items-center gap-2 w-full bg-blue-600 hover:bg-blue-700 text-white rounded-lg p-2.5 transition-colors mb-4"
            >
              <Plus size={20} />
              Nouveau projet
            </button>
          )}

          {!isCollapsed && projects.map((project) => (
            <div
              key={project.id}
              className={`group flex items-center justify-between p-3 rounded-lg cursor-pointer transition-colors ${
                project.id === currentProjectId
                  ? 'bg-gray-800 text-white'
                  : 'text-gray-300 hover:bg-gray-800/50'
              }`}
              onClick={() => setCurrentProject(project.id)}
            >
              <div className="flex items-center gap-2 flex-1 min-w-0">
                <FolderOpen size={18} />
                <span className="truncate">{project.name}</span>
              </div>
              <div className="hidden group-hover:flex items-center gap-2">
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    handleEditProject(project.id);
                  }}
                  className="text-gray-400 hover:text-white transition-colors"
                >
                  <Edit2 size={14} />
                </button>
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    deleteProject(project.id);
                  }}
                  className="text-gray-400 hover:text-red-500 transition-colors"
                >
                  <Trash2 size={14} />
                </button>
              </div>
            </div>
          ))}
        </div>
      )}
      
      <ProjectModal
        isOpen={isProjectModalOpen}
        onClose={() => {
          setIsProjectModalOpen(false);
          setEditingProject(null);
        }}
        onSubmit={editingProject ? handleUpdateProject : handleCreateProject}
        initialData={editingProject ? projects.find(p => p.id === editingProject) : undefined}
        title={editingProject ? 'Modifier le projet' : 'Nouveau projet'}
      />
    </div>
  );
}
```

src\components\WebcamCapture.tsx:
```
import React, { useRef, useEffect, useState } from 'react';
import { X, Camera } from 'lucide-react';

interface WebcamCaptureProps {
  onCapture: (file: File) => void;
  onClose: () => void;
}

export function WebcamCapture({ onCapture, onClose }: WebcamCaptureProps) {
  const videoRef = useRef<HTMLVideoElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function startVideo() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        if (videoRef.current) {
          videoRef.current.srcObject = stream;
          videoRef.current.play();
        }
      } catch (err: any) {
        setError('Impossible d\'accÃ©der Ã  la webcam');
        console.error(err);
      }
    }
    startVideo();

    return () => {
      if (videoRef.current && videoRef.current.srcObject) {
        const stream = videoRef.current.srcObject as MediaStream;
        stream.getTracks().forEach(track => track.stop());
      }
    };
  }, []);

  const handleCapture = () => {
    if (!videoRef.current || !canvasRef.current) return;
    const video = videoRef.current;
    const canvas = canvasRef.current;
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const ctx = canvas.getContext('2d');
    if (ctx) {
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      canvas.toBlob(blob => {
        if (blob) {
          const file = new File([blob], 'webcam.png', { type: 'image/png' });
          onCapture(file);
          onClose();
        }
      }, 'image/png');
    }
  };

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-gray-900 p-4 rounded-lg relative">
        <button onClick={onClose} className="absolute top-2 right-2 text-gray-400 hover:text-white">
          <X size={20} />
        </button>
        {error ? (
          <p className="text-red-500">{error}</p>
        ) : (
          <>
            <video ref={videoRef} className="w-full max-w-md rounded" autoPlay muted />
            <canvas ref={canvasRef} className="hidden" />
            <div className="mt-4 flex justify-center">
              <button
                onClick={handleCapture}
                className="flex items-center gap-2 bg-blue-600 hover:bg-blue-700 text-white rounded px-4 py-2 transition-colors"
              >
                <Camera size={20} />
                Prendre la photo
              </button>
            </div>
          </>
        )}
      </div>
    </div>
  );
}

```

src\hooks\useFileSystem.ts:
```
import { useState, useEffect, useCallback } from 'react';
import { useStore } from '../store';

// Types pour l'API File System Access
interface FileSystemPermissionDescriptor {
  mode?: 'read' | 'readwrite';
}

interface FileSystemHandle {
  kind: 'file' | 'directory';
  name: string;
  queryPermission?: (desc: FileSystemPermissionDescriptor) => Promise<PermissionState>;
  requestPermission?: (desc: FileSystemPermissionDescriptor) => Promise<PermissionState>;
}

export interface FileSystemDirectoryHandle extends FileSystemHandle {
  kind: 'directory';
  values: () => AsyncIterableIterator<FileSystemHandle>;
  getDirectoryHandle: (name: string, options?: { create?: boolean }) => Promise<FileSystemDirectoryHandle>;
  getFileHandle: (name: string, options?: { create?: boolean }) => Promise<FileSystemFileHandle>;
  removeEntry: (name: string, options?: { recursive?: boolean }) => Promise<void>;
}

interface FileSystemFileHandle extends FileSystemHandle {
  kind: 'file';
  getFile: () => Promise<File>;
  createWritable: () => Promise<FileSystemWritableFileStream>;
}

interface FileSystemWritableFileStream extends WritableStream {
  write: (content: string) => Promise<void>;
  close: () => Promise<void>;
}

// DÃ©claration des APIs manquantes
declare global {
  interface Window {
    showDirectoryPicker: (options?: {
      mode?: 'read' | 'readwrite'
    }) => Promise<FileSystemDirectoryHandle>;
  }
  interface Navigator {
    standalone?: boolean;
  }
}

interface FileSystemState {
  isPWA: boolean;
  hasFileSystemAccess: boolean;
  fileTree: any;
  isLoading: boolean;
  rootDirectory: string;
  fileStats: Record<string, { size: number; lastModified: number; type: string }>;
  searchResults: string[];
  requestFileSystemAccess: () => Promise<void>;
  readFileContent: (path: string) => Promise<string>;
  writeFileContent: (path: string, content: string) => Promise<void>;
  createFile: (path: string, content?: string) => Promise<void>;
  createDirectory: (path: string) => Promise<void>;
  deleteEntry: (path: string) => Promise<void>;
  renameEntry: (oldPath: string, newPath: string) => Promise<void>;
  refreshFileTree: () => Promise<void>;
  watchFileChanges: (callback: (path: string) => void) => () => void;
  searchFiles: (query: string) => Promise<void>;
  getFileStats: (path: string) => Promise<{ size: number; lastModified: number; type: string }>;
  moveEntry: (oldPath: string, newPath: string) => Promise<void>;
  copyEntry: (sourcePath: string, destPath: string) => Promise<void>;
  getGitIgnoredFiles: () => Promise<Set<string>>;
  getAllFilesInDirectory: (path: string) => Promise<string[]>;
}

const REFRESH_INTERVAL = 1000; // 1 seconde

export function useFileSystem(projectId?: string): FileSystemState {
  const [isPWA, setIsPWA] = useState(false);
  const [hasFileSystemAccess, setHasFileSystemAccess] = useState(false);
  const [fileTree, setFileTree] = useState<any>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [directoryHandle, setDirectoryHandle] = useState<FileSystemDirectoryHandle | null>(null);
  const [rootDirectory, setRootDirectory] = useState<string>('');
  const [fileWatcher, setFileWatcher] = useState<number | null>(null);
  const [fileStats, setFileStats] = useState<Record<string, { size: number; lastModified: number; type: string }>>({});
  const [searchResults, setSearchResults] = useState<string[]>([]);
  const [gitIgnoredFiles, setGitIgnoredFiles] = useState<Set<string>>(new Set());

  const { projects, setProjectDirectory } = useStore();
  const currentProject = projectId ? projects.find(p => p.id === projectId) : null;

  // VÃ©rifier si l'application est en mode PWA
  useEffect(() => {
    const isPWACheck = 
      window.matchMedia('(display-mode: standalone)').matches ||
      (navigator as Navigator).standalone ||
      document.referrer.includes('android-app://');
    setIsPWA(isPWACheck);
  }, []);

  // Restaurer le handle du dossier au dÃ©marrage
  useEffect(() => {
    const restoreDirectoryHandle = async () => {
      if (currentProject?.directoryHandle) {
        try {
          const handle = currentProject.directoryHandle as FileSystemDirectoryHandle;
          const permissionState = await handle.queryPermission?.({ mode: 'readwrite' });
          
          if (permissionState === 'granted') {
            setDirectoryHandle(handle);
            setHasFileSystemAccess(true);
            setRootDirectory(handle.name);
            const tree = await buildFileTree(handle);
            setFileTree(tree);
            await loadGitIgnore(handle);
            await updateAllFileStats(handle);
          } else {
            const newPermission = await handle.requestPermission?.({ mode: 'readwrite' });
            if (newPermission === 'granted') {
              setDirectoryHandle(handle);
              setHasFileSystemAccess(true);
              setRootDirectory(handle.name);
              const tree = await buildFileTree(handle);
              setFileTree(tree);
              await loadGitIgnore(handle);
              await updateAllFileStats(handle);
            }
          }
        } catch (error) {
          console.error('Erreur lors de la restauration du handle:', error);
          if (projectId) {
            setProjectDirectory(projectId, null);
          }
        }
      }
    };

    restoreDirectoryHandle();
  }, [currentProject?.directoryHandle, projectId, setProjectDirectory]);

  // Construire l'arborescence des fichiers
  const buildFileTree = async (handle: FileSystemDirectoryHandle, path: string = ''): Promise<any> => {
    const tree: any = {};
    
    for await (const entry of handle.values()) {
      const entryPath = path ? `${path}/${entry.name}` : entry.name;
      
      if (gitIgnoredFiles.has(entryPath)) continue;
      
      if (entry.kind === 'directory') {
        const dirHandle = await handle.getDirectoryHandle(entry.name);
        tree[entry.name] = await buildFileTree(dirHandle, entryPath);
      } else {
        tree[entry.name] = entryPath;
      }
    }
    
    return tree;
  };

  // Charger et parser le .gitignore
  const loadGitIgnore = async (handle: FileSystemDirectoryHandle) => {
    try {
      const gitignoreHandle = await handle.getFileHandle('.gitignore');
      const file = await gitignoreHandle.getFile();
      const content = await file.text();
      
      const patterns = content
        .split('\n')
        .map(line => line.trim())
        .filter(line => line && !line.startsWith('#'));
      
      const ignored = new Set<string>();
      setGitIgnoredFiles(ignored);
    } catch {
      setGitIgnoredFiles(new Set());
    }
  };

  // Mettre Ã  jour les stats de tous les fichiers
  const updateAllFileStats = async (handle: FileSystemDirectoryHandle, path: string = '') => {
    const stats: Record<string, { size: number; lastModified: number; type: string }> = {};
    
    const processEntry = async (entry: FileSystemHandle, entryPath: string) => {
      if (entry.kind === 'file') {
        const fileHandle = entry as FileSystemFileHandle;
        const file = await fileHandle.getFile();
        stats[entryPath] = {
          size: file.size,
          lastModified: file.lastModified,
          type: file.type || 'text/plain'
        };
      } else {
        const dirHandle = entry as FileSystemDirectoryHandle;
        for await (const childEntry of dirHandle.values()) {
          const childPath = entryPath ? `${entryPath}/${childEntry.name}` : childEntry.name;
          await processEntry(childEntry, childPath);
        }
      }
    };
    
    await processEntry(handle, path);
    setFileStats(stats);
  };

  // Obtenir les stats d'un fichier
  const getFileStats = async (path: string) => {
    const handle = await getHandleFromPath(path);
    if (handle.kind !== 'file') {
      throw new Error('Ce n\'est pas un fichier');
    }
    const fileHandle = handle as FileSystemFileHandle;
    const file = await fileHandle.getFile();
    return {
      size: file.size,
      lastModified: file.lastModified,
      type: file.type || 'text/plain'
    };
  };

  // Rechercher des fichiers
  const searchFiles = async (query: string) => {
    if (!query.trim()) {
      setSearchResults([]);
      return;
    }

    const results: string[] = [];
    const searchTerm = query.toLowerCase();
    
    const searchInDirectory = async (handle: FileSystemDirectoryHandle, path: string = '') => {
      for await (const entry of handle.values()) {
        const entryPath = path ? `${path}/${entry.name}` : entry.name;
        
        if (gitIgnoredFiles.has(entryPath)) continue;
        
        if (entry.name.toLowerCase().includes(searchTerm)) {
          results.push(entryPath);
        }
        
        if (entry.kind === 'directory') {
          const dirHandle = await handle.getDirectoryHandle(entry.name);
          await searchInDirectory(dirHandle, entryPath);
        }
      }
    };
    
    if (directoryHandle) {
      await searchInDirectory(directoryHandle);
    }
    
    setSearchResults(results);
  };

  // Obtenir tous les fichiers dans un dossier
  const getAllFilesInDirectory = async (path: string): Promise<string[]> => {
    const handle = await getHandleFromPath(path);
    if (handle.kind !== 'directory') {
      throw new Error('Ce n\'est pas un dossier');
    }

    const files: string[] = [];
    const processDirectory = async (dirHandle: FileSystemDirectoryHandle, currentPath: string) => {
      for await (const entry of dirHandle.values()) {
        const entryPath = `${currentPath}/${entry.name}`;
        if (entry.kind === 'file') {
          files.push(entryPath);
        } else {
          const childHandle = await dirHandle.getDirectoryHandle(entry.name);
          await processDirectory(childHandle, entryPath);
        }
      }
    };

    await processDirectory(handle as FileSystemDirectoryHandle, path);
    return files;
  };

  // Copier un fichier ou dossier
  const copyEntry = async (sourcePath: string, destPath: string) => {
    const sourceHandle = await getHandleFromPath(sourcePath);
    
    if (sourceHandle.kind === 'file') {
      const content = await readFileContent(sourcePath);
      await createFile(destPath, content);
    } else {
      const copyDirectory = async (
        sourceHandle: FileSystemDirectoryHandle,
        targetPath: string
      ) => {
        await createDirectory(targetPath);
        
        for await (const entry of sourceHandle.values()) {
          const newPath = `${targetPath}/${entry.name}`;
          
          if (entry.kind === 'file') {
            const fileHandle = await sourceHandle.getFileHandle(entry.name);
            const content = await (await fileHandle.getFile()).text();
            await createFile(newPath, content);
          } else {
            const dirHandle = await sourceHandle.getDirectoryHandle(entry.name);
            await copyDirectory(dirHandle, newPath);
          }
        }
      };

      await copyDirectory(sourceHandle as FileSystemDirectoryHandle, destPath);
    }
  };

  // DÃ©placer un fichier ou dossier
  const moveEntry = async (oldPath: string, newPath: string) => {
    await copyEntry(oldPath, newPath);
    await deleteEntry(oldPath);
  };

  // Obtenir un handle Ã  partir d'un chemin
  const getHandleFromPath = async (path: string): Promise<FileSystemHandle> => {
    if (!directoryHandle) throw new Error('Pas d\'accÃ¨s au systÃ¨me de fichiers');

    const parts = path.split('/').filter(Boolean);
    let currentHandle: FileSystemHandle = directoryHandle;

    for (const part of parts) {
      if (currentHandle.kind !== 'directory') {
        throw new Error('Chemin invalide');
      }
      const dirHandle = currentHandle as FileSystemDirectoryHandle;
      const isLastPart = part === parts[parts.length - 1];
      if (isLastPart) {
        try {
          currentHandle = await dirHandle.getFileHandle(part);
        } catch {
          currentHandle = await dirHandle.getDirectoryHandle(part);
        }
      } else {
        currentHandle = await dirHandle.getDirectoryHandle(part);
      }
    }

    return currentHandle;
  };

  // Lire le contenu d'un fichier
  const readFileContent = async (path: string): Promise<string> => {
    const handle = await getHandleFromPath(path);
    if (handle.kind !== 'file') {
      throw new Error('Ce n\'est pas un fichier');
    }
    const fileHandle = handle as FileSystemFileHandle;
    const file = await fileHandle.getFile();
    return await file.text();
  };

  // Ã‰crire dans un fichier
  const writeFileContent = async (path: string, content: string): Promise<void> => {
    const handle = await getHandleFromPath(path);
    if (handle.kind !== 'file') {
      throw new Error('Ce n\'est pas un fichier');
    }
    const fileHandle = handle as FileSystemFileHandle;
    const writable = await fileHandle.createWritable();
    await writable.write(content);
    await writable.close();
    await refreshFileTree();
    await updateAllFileStats(directoryHandle!);
  };

  // CrÃ©er un nouveau fichier
  const createFile = async (path: string, content: string = ''): Promise<void> => {
    if (!directoryHandle) throw new Error('Pas d\'accÃ¨s au systÃ¨me de fichiers');

    const parts = path.split('/');
    const fileName = parts.pop()!;
    let currentHandle: FileSystemDirectoryHandle = directoryHandle;

    for (const part of parts) {
      if (part) {
        currentHandle = await currentHandle.getDirectoryHandle(part, { create: true });
      }
    }

    const fileHandle = await currentHandle.getFileHandle(fileName, { create: true });
    const writable = await fileHandle.createWritable();
    await writable.write(content);
    await writable.close();
    await refreshFileTree();
    await updateAllFileStats(directoryHandle);
  };

  // CrÃ©er un nouveau dossier
  const createDirectory = async (path: string): Promise<void> => {
    if (!directoryHandle) throw new Error('Pas d\'accÃ¨s au systÃ¨me de fichiers');

    const parts = path.split('/');
    let currentHandle: FileSystemDirectoryHandle = directoryHandle;

    for (const part of parts) {
      if (part) {
        currentHandle = await currentHandle.getDirectoryHandle(part, { create: true });
      }
    }

    await refreshFileTree();
    await updateAllFileStats(directoryHandle);
  };

  // Supprimer un fichier ou dossier
  const deleteEntry = async (path: string): Promise<void> => {
    if (!directoryHandle) throw new Error('Pas d\'accÃ¨s au systÃ¨me de fichiers');

    const parts = path.split('/');
    const name = parts.pop()!;
    let currentHandle: FileSystemDirectoryHandle = directoryHandle;

    for (const part of parts) {
      if (part) {
        currentHandle = await currentHandle.getDirectoryHandle(part);
      }
    }

    await currentHandle.removeEntry(name, { recursive: true });
    await refreshFileTree();
    await updateAllFileStats(directoryHandle);
  };

  // Renommer un fichier ou dossier
  const renameEntry = async (oldPath: string, newPath: string): Promise<void> => {
    await copyEntry(oldPath, newPath);
    await deleteEntry(oldPath);
    await refreshFileTree();
    await updateAllFileStats(directoryHandle!);
  };

  // RafraÃ®chir l'arborescence
  const refreshFileTree = async () => {
    if (!directoryHandle) return;
    const tree = await buildFileTree(directoryHandle);
    setFileTree(tree);
  };

  // Observer les changements de fichiers
  const watchFileChanges = useCallback((callback: (path: string) => void) => {
    if (fileWatcher) {
      clearInterval(fileWatcher);
    }

    const watcherId = window.setInterval(async () => {
      if (!directoryHandle) return;
      
      try {
        const newTree = await buildFileTree(directoryHandle);
        const stringifiedOldTree = JSON.stringify(fileTree);
        const stringifiedNewTree = JSON.stringify(newTree);
        
        if (stringifiedOldTree !== stringifiedNewTree) {
          setFileTree(newTree);
          await updateAllFileStats(directoryHandle);
          callback(rootDirectory);
        }
      } catch (error) {
        console.error('Erreur lors de la surveillance des fichiers:', error);
      }
    }, REFRESH_INTERVAL);

    setFileWatcher(watcherId);

    return () => {
      if (watcherId) {
        clearInterval(watcherId);
      }
    };
  }, [directoryHandle, fileTree, rootDirectory]);

  // Demander l'accÃ¨s au systÃ¨me de fichiers
  const requestFileSystemAccess = async () => {
    try {
      setIsLoading(true);
      
      const handle = await window.showDirectoryPicker({
        mode: 'readwrite'
      });
      
      setDirectoryHandle(handle);
      setHasFileSystemAccess(true);
      setRootDirectory(handle.name);
      
      if (projectId) {
        setProjectDirectory(projectId, handle);
      }
      
      const tree = await buildFileTree(handle);
      setFileTree(tree);
      await loadGitIgnore(handle);
      await updateAllFileStats(handle);
    } catch (error) {
      console.error('Erreur lors de la demande d\'accÃ¨s aux fichiers:', error);
    } finally {
      setIsLoading(false);
    }
  };

  // Nettoyer le watcher quand le composant est dÃ©montÃ©
  useEffect(() => {
    return () => {
      if (fileWatcher) {
        clearInterval(fileWatcher);
      }
    };
  }, [fileWatcher]);

  // Obtenir la liste des fichiers ignorÃ©s par git
  const getGitIgnoredFiles = async () => {
    return gitIgnoredFiles;
  };

  return {
    isPWA,
    hasFileSystemAccess,
    fileTree,
    isLoading,
    rootDirectory,
    fileStats,
    searchResults,
    requestFileSystemAccess,
    readFileContent,
    writeFileContent,
    createFile,
    createDirectory,
    deleteEntry,
    renameEntry,
    refreshFileTree,
    watchFileChanges,
    searchFiles,
    getFileStats,
    moveEntry,
    copyEntry,
    getGitIgnoredFiles,
    getAllFilesInDirectory
  };
}
```

src\hooks\useKeyboardShortcuts.ts:
```
import { useEffect } from 'react';
import { useStore } from '../store';

export function useKeyboardShortcuts() {
  const { addChat, addProject } = useStore();

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Ctrl/Cmd + K : Recherche globale
      if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
        e.preventDefault();
        // TODO: Ouvrir la recherche globale
      }

      // Ctrl/Cmd + N : Nouveau chat
      if ((e.ctrlKey || e.metaKey) && e.key === 'n') {
        e.preventDefault();
        // TODO: Ouvrir le modal de crÃ©ation de chat
      }

      // Ctrl/Cmd + P : Nouveau projet
      if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
        e.preventDefault();
        // TODO: Ouvrir le modal de crÃ©ation de projet
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [addChat, addProject]);
}
```

src\index.css:
```
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  color-scheme: dark;
}

/* ThÃ¨me global */
body {
  @apply bg-[#0A0A0A] text-white;
}

/* Styles des composants communs */
.btn {
  @apply px-4 py-2 rounded-lg transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-white/20;
}

.btn-primary {
  @apply bg-white text-black hover:bg-white/90;
}

.btn-secondary {
  @apply bg-zinc-800 text-white hover:bg-zinc-700;
}

.input {
  @apply bg-zinc-900 border border-zinc-800 rounded-lg px-4 py-2 text-white placeholder-zinc-400
         focus:outline-none focus:ring-2 focus:ring-white/20 focus:border-transparent
         transition-all duration-200;
}

.card {
  @apply bg-zinc-900 rounded-lg border border-zinc-800;
}

/* Scrollbar personnalisÃ©e */
::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

::-webkit-scrollbar-track {
  @apply bg-zinc-900;
}

::-webkit-scrollbar-thumb {
  @apply bg-zinc-700 rounded-full hover:bg-zinc-600 transition-colors;
}

/* Styles pour le markdown */
.prose {
  @apply prose-invert max-w-none;
}

.prose pre {
  @apply bg-black rounded-lg border border-zinc-800 !important;
}

.prose code {
  @apply bg-zinc-800 text-zinc-200 px-1.5 py-0.5 rounded text-sm !important;
}

.prose pre code {
  @apply bg-transparent p-0 !important;
}

/* Animations */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.animate-fade-in {
  animation: fadeIn 0.2s ease-out;
}

/* Transitions */
.transition-smooth {
  @apply transition-all duration-200 ease-in-out;
}
```

src\main.tsx:
```
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import App from './App.tsx';
import './index.css';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>
);

```

src\services\ai.ts:
```
import OpenAI from 'openai';
import { AIModel } from '../types';

const AI_MODELS: AIModel[] = [
  {
    id: 'gpt',
    name: 'GPT-4o',
    apiEndpoint: 'https://api.openai.com/v1/chat/completions',
    defaultModel: 'gpt-4o',
    supportsStreaming: true,
    supportsFunctionCalling: true
  },
  {
    id: 'claude',
    name: 'Claude',
    apiEndpoint: 'https://api.anthropic.com/v1/messages',
    defaultModel: 'claude-3-opus-20240229',
    supportsStreaming: false,
    supportsFunctionCalling: false
  },
  {
    id: 'mistral',
    name: 'Mistral',
    apiEndpoint: 'https://api.mistral.ai/v1/chat/completions',
    defaultModel: 'mistral-large-latest',
    supportsStreaming: false,
    supportsFunctionCalling: false
  }
];

export async function generateImageDescription(apiKey: string, base64Image: string): Promise<string> {
  if (!apiKey) {
    throw new Error("ClÃ© API GPT-4 requise pour l'analyse d'images");
  }

  const openai = new OpenAI({ 
    apiKey,
    dangerouslyAllowBrowser: true
  });

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "user",
          content: [
            { 
              type: "text", 
              text: `DÃ©cris cette image de maniÃ¨re trÃ¨s prÃ©cise. La premiÃ¨re phrase est obligatoirement une phrase concise qui rÃ©sume l'image, commenÃ§ant par "Tu vois une image qui reprÃ©sente" et de moins de 15 mots. Ensuite tu dÃ©cris trÃ¨s prÃ©cisÃ©ment l'image. S'il y a du texte d'indiquÃ©, tu le rÃ©pÃ¨te entiÃ¨rement. Si l'image est uniquement un screen d'un fichier de code, aprÃ¨s la premiÃ¨re phrase de ta rÃ©ponse tu indiqueras uniquement "Code :" suivi de l'entiÃ¨retÃ© du code affichÃ© sur l'image.` 
            },
            {
              type: "image_url",
              image_url: {
                url: base64Image
              }
            }
          ],
        },
      ],
      max_tokens: 150,
    });

    return response.choices[0]?.message?.content || 'Description non disponible';
  } catch (error: any) {
    console.error('Erreur lors de la gÃ©nÃ©ration de la description:', error);
    throw new Error(`Erreur lors de l'analyse de l'image: ${error.message}`);
  }
}

// DÃ©finition des outils avec additionalProperties: false
const tools = [
  {
    type: "function",
    function: {
      name: "get_current_time",
      description: "Get the current time in a specific timezone",
      parameters: {
        type: "object",
        properties: {
          timezone: {
            type: "string",
            description: "The timezone to get the time for (e.g. 'Europe/Paris')"
          }
        },
        required: ["timezone"],
        additionalProperties: false
      },
      strict: true
    }
  }
];

function get_current_time(timezone: string): string {
  try {
    const now = new Date();
    const formatter = new Intl.DateTimeFormat('fr-FR', { 
      timeZone: timezone, 
      timeStyle: 'medium', 
      dateStyle: 'long' 
    });
    return formatter.format(now);
  } catch (e) {
    return "Fuseau horaire invalide.";
  }
}

/**
 * streamResponse
 * 
 * - Retourne un gÃ©nÃ©rateur asynchrone qui envoie les morceaux de texte renvoyÃ©s par GPT en streaming.
 * - Accumule Ã©galement les appels de fonction (function calling) dans finalToolCalls.
 * - Ã€ la fin du flux, finalToolCalls contiendra la liste des appels de fonction complÃ©tÃ©s (arguments JSON reconstituÃ©s).
 */
export async function* streamResponse(
  model: AIModel,
  apiKey: string,
  messages: { role: string; content: string }[],
  finalToolCalls: Record<number, { name: string; arguments: string }>
) {
  if (model.id !== 'gpt') {
    throw new Error('Le streaming n\'est supportÃ© que pour GPT-4');
  }

  const openai = new OpenAI({
    apiKey,
    dangerouslyAllowBrowser: true
  });

  const stream = await openai.chat.completions.create({
    model: model.defaultModel,
    messages: messages.map(m => ({
      role: m.role === 'assistant' ? 'assistant' : 'user',
      content: m.content
    })),
    stream: true,
    tools: tools,
    store: true,
  });

  for await (const chunk of stream) {
    const choice = chunk.choices[0];
    
    // Si on reÃ§oit du texte
    if (choice?.delta?.content) {
      const contentPart = choice.delta.content;
      console.log(`Chunk: ${contentPart}`);
      yield contentPart;
    }

    // Si on reÃ§oit un (ou plusieurs) appels de fonction
    if (choice?.delta?.tool_calls) {
      const calls = choice.delta.tool_calls;
      const callArray = Array.isArray(calls) ? calls : [calls];
      for (const singleCall of callArray) {
        const index = singleCall.index;
        if (index === undefined) continue;

        // Initialisation de la structure de stockage si besoin
        if (!finalToolCalls[index]) {
          finalToolCalls[index] = {
            name: singleCall?.function?.name || '',
            arguments: singleCall?.function?.arguments || ''
          };
        } else {
          // Accumulation des arguments (ils arrivent en fragments)
          finalToolCalls[index].arguments += singleCall?.function?.arguments || '';
        }

        // Mise Ã  jour du nom de fonction si on le reÃ§oit plus tard
        if (!finalToolCalls[index].name && singleCall?.function?.name) {
          finalToolCalls[index].name = singleCall.function.name;
        }
      }
    }
  }
}

/**
 * ExÃ©cute un Ã©ventuel appel de fonction en local,
 * puis renvoie la rÃ©ponse finale. 
 */
export async function handleFunctionCallsAndRespond(
  model: AIModel,
  apiKey: string,
  conversationSoFar: { role: string; content: string }[],
  finalToolCalls: Record<number, { name: string; arguments: string }>
): Promise<string> {
  console.log('DEBUG: handleFunctionCallsAndRespond -> finalToolCalls =', finalToolCalls);

  // On exÃ©cute pour chaque fonction identifiÃ©e
  const callsResults: string[] = [];
  for (const indexString in finalToolCalls) {
    const call = finalToolCalls[indexString];
    console.log(`DEBUG: Traitement de l'appel de fonction index=${indexString}, name=${call.name}, args="${call.arguments}"`);
    
    if (call.name === 'get_current_time') {
      try {
        const params = JSON.parse(call.arguments || '{}');
        const timezone = params.timezone || 'UTC';
        const result = get_current_time(timezone);
        callsResults.push(`Pour le fuseau "${timezone}", l'heure est: ${result}`);
        console.log(`DEBUG: RÃ©sultat get_current_time("${timezone}") = ${result}`);
      } catch (e) {
        const errMsg = `Erreur de parsing pour get_current_time: ${e}`;
        callsResults.push(errMsg);
        console.log('DEBUG:', errMsg);
      }
    } else {
      console.log(`DEBUG: Appel de fonction non gÃ©rÃ©: ${call.name}`);
    }
  }

  if (callsResults.length === 0) {
    console.log('DEBUG: Aucune fonction valide nâ€™a Ã©tÃ© appelÃ©e ou finalisÃ©e (callsResults vide).');
    return '';
  }

  const newAssistantMessage = `
Voici les rÃ©sultats des fonctions appelÃ©es :

${callsResults.join('\n')}

Tu dois IMPÃ‰RATIVEMENT intÃ©grer ces informations (sans t'en excuser ou les ignorer) dans ta rÃ©ponse finale. 
`.trim();

  console.log('DEBUG: Envoi dâ€™un nouveau message (ROLE=system) Ã  GPT avec le rÃ©sultat des fonctions:\n', newAssistantMessage);

  const openai = new OpenAI({ apiKey, dangerouslyAllowBrowser: true });

  // Remplacez le rÃ´le "assistant" par "system" pour imposer plus fortement la directive 
  const newConversation = [
    ...conversationSoFar,
    { role: 'system', content: newAssistantMessage }
  ];

  const completion = await openai.chat.completions.create({
    model: model.defaultModel,
    messages: newConversation,
    store: true,
    stream: false
  });

  const finalContent = completion.choices[0]?.message?.content || '';
  console.log('DEBUG: GPT renvoie (aprÃ¨s fonction) =', finalContent);
  return finalContent;
}


/**
 * sendMessage
 * 
 * Fonction pour l'appel unique (sans streaming) ou usage standard. 
 * Si useStreaming = true, la fonction n'est plus appelÃ©e
 * (vous utilisez handleSubmit dans ChatWindow qui appelle streamResponse).
 */
export async function sendMessage(
  model: AIModel,
  apiKey: string,
  messages: { role: string; content: string; selectedImages?: string[] }[],
  chatImages?: { id: string; description: string }[],
  useStreaming: boolean = false
) {
  if (!apiKey) {
    throw new Error(`Veuillez fournir une clÃ© API pour ${model.name}`);
  }

  const processedMessages = messages.map(msg => {
    if (msg.selectedImages?.length && chatImages) {
      let content = msg.content;
      msg.selectedImages.forEach(imgId => {
        const image = chatImages.find(img => img.id === imgId);
        if (image) {
          const imageRef = `[Image ${image.id}]`;
          content = content.replace(imageRef, `[Image: ${image.description}]`);
        }
      });
      return { role: msg.role, content };
    }
    return { role: msg.role, content: msg.content };
  });

  if (useStreaming && model.supportsStreaming) {
    // On n'utilise plus sendMessage en streaming dans l'exemple,
    // handleSubmit de ChatWindow.tsx appelle directement streamResponse.
    // Vous pourriez nÃ©anmoins l'adapter si besoin.
    throw new Error('Le streaming direct nâ€™est plus gÃ©rÃ© ici. Utilisez streamResponse et handleFunctionCallsAndRespond.');
  }

  switch (model.id) {
    case 'gpt': {
      const openai = new OpenAI({
        apiKey,
        dangerouslyAllowBrowser: true
      });
      const response = await openai.chat.completions.create({
        model: model.defaultModel,
        messages: processedMessages.map(m => ({
          role: m.role === 'assistant' ? 'assistant' : 'user',
          content: m.content
        })),
        tools: model.supportsFunctionCalling ? tools : undefined,
        store: true,
        stream: false,
      });
      return response.choices[0]?.message?.content || '';
    }
    case 'claude': {
      const headers: Record<string, string> = {
        'Content-Type': 'application/json',
        'x-api-key': apiKey,
        'anthropic-version': '2023-06-01'
      };
      const body = {
        model: model.defaultModel,
        messages: processedMessages.map(m => ({
          role: m.role === 'assistant' ? 'assistant' : 'user',
          content: m.content
        }))
      };
      const response = await fetch(model.apiEndpoint, {
        method: 'POST',
        headers,
        body: JSON.stringify(body)
      });
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data.error?.message || `Erreur avec ${model.name}`);
      }
      return data.content[0]?.text || '';
    }
    case 'mistral': {
      const headers: Record<string, string> = {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      };
      const body = {
        model: model.defaultModel,
        messages: processedMessages.map(m => ({
          role: m.role === 'assistant' ? 'assistant' : 'user',
          content: m.content
        }))
      };
      const response = await fetch(model.apiEndpoint, {
        method: 'POST',
        headers,
        body: JSON.stringify(body)
      });
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data.error?.message || `Erreur avec ${model.name}`);
      }
      return data.choices[0]?.message?.content || '';
    }
    default:
      throw new Error('ModÃ¨le d\'IA non supportÃ©');
  }
}

export { AI_MODELS };

```

src\store.ts:
```
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { AppState, Chat, AIModel, Project, ProjectFile, ChatImage, Message } from './types';

export const useStore = create<AppState>()(
  persist(
    (set, get) => ({
      chats: [],
      projects: [],
      currentChatId: null,
      currentProjectId: null,
      apiKeys: {},

      addChat: (model: AIModel, projectId?: string) => {
        const newChat: Chat = {
          id: crypto.randomUUID(),
          title: 'Nouvelle conversation',
          messages: [],
          model,
          projectId,
          emoji: 'ğŸ’¬',
          images: [],
          streamingEnabled: true,
          systemPrompt: '' // ou une valeur par dÃ©faut
        };

        set((state) => ({
          chats: [...state.chats, newChat],
          currentChatId: newChat.id
        }));
      },

      deleteChat: (id: string) => {
        set((state) => ({
          chats: state.chats.filter((chat) => chat.id !== id),
          currentChatId: state.currentChatId === id ? null : state.currentChatId
        }));
      },

      setCurrentChat: (id: string | null) => {
        set({ currentChatId: id });
      },

      updateChat: (id: string, updates: Partial<Chat>) => {
        set((state) => ({
          chats: state.chats.map((chat) =>
            chat.id === id ? { ...chat, ...updates } : chat
          )
        }));
      },

      addMessage: (
        chatId: string,
        role: Message['role'],
        content: string,
        selectedImages?: string[],
        messageId?: string,
        offline?: boolean
      ) => {
        const id = messageId || crypto.randomUUID();
        const message: Message = {
          id,
          role,
          content,
          timestamp: Date.now(),
          isEditing: false,
          selectedImages,
          offline: offline || false
        };

        set((state) => ({
          chats: state.chats.map((chat) =>
            chat.id === chatId
              ? { ...chat, messages: [...chat.messages, message] }
              : chat
          )
        }));
      },


      clearOfflineFlag: (chatId: string, messageId: string) => {
        set(state => ({
          chats: state.chats.map(chat => {
            if (chat.id === chatId) {
              return {
                ...chat,
                messages: chat.messages.map(msg =>
                  msg.id === messageId ? { ...msg, offline: false } : msg
                )
              };
            }
            return chat;
          })
        }));
      },

      updateMessage: (chatId: string, messageId: string, content: string) => {
        set((state) => ({
          chats: state.chats.map((chat) =>
            chat.id === chatId
              ? {
                ...chat,
                messages: chat.messages.map((msg) =>
                  msg.id === messageId
                    ? { ...msg, content, isEditing: false }
                    : msg
                )
              }
              : chat
          )
        }));
      },

      setMessageEditing: (chatId: string, messageId: string, isEditing: boolean) => {
        set((state) => ({
          chats: state.chats.map((chat) =>
            chat.id === chatId
              ? {
                ...chat,
                messages: chat.messages.map((msg) =>
                  msg.id === messageId ? { ...msg, isEditing } : msg
                )
              }
              : chat
          )
        }));
      },

      updateChatTitle: (chatId: string, title: string) => {
        set((state) => ({
          chats: state.chats.map((chat) =>
            chat.id === chatId ? { ...chat, title } : chat
          )
        }));
      },

      updateChatEmoji: (chatId: string, emoji: string) => {
        set((state) => ({
          chats: state.chats.map((chat) =>
            chat.id === chatId ? { ...chat, emoji } : chat
          )
        }));
      },

      addImageToChat: (chatId: string, image: Omit<ChatImage, 'id'>) => {
        const newImage: ChatImage = {
          ...image,
          id: crypto.randomUUID()
        };

        set((state) => ({
          chats: state.chats.map((chat) =>
            chat.id === chatId
              ? {
                ...chat,
                images: Array.isArray(chat.images)
                  ? [...chat.images, newImage]
                  : [newImage]
              }
              : chat
          )
        }));

        return newImage.id;
      },

      deleteImageFromChat: (chatId: string, imageId: string) => {
        set((state) => ({
          chats: state.chats.map((chat) =>
            chat.id === chatId
              ? {
                ...chat,
                images: Array.isArray(chat.images)
                  ? chat.images.filter((img) => img.id !== imageId)
                  : [],
                messages: chat.messages.map((msg) => ({
                  ...msg,
                  selectedImages: msg.selectedImages?.filter((id) => id !== imageId)
                }))
              }
              : chat
          )
        }));
      },

      getCurrentChat: () => {
        const state = get();
        return state.currentChatId ? (state.chats.find(c => c.id === state.currentChatId) || null) : null;
      },

      addProject: (name: string, description: string, systemPrompt: string) => {
        const newProject: Project = {
          id: crypto.randomUUID(),
          name,
          description,
          systemPrompt,
          files: [],
          created: Date.now(),
          lastModified: Date.now(),
          selectedFiles: new Set<string>(),
          directoryHandle: null
        };

        set((state) => ({
          projects: [...state.projects, newProject],
          currentProjectId: newProject.id
        }));
      },

      deleteProject: (id: string) => {
        set((state) => ({
          projects: state.projects.filter((project) => project.id !== id),
          currentProjectId: state.currentProjectId === id ? null : state.currentProjectId,
          chats: state.chats.filter((chat) => chat.projectId !== id)
        }));
      },

      setCurrentProject: (id: string | null) => {
        set({ currentProjectId: id });
      },

      updateProject: (id: string, updates: Partial<Project>) => {
        set((state) => ({
          projects: state.projects.map((project) =>
            project.id === id
              ? { ...project, ...updates, lastModified: Date.now() }
              : project
          )
        }));
      },

      addFile: (projectId: string, file: Omit<ProjectFile, 'id'>) => {
        const newFile: ProjectFile = {
          ...file,
          id: crypto.randomUUID()
        };

        set((state) => ({
          projects: state.projects.map((project) =>
            project.id === projectId
              ? {
                ...project,
                files: [...project.files, newFile],
                lastModified: Date.now()
              }
              : project
          )
        }));
      },

      updateFile: (projectId: string, fileId: string, content: string) => {
        set((state) => ({
          projects: state.projects.map((project) =>
            project.id === projectId
              ? {
                ...project,
                files: project.files.map((file) =>
                  file.id === fileId
                    ? { ...file, content, lastModified: Date.now() }
                    : file
                ),
                lastModified: Date.now()
              }
              : project
          )
        }));
      },

      deleteFile: (projectId: string, fileId: string) => {
        set((state) => ({
          projects: state.projects.map((project) =>
            project.id === projectId
              ? {
                ...project,
                files: project.files.filter((file) => file.id !== fileId),
                lastModified: Date.now()
              }
              : project
          )
        }));
      },

      setApiKey: (modelId: string, apiKey: string) => {
        set((state) => ({
          apiKeys: { ...state.apiKeys, [modelId]: apiKey }
        }));
      },

      setProjectDirectory: (projectId: string, handle: FileSystemDirectoryHandle | null) => {
        set((state) => ({
          projects: state.projects.map((project) =>
            project.id === projectId
              ? { ...project, directoryHandle: handle }
              : project
          )
        }));
      }
    }),
    {
      name: 'ai-chat-storage',
      partialize: (state) => ({
        chats: state.chats,
        projects: state.projects.map(project => ({
          ...project,
          directoryHandle: undefined // Ne pas persister le handle
        })),
        apiKeys: state.apiKeys
      })
    }
  )
);
```

src\sw-custom.js:
```
// src/sw-custom.js

import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst } from 'workbox-strategies';

// PrÃ©-cachez tous les assets gÃ©nÃ©rÃ©s par Vite
precacheAndRoute(self.__WB_MANIFEST || []);

// Mise en cache Ã  la volÃ©e pour lâ€™API OpenAI (vous pouvez ajouter dâ€™autres rÃ¨gles si besoin)
registerRoute(
  ({ url }) => url.origin === 'https://api.openai.com',
  new NetworkFirst({
    cacheName: 'openai-api-cache',
    plugins: []
  })
);

// Lors d'un background sync, nous ne faisons pas l'appel nous-mÃªmes
// mais nous informons le client pour qu'il procÃ¨de Ã  la synchronisation.
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-messages') {
    event.waitUntil(
      self.clients.matchAll().then((clients) => {
        for (const client of clients) {
          client.postMessage({ type: 'SYNC_OFFLINE_MESSAGES' });
        }
      })
    );
  }
});

```

src\types.ts:
```
export interface Message {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: number;
  isEditing?: boolean;
  selectedImages?: string[];
  offline?: boolean;
}

export interface ChatImage {
  id: string;
  base64: string;
  description: string;
  name: string;
  timestamp: number;
}

export interface ProjectFile {
  id: string;
  name: string;
  path: string;
  content: string;
  language: string;
  lastModified: number;
}

export interface Project {
  id: string;
  name: string;
  description: string;
  systemPrompt: string;
  files: ProjectFile[];
  created: number;
  lastModified: number;
  selectedFiles: Set<string>;
  directoryHandle?: any;
}

export interface HistoryBranch {
  baseMessageId: string;
  branchIndex: number;
  messages: Message[];
}

export interface Chat {
  id: string;
  title: string;
  messages: Message[];
  model: AIModel;
  projectId?: string;
  emoji: string;
  images: ChatImage[];
  streamingEnabled: boolean;
  systemPrompt?: string;
}

export interface AIModel {
  id: 'gpt' | 'claude' | 'mistral';
  name: string;
  apiEndpoint: string;
  defaultModel: string;
  supportsStreaming?: boolean;
  supportsFunctionCalling?: boolean;
}

export interface AppState {
  chats: Chat[];
  projects: Project[];
  currentChatId: string | null;
  currentProjectId: string | null;
  apiKeys: Record<string, string>;

  getCurrentChat: () => Chat | null;

  addChat: (model: AIModel, projectId?: string) => void;
  deleteChat: (id: string) => void;
  setCurrentChat: (id: string | null) => void;
  updateChat: (id: string, updates: Partial<Chat>) => void;
  addMessage: (
    chatId: string,
    role: Message['role'],
    content: string,
    selectedImages?: string[],
    messageId?: string,
    offline?: boolean
  ) => void;
  clearOfflineFlag: (chatId: string, messageId: string) => void;
  updateMessage: (chatId: string, messageId: string, content: string) => void;
  setMessageEditing: (chatId: string, messageId: string, isEditing: boolean) => void;
  updateChatTitle: (chatId: string, title: string) => void;
  updateChatEmoji: (chatId: string, emoji: string) => void;
  addImageToChat: (chatId: string, image: Omit<ChatImage, 'id'>) => string;
  deleteImageFromChat: (chatId: string, imageId: string) => void;

  addProject: (name: string, description: string, systemPrompt: string) => void;
  deleteProject: (id: string) => void;
  setCurrentProject: (id: string | null) => void;
  updateProject: (id: string, updates: Partial<Project>) => void;
  addFile: (projectId: string, file: Omit<ProjectFile, 'id'>) => void;
  updateFile: (projectId: string, fileId: string, content: string) => void;
  deleteFile: (projectId: string, fileId: string) => void;

  setApiKey: (modelId: string, apiKey: string) => void;
  setProjectDirectory: (projectId: string, handle: any | null) => void;
}
```

src\utils\format.ts:
```
export function formatFileSize(bytes: number): string {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }
  
  export function formatDate(timestamp: number): string {
    const date = new Date(timestamp);
    const now = new Date();
    const diff = now.getTime() - date.getTime();
    
    // Moins d'une minute
    if (diff < 60000) {
      return 'Ã€ l\'instant';
    }
    
    // Moins d'une heure
    if (diff < 3600000) {
      const minutes = Math.floor(diff / 60000);
      return `Il y a ${minutes} minute${minutes > 1 ? 's' : ''}`;
    }
    
    // Moins d'un jour
    if (diff < 86400000) {
      const hours = Math.floor(diff / 3600000);
      return `Il y a ${hours} heure${hours > 1 ? 's' : ''}`;
    }
    
    // Moins d'une semaine
    if (diff < 604800000) {
      const days = Math.floor(diff / 86400000);
      return `Il y a ${days} jour${days > 1 ? 's' : ''}`;
    }
    
    // Format standard
    return date.toLocaleDateString('fr-FR', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  }
```

src\utils\offlineMessages.ts:
```
// src/utils/offlineMessages.ts

const DB_NAME = 'offlineMessages';
const STORE_NAME = 'messages';

export function openDB(): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, 1);
    request.onupgradeneeded = () => {
      request.result.createObjectStore(STORE_NAME, { keyPath: 'id' });
    };
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

export async function storePendingMessage(message: any): Promise<void> {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    const request = store.add(message);
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}

export async function getPendingMessages(): Promise<any[]> {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);
    const request = store.getAll();
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

export async function removePendingMessage(id: string): Promise<void> {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    const request = store.delete(id);
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}

```

src\utils\processOfflineMessages.ts:
```
import { sendMessage } from '../services/ai';
import { useStore } from '../store';
import { getPendingMessages, removePendingMessage } from './offlineMessages';

export async function processOfflineMessages() {
  const pendingMessages = await getPendingMessages();
  if (!pendingMessages.length) return;
  const store = useStore.getState();

  // Grouper les messages pending par chatId
  const messagesByChat = pendingMessages.reduce((acc: Record<string, any[]>, msg) => {
    acc[msg.chatId] = acc[msg.chatId] || [];
    acc[msg.chatId].push(msg);
    return acc;
  }, {} as Record<string, any[]>);

  // Pour chaque chat avec des messages offline
  for (const chatId in messagesByChat) {
    try {
      const chat = store.chats.find(c => c.id === chatId);
      if (!chat) continue;
      const apiKey = store.apiKeys[chat.model.id];
      if (!apiKey) continue;

      // Pour chaque message offline pending, on retire l'indicateur offline dans le store
      for (const offlineMsg of messagesByChat[chatId]) {
        store.clearOfflineFlag(chatId, offlineMsg.id);
      }

      // Construire l'historique complet du chat
      const finalMessages = [
        { role: 'system', content: chat.systemPrompt || '' },
        ...chat.messages.filter(m => m.role !== 'system').map(m => ({
          role: m.role,
          content: m.content
        }))
      ];

      // Effectuer une seule requÃªte API pour ce chat
      const response = await sendMessage(chat.model, apiKey, finalMessages, chat.images, false);
      // Ajouter la rÃ©ponse de l'IA dans le chat
      store.addMessage(chatId, 'assistant', response);

      // Supprimer les messages pending pour ce chat de l'IndexedDB
      for (const offlineMsg of messagesByChat[chatId]) {
        await removePendingMessage(offlineMsg.id);
      }
    } catch (error) {
      console.error('Erreur lors de la synchronisation des messages offline:', error);
    }
  }
}

```

src\vite-env.d.ts:
```
/// <reference types="vite/client" />

```

tailwind.config.js:
```
import typography from '@tailwindcss/typography';

/** @type {import('tailwindcss').Config} */
export default {
  content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],
  theme: {
    extend: {
      colors: {
        background: '#0A0A0A',
        surface: '#1A1A1A',
        'surface-light': '#2A2A2A',
        primary: '#FFFFFF',
        secondary: '#A1A1AA',
        accent: '#F5F5F5'
      },
      animation: {
        'fade-in': 'fadeIn 0.2s ease-out',
        'slide-up': 'slideUp 0.3s ease-out',
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' },
        },
        slideUp: {
          '0%': { transform: 'translateY(10px)', opacity: '0' },
          '100%': { transform: 'translateY(0)', opacity: '1' },
        },
      },
    },
  },
  plugins: [typography],
};
```

tsconfig.app.json:
```
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"]
}

```

tsconfig.json:
```
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

```

tsconfig.node.json:
```
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}

```

vite.config.ts:
```
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { VitePWA } from 'vite-plugin-pwa';

export default defineConfig({
  plugins: [
    react(),
    VitePWA({
      // On passe en mode injectManifest pour utiliser notre SW personnalisÃ©.
      strategies: 'injectManifest',
      srcDir: 'src',
      filename: 'sw-custom.js',
      registerType: 'autoUpdate',
      includeAssets: ['icon-192x192.png', 'icon-512x512.png'],
      manifest: {
        name: 'AI Chat App',
        short_name: 'AI Chat',
        description: 'Application de chat avec diffÃ©rentes IAs',
        theme_color: '#0A0A0A',
        background_color: '#0A0A0A',
        display: 'standalone',
        icons: [
          {
            src: '/icon-192x192.png',
            sizes: '192x192',
            type: 'image/png',
            purpose: 'any maskable'
          },
          {
            src: '/icon-512x512.png',
            sizes: '512x512',
            type: 'image/png',
            purpose: 'any maskable'
          }
        ]
      },
      workbox: {
        globPatterns: ['**/*.{js,css,html,ico,png,svg,woff,woff2}'],
        runtimeCaching: [
          {
            urlPattern: /^https:\/\/api\.openai\.com\/.*/i,
            handler: 'NetworkFirst',
            options: {
              cacheName: 'api-cache',
              expiration: {
                maxEntries: 50,
                maxAgeSeconds: 60 * 60 * 24 // 24 heures
              }
            }
          }
        ]
      }
    })
  ],
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          'lucide-react': ['lucide-react']
        }
      }
    }
  }
});

```

