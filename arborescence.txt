📁 Arborescence du projet

├── public
│   ├── icon-192x192.png
│   ├── icon-512x512.png
│   └── manifest.json
├── src
│   ├── components
│   │   ├── ChatWindow.tsx
│   │   ├── Editor.tsx
│   │   ├── EmojiPicker.tsx
│   │   ├── FileContextMenu.tsx
│   │   ├── FileTree.tsx
│   │   ├── ImageGallery.tsx
│   │   ├── ImageUploader.tsx
│   │   ├── MapCapture.tsx
│   │   ├── ProjectModal.tsx
│   │   ├── ProjectPanel.tsx
│   │   ├── SearchModal.tsx
│   │   ├── SettingsModal.tsx
│   │   ├── Sidebar.tsx
│   │   └── WebcamCapture.tsx
│   ├── hooks
│   │   ├── useFileSystem.ts
│   │   └── useKeyboardShortcuts.ts
│   ├── services
│   │   └── ai.ts
│   ├── utils
│   │   ├── format.ts
│   │   ├── offlineMessages.ts
│   │   └── processOfflineMessages.ts
│   ├── App.tsx
│   ├── index.css
│   ├── main.tsx
│   ├── store.ts
│   ├── sw-custom.js
│   ├── types.ts
│   └── vite-env.d.ts
├── .gitignore
├── eslint.config.js
├── index.html
├── package.json
├── postcss.config.js
├── project-bolt-sb1-jzrce3dn.zip
├── README.md
├── tailwind.config.js
├── tsconfig.app.json
├── tsconfig.json
├── tsconfig.node.json
└── vite.config.ts

📄 Contenu des fichiers

.gitignore:
```
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

```

eslint.config.js:
```
import js from '@eslint/js';
import globals from 'globals';
import reactHooks from 'eslint-plugin-react-hooks';
import reactRefresh from 'eslint-plugin-react-refresh';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  }
);

```

index.html:
```
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/icon-192x192.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#0A0A0A" />
    <meta name="description" content="Application de chat avec différentes IAs" />
    <link rel="apple-touch-icon" href="/icon-192x192.png" />
    <link rel="manifest" href="/manifest.json" />
    <title>AI Chat App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```

package.json:
```
{
  "name": "ai-chat-app",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@headlessui/react": "^1.7.18",
    "@monaco-editor/react": "^4.6.0",
    "chalk": "^5.4.1",
    "highlight.js": "^11.9.0",
    "html2canvas": "^1.4.1",
    "inquirer": "^12.4.1",
    "leaflet": "^1.9.4",
    "lucide-react": "^0.344.0",
    "marked": "^12.0.0",
    "openai": "^4.28.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-leaflet": "^4.2.1",
    "react-swipeable": "^7.0.2",
    "strip-ansi": "^7.1.0",
    "zustand": "^4.5.2"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.1",
    "@tailwindcss/typography": "^0.5.10",
    "@types/leaflet": "^1.9.16",
    "@types/react": "^18.3.5",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1",
    "autoprefixer": "^10.4.18",
    "eslint": "^9.9.1",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.11",
    "globals": "^15.9.0",
    "postcss": "^8.4.35",
    "tailwindcss": "^3.4.1",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.3.0",
    "vite": "^5.4.2",
    "vite-plugin-pwa": "^0.19.2"
  }
}

```

postcss.config.js:
```
import tailwindcss from 'tailwindcss';
import autoprefixer from 'autoprefixer';

export default {
  plugins: {
    tailwindcss,
    autoprefixer,
  },
};
```

project-bolt-sb1-jzrce3dn.zip:
```
[CONTENU NON AFFICHÉ - FICHIER BINAIRE]
```

public\icon-192x192.png:
```
[CONTENU NON AFFICHÉ - FICHIER BINAIRE]
```

public\icon-512x512.png:
```
[CONTENU NON AFFICHÉ - FICHIER BINAIRE]
```

public\manifest.json:
```
{
    "name": "AI Chat App",
    "short_name": "AI Chat",
    "description": "Application de chat avec différentes IAs",
    "start_url": "/",
    "display": "standalone",
    "background_color": "#0A0A0A",
    "theme_color": "#0A0A0A",
    "icons": [
      {
        "src": "/icon-192x192.png",
        "sizes": "192x192",
        "type": "image/png",
        "purpose": "any maskable"
      },
      {
        "src": "/icon-512x512.png",
        "sizes": "512x512",
        "type": "image/png",
        "purpose": "any maskable"
      }
    ]
  }
```

README.md:
```
# AI Chat App 🤖

Une application de chat moderne et élégante permettant d'interagir avec différents modèles d'IA (GPT-4, Claude, Mistral), avec support PWA pour une installation sur desktop et mobile.

![Version](https://img.shields.io/badge/version-1.0.0-blue.svg)
![License](https://img.shields.io/badge/license-MIT-green.svg)

## ✨ Fonctionnalités

- 💬 Chat avec différents modèles d'IA (GPT-4, Claude, Mistral)
- 📱 Progressive Web App (PWA) installable
- 🌙 Thème sombre natif
- 📂 Gestion de projets et fichiers
- 🖼️ Support des images avec description automatique
- 💾 Sauvegarde locale des conversations
- ⚡ Streaming des réponses en temps réel
- 📍 Fonctionne hors-ligne
- 🔄 Mise à jour automatique

## 🚀 Installation

1. Clonez le repository :
```bash
git clone https://github.com/Onitsag/Chatbot
cd Chatbot
```

2. Installez les dépendances :
```bash
npm install
```

3. Créez un fichier `.env` à la racine du projet avec vos clés API :
```env
VITE_OPENAI_API_KEY=votre_clé_openai
VITE_ANTHROPIC_API_KEY=votre_clé_anthropic
VITE_MISTRAL_API_KEY=votre_clé_mistral
```

4. Lancez le serveur de développement :
```bash
npm run dev
```

## 🏗️ Build et déploiement

1. Créez une version de production :
```bash
npm run build
```

2. Testez la version de production localement :
```bash
npm run preview
```

## 📱 Installation PWA

### Sur Desktop (Chrome, Edge, etc.)

1. Ouvrez l'application dans votre navigateur
2. Cliquez sur l'icône d'installation dans la barre d'adresse (🔽)
3. Suivez les instructions d'installation

### Sur Android

1. Ouvrez l'application dans Chrome
2. Appuyez sur "Ajouter à l'écran d'accueil"
3. Suivez les instructions d'installation

### Sur iOS

1. Ouvrez l'application dans Safari
2. Appuyez sur le bouton Partager (📤)
3. Sélectionnez "Sur l'écran d'accueil"
4. Confirmez l'installation

## 🧪 Test de la PWA

Pour tester les fonctionnalités PWA :

1. **Mode hors-ligne** :
   - Ouvrez les DevTools (F12)
   - Allez dans l'onglet "Network"
   - Activez "Offline"
   - L'application devrait continuer à fonctionner

2. **Mise en cache** :
   - Les ressources sont automatiquement mises en cache
   - Les appels API sont mis en cache pour 24h
   - Vérifiez dans DevTools > Application > Cache Storage

3. **Mise à jour** :
   - L'application se met à jour automatiquement
   - Une notification apparaît lors des mises à jour

## 🛠️ Technologies utilisées

- React 18
- TypeScript
- Vite
- Tailwind CSS
- Zustand (State management)
- Marked (Markdown parsing)
- Lucide React (Icons)
- PWA (vite-plugin-pwa)

## 📝 Configuration

### Manifest PWA

Le fichier `manifest.json` configure l'apparence et le comportement de l'application installée :

```json
{
  "name": "AI Chat App",
  "short_name": "AI Chat",
  "description": "Application de chat avec différentes IAs",
  "theme_color": "#0A0A0A",
  "background_color": "#0A0A0A",
  "display": "standalone"
}
```

### Service Worker

Le service worker est généré automatiquement par `vite-plugin-pwa` et gère :
- La mise en cache des ressources
- Le fonctionnement hors-ligne
- Les stratégies de cache pour les API
- Les mises à jour automatiques

## 📄 License

MIT License - voir le fichier [LICENSE](LICENSE) pour plus de détails.
```

src\App.tsx:
```
// src/App.tsx
import React, { useEffect, useState } from 'react';
import { Sidebar } from './components/Sidebar';
import { ChatWindow } from './components/ChatWindow';
import { ProjectPanel } from './components/ProjectPanel';
import { useStore } from './store';
import {
  MessageSquare,
  FolderOpen,
  ChevronLeft,
  ChevronRight,
  Settings
} from 'lucide-react';
import { SettingsModal } from './components/SettingsModal';
import { processOfflineMessages } from './utils/processOfflineMessages';
import { useSwipeable } from 'react-swipeable';

export default function App() {
  const { currentProjectId } = useStore();
  const [view, setView] = useState<'chat' | 'project'>('chat');
  const [isSidebarCollapsed, setIsSidebarCollapsed] = useState(false);
  const [isSettingsOpen, setIsSettingsOpen] = useState(false);

  // Demander la permission pour les notifications au démarrage
  useEffect(() => {
    if ("Notification" in window && Notification.permission !== "granted") {
      Notification.requestPermission();
    }
  }, []);

  // Écouter les messages du service worker pour déclencher la synchronisation hors ligne
  useEffect(() => {
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.addEventListener('message', (event) => {
        if (event.data && event.data.type === 'SYNC_OFFLINE_MESSAGES') {
          processOfflineMessages();
        }
      });
    }
  }, []);

  // Lorsqu'on repasse en ligne, lancer la synchronisation
  useEffect(() => {
    const handleOnline = () => {
      processOfflineMessages();
    };
    window.addEventListener('online', handleOnline);
    return () => window.removeEventListener('online', handleOnline);
  }, []);

  // Utilisation de react-swipeable pour gérer l'ouverture/fermeture de la sidebar en mobile
  const swipeHandlers = useSwipeable({
    onSwipedLeft: () => {
      if (window.innerWidth < 768) {
        setIsSidebarCollapsed(true);
      }
    },
    onSwipedRight: () => {
      if (window.innerWidth < 768) {
        setIsSidebarCollapsed(false);
      }
    },
    trackMouse: true // Pour tester avec la souris
  });

  return (
    <div className="flex h-screen bg-gray-900 text-white">
      {/* Sidebar principale avec swipe (sur mobile) */}
      <div
        {...swipeHandlers}
        className={`fixed left-0 top-0 h-screen overflow-y-auto z-50 transition-all duration-300 ease-in-out ${
          isSidebarCollapsed ? 'w-16' : 'w-72'
        }`}
      >
        <div
          className={`flex flex-col w-full h-full bg-gray-900 border-r border-gray-700 ${
            isSidebarCollapsed ? 'items-center' : ''
          }`}
        >
          {/* Navigation principale */}
          <div
            className={`flex p-2 gap-2 border-b border-gray-700 ${
              isSidebarCollapsed ? 'flex-col' : ''
            }`}
          >
            <div className={`flex gap-2 ${isSidebarCollapsed ? 'flex-col' : 'flex-1'}`}>
              <button
                onClick={() => setView('chat')}
                className={`flex items-center gap-2 ${
                  isSidebarCollapsed ? 'w-12 h-12 justify-center' : 'flex-1'
                } px-4 py-2 rounded-lg transition-colors ${
                  view === 'chat'
                    ? 'bg-blue-600 text-white'
                    : 'bg-gray-800 text-gray-300 hover:bg-gray-700'
                }`}
              >
                <MessageSquare size={20} />
                {!isSidebarCollapsed && 'Chat'}
              </button>
              <button
                onClick={() => setView('project')}
                className={`flex items-center gap-2 ${
                  isSidebarCollapsed ? 'w-12 h-12 justify-center' : 'flex-1'
                } px-4 py-2 rounded-lg transition-colors ${
                  view === 'project'
                    ? 'bg-blue-600 text-white'
                    : 'bg-gray-800 text-gray-300 hover:bg-gray-700'
                }`}
              >
                <FolderOpen size={20} />
                {!isSidebarCollapsed && 'Projet'}
              </button>
            </div>
            <button
              onClick={() => setIsSettingsOpen(true)}
              className={`flex items-center justify-center ${
                isSidebarCollapsed ? 'w-12 h-12' : 'w-12'
              } text-gray-400 hover:text-white hover:bg-gray-800 rounded-lg transition-colors`}
              title="Paramètres"
            >
              <Settings size={20} />
            </button>
          </div>

          {/* Sidebar spécifique à la vue */}
          <div className="flex-1 overflow-hidden">
            <Sidebar onViewChange={setView} currentView={view} isCollapsed={isSidebarCollapsed} />
          </div>

          {/* Bouton pour plier/déplier la sidebar */}
          <button
            onClick={() => setIsSidebarCollapsed(!isSidebarCollapsed)}
            className="absolute -right-3 top-1/2 transform -translate-y-1/2 w-6 h-12 bg-gray-900 text-gray-300 hover:text-white rounded-r-lg flex items-center justify-center border-t border-r border-b border-gray-700"
          >
            {isSidebarCollapsed ? <ChevronRight size={16} /> : <ChevronLeft size={16} />}
          </button>
        </div>
      </div>

      {/* Contenu principal avec marge à gauche pour la sidebar */}
      <div className={`flex-1 ${isSidebarCollapsed ? 'ml-16' : 'ml-72'} transition-all duration-300 overflow-hidden`}>
        {view === 'chat' ? <ChatWindow /> : <ProjectPanel />}
      </div>

      <SettingsModal isOpen={isSettingsOpen} onClose={() => setIsSettingsOpen(false)} />
    </div>
  );
}

```

src\components\ChatWindow.tsx:
```
import React from 'react';
import { Send, Edit2, Check, X, Loader, ChevronDown, ToggleLeft, ToggleRight, RotateCw, Camera, MapPin } from 'lucide-react';
import { useStore } from '../store';
import { sendMessage, generateImageDescription, AI_MODELS, streamResponse, handleFunctionCallsAndRespond } from '../services/ai';
import { marked } from 'marked';
import { ProjectFile, ChatImage, AIModel } from '../types';
import { WebcamCapture } from './WebcamCapture';
import { MapCapture } from './MapCapture';
import { storePendingMessage } from '../utils/offlineMessages';
import 'highlight.js/styles/github-dark.css';

/**
 * ChatWindow
 * - Envoie un message system invisible comme 1er message (prompt system).
 * - Permet de choisir la taille d'historique (2 à 30).
 * - @NomImage: pas de description visible, description seulement pour l'IA.
 */
export function ChatWindow({
  projectFiles,
  systemPrompt
}: {
  projectFiles?: ProjectFile[];
  systemPrompt?: string;
}) {
  const {
    chats,
    currentChatId,
    apiKeys,
    addMessage,
    updateMessage,
    setMessageEditing,
    updateChat,
    addImageToChat,
    deleteImageFromChat
  } = useStore();

  // État local
  const [input, setInput] = React.useState('');
  const [isLoading, setIsLoading] = React.useState(false);
  const [isImageLoading, setIsImageLoading] = React.useState(false);
  const [editingContent, setEditingContent] = React.useState('');
  const [error, setError] = React.useState<string | null>(null);
  const [selectedImages, setSelectedImages] = React.useState<ChatImage[]>([]);
  const [showImageSuggestions, setShowImageSuggestions] = React.useState(false);
  const [cursorPosition, setCursorPosition] = React.useState(0);
  const [isDragging, setIsDragging] = React.useState(false);
  const [isModelDropdownOpen, setIsModelDropdownOpen] = React.useState(false);
  const [streamingEnabled, setStreamingEnabled] = React.useState(true);
  const [currentResponse, setCurrentResponse] = React.useState('');
  const [isWebcamOpen, setIsWebcamOpen] = React.useState(false);
  const [isMapOpen, setIsMapOpen] = React.useState(false);


  // Nouvelle fonctionnalité : limiter l'historique
  // On lit localStorage si présent, sinon 15
  const [historySize, setHistorySize] = React.useState(() => {
    const saved = localStorage.getItem('historySize');
    return saved ? parseInt(saved, 10) : 15;
  });

  const [isHistoryDropdownOpen, setIsHistoryDropdownOpen] = React.useState(false);

  const messagesEndRef = React.useRef<HTMLDivElement>(null);
  const suggestionRef = React.useRef<HTMLDivElement>(null);
  const chatContainerRef = React.useRef<HTMLDivElement>(null);
  const dropdownRef = React.useRef<HTMLDivElement>(null);
  const historyDropdownRef = React.useRef<HTMLDivElement>(null);
  const textareaRef = React.useRef<HTMLTextAreaElement>(null);

  // Liste locale d'images
  const [localImages, setLocalImages] = React.useState<ChatImage[]>([]);


  const webcamSupported = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
  const geolocationSupported = 'geolocation' in navigator;


  // Sélection du chat
  const currentChat = chats.find(chat => chat.id === currentChatId);

  React.useEffect(() => {
    localStorage.setItem('historySize', historySize.toString());
  }, [historySize]);

  // ─────────────────────────────────────────────────────────────────────────────
  // 1) Synchronisation localImages
  // ─────────────────────────────────────────────────────────────────────────────
  React.useEffect(() => {
    if (currentChat) {
      setLocalImages([...currentChat.images]);
    }
  }, [currentChat?.id, currentChat?.images.length]);

  // ─────────────────────────────────────────────────────────────────────────────
  // Fonctions utilitaires
  // ─────────────────────────────────────────────────────────────────────────────
  function convertToBase64(file: File): Promise<string> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.readAsDataURL(file);
      reader.onload = () => resolve(reader.result as string);
      reader.onerror = (err) => reject(err);
    });
  }

  function getRandomSuffix(length: number = 5): string {
    return Math.random().toString(36).substring(2, 2 + length);
  }

  function getRandomizedName(originalName: string): string {
    const dotIndex = originalName.lastIndexOf('.');
    let base = originalName;
    let ext = '';
    if (dotIndex !== -1) {
      base = originalName.slice(0, dotIndex);
      ext = originalName.slice(dotIndex);
    }
    const suffix = getRandomSuffix(5);
    return `${base}-${suffix}${ext}`;
  }

  // Convertir MarkDown => HTML
  function toHtml(markdown: string) {
    return marked.parse(markdown, { breaks: true }) as string;
  }

  // Repère @NomImage dans un message => renvoie la liste des images
  function getMentionedImages(content: string): ChatImage[] {
    const mentionRegex = /@([^\s]+)/g;
    const result: ChatImage[] = [];
    let match;
    while ((match = mentionRegex.exec(content)) !== null) {
      const imageName = match[1];
      const found = localImages.find(i => i.name === imageName);
      if (found && !result.some(x => x.id === found.id)) {
        result.push(found);
      }
    }
    return result;
  }

  function triggerNotification(message: string) {
    if ("Notification" in window) {
      if (Notification.permission === "granted") {
        new Notification(message);
      } else if (Notification.permission !== "denied") {
        Notification.requestPermission().then(permission => {
          if (permission === "granted") {
            new Notification(message);
          }
        });
      }
    }
  }

  // ─────────────────────────────────────────────────────────────────────────────
  // 2) Divers useEffects
  // ─────────────────────────────────────────────────────────────────────────────
  // Focus auto
  React.useEffect(() => {
    const handleKeyPress = (e: KeyboardEvent) => {
      if (e.ctrlKey || e.altKey || e.metaKey) return;
      if (e.key.length === 1) {
        const activeElem = document.activeElement as HTMLElement | null;
        if (!activeElem) return;
        const tag = activeElem.tagName.toLowerCase();
        if (tag !== 'textarea' && tag !== 'input') {
          textareaRef.current?.focus();
        }
      }
    };
    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, []);

  // Scroll auto
  React.useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [currentChat?.messages]);

  // Fermer suggestions
  React.useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (suggestionRef.current && !suggestionRef.current.contains(e.target as Node)) {
        setShowImageSuggestions(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  // Coller image
  React.useEffect(() => {
    const handlePaste = async (e: ClipboardEvent) => {
      const items = Array.from(e.clipboardData?.items || []);
      const imageItem = items.find(it => it.type.startsWith('image/'));
      if (imageItem) {
        e.preventDefault();
        const file = imageItem.getAsFile();
        if (file) {
          await processImage(file);
        }
      }
    };
    document.addEventListener('paste', handlePaste);
    return () => document.removeEventListener('paste', handlePaste);
  }, [currentChat?.id, apiKeys]);

  // Fermer dropdown IA
  React.useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(e.target as Node)) {
        setIsModelDropdownOpen(false);
      }
      if (historyDropdownRef.current && !historyDropdownRef.current.contains(e.target as Node)) {
        setIsHistoryDropdownOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  // ─────────────────────────────────────────────────────────────────────────────
  // 3) Pas de chat => ...
  // ─────────────────────────────────────────────────────────────────────────────
  if (!currentChat) {
    return (
      <div className="flex-1 flex items-center justify-center bg-gray-800">
        <div className="text-center">
          <p className="text-xl text-gray-300 font-medium">Aucune conversation sélectionnée</p>
          <p className="mt-2 text-gray-400">Sélectionnez ou créez une conversation pour commencer</p>
        </div>
      </div>
    );
  }

  // ─────────────────────────────────────────────────────────────────────────────
  // processImage => rename + desc + store
  // ─────────────────────────────────────────────────────────────────────────────
  async function processImage(file: File) {
    if (!file.type.startsWith('image/')) {
      setError('Le fichier doit être une image');
      return;
    }
    if (file.size > 5 * 1024 * 1024) {
      setError('L\'image ne doit pas dépasser 5MB');
      return;
    }
    try {
      setError(null);
      setIsImageLoading(true);

      const rName = getRandomizedName(file.name);
      console.log(`[processImage] rename "${file.name}" => "${rName}"`);

      const base64 = await convertToBase64(file);
      if (!currentChat) {
        setError('Aucune conversation sélectionnée');
        return;
      }
      const desc = await generateImageDescription(apiKeys[currentChat.model.id], base64);

      const newImg: ChatImage = {
        id: crypto.randomUUID(),
        base64,
        description: desc,
        name: rName,
        timestamp: Date.now()
      };

      setLocalImages(prev => [...prev, newImg]);
      await addImageToChat(currentChat.id, {
        base64,
        description: desc,
        name: rName,
        timestamp: Date.now()
      });
      console.log('[processImage] Image added =>', rName);
    } catch (err: any) {
      setError(err.message);
      console.error('Erreur lors du traitement de l\'image:', err);
    } finally {
      setIsImageLoading(false);
    }
  }

  // ─────────────────────────────────────────────────────────────────────────────
  // handleStreamingToggle
  // ─────────────────────────────────────────────────────────────────────────────
  function handleStreamingToggle() {
    const newVal = !streamingEnabled;
    setStreamingEnabled(newVal);
    if (!currentChat) {
      setError('Aucune conversation sélectionnée');
      return;
    }
    updateChat(currentChat.id, { streamingEnabled: newVal });
  }

  // ─────────────────────────────────────────────────────────────────────────────
  // handleSubmit => envoi
  // ─────────────────────────────────────────────────────────────────────────────
  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    if (!input.trim() && selectedImages.length === 0) return;
    if (isLoading) return;

    if (!currentChat) {
      setError('Aucune conversation sélectionnée');
      return;
    }
    const apiKey = apiKeys[currentChat.model.id];
    if (!apiKey) {
      setError(`Veuillez entrer une clé API pour ${currentChat.model.name}`);
      return;
    }
    setError(null);

    // Préparer le message en intégrant les descriptions d'images
    const userTyped = input.trim();
    let msgForAI = userTyped;
    for (const img of localImages) {
      const mention = '@' + img.name;
      if (msgForAI.includes(mention)) {
        msgForAI = msgForAI.replace(mention, mention + ` (${img.description})`);
      }
    }
    setInput('');
    setSelectedImages([]);

    // Si hors ligne, on ajoute immédiatement le message avec le flag offline
    if (!navigator.onLine) {
      const offlineId = crypto.randomUUID();
      // Ajout du message avec offline=true (sans modifier le contenu)
      addMessage(currentChat.id, 'user', msgForAI, undefined, offlineId, true);
      // Stocker dans IndexedDB pour la synchronisation ultérieure
      await storePendingMessage({
        id: offlineId,
        chatId: currentChat.id,
        content: msgForAI,
        timestamp: Date.now()
      });
      // Demander la background sync
      if ('serviceWorker' in navigator && 'SyncManager' in window) {
        const reg = await navigator.serviceWorker.ready;
        await (reg as any).sync.register('sync-messages');
      }
      // Notifier une seule fois (stockage dans localStorage pour éviter les doublons)
      if (Notification.permission === "granted" && !localStorage.getItem('offlineSyncNotified')) {
        new Notification("Vous êtes hors ligne. Vos messages seront synchronisés dès le retour de connexion.");
        localStorage.setItem('offlineSyncNotified', 'true');
      }
      return;
    }

    // Si en ligne, envoyer le message normalement (il est affiché dès la saisie)
    addMessage(currentChat.id, 'user', userTyped);
    setIsLoading(true);
    setCurrentResponse('');

    try {
      // Préparation du message système et de l'historique
      const systemBase = `Tu es un assistant IA. Réponds brièvement. L'utilisateur peut t'envoyer des images en mentionnant leur nom, exemple "@image.png". Tu peux voir l'image grâce à la description qui se trouve automatiquement entre parenthèses après la mention de l'image en question.\n`;
      const fullSystem = systemPrompt ? systemBase + "\n" + systemPrompt : systemBase;
      const systemMsg = { role: 'system' as const, content: fullSystem };

      const visibleHistory = currentChat.messages.filter(m => m.role !== 'system');
      const lastMessages = visibleHistory.slice(-historySize);

      const finalMessages = [
        systemMsg,
        ...lastMessages.map(m => ({ role: m.role, content: m.content })),
        { role: 'user' as const, content: msgForAI }
      ];

      if (streamingEnabled && currentChat.model.supportsStreaming) {
        const finalToolCalls: Record<number, { name: string; arguments: string }> = {};
        const streamGen = streamResponse(currentChat.model, apiKey, finalMessages, finalToolCalls);
        let accum = '';
        for await (const chunk of streamGen) {
          accum += chunk;
          setCurrentResponse(accum);
        }
        const addRes = await handleFunctionCallsAndRespond(
          currentChat.model,
          apiKey,
          [...finalMessages, { role: 'assistant', content: accum }],
          finalToolCalls
        );
        let finalAnswer = accum.trim();
        if (addRes.trim()) finalAnswer += '\n\n' + addRes.trim();

        if (finalAnswer) {
          addMessage(currentChat.id, 'assistant', finalAnswer);
        }
      } else {
        const resp = await sendMessage(
          currentChat.model,
          apiKey,
          finalMessages,
          currentChat.images,
          false
        );
        addMessage(currentChat.id, 'assistant', resp);
      }
    } catch (err: any) {
      const msg = err.message || 'Une erreur est survenue';
      setError(msg);
      addMessage(currentChat.id, 'assistant', `⚠️ ${msg}`);
    } finally {
      setIsLoading(false);
      setCurrentResponse('');
    }
  }




  // ─────────────────────────────────────────────────────────────────────────────
  // Édition
  // ─────────────────────────────────────────────────────────────────────────────
  function handleEdit(msg: any) {
    setEditingContent(msg.content);
    if (!currentChat) {
      setError('Aucune conversation sélectionnée');
      return;
    }
    setMessageEditing(currentChat.id, msg.id, true);
  }
  async function handleSaveEdit(msgId: string) {
    // 1. Mettre à jour le contenu du message et sortir du mode édition
    if (!currentChat) {
      setError('Aucune conversation sélectionnée');
      return;
    }
    updateMessage(currentChat.id, msgId, editingContent);
    setMessageEditing(currentChat.id, msgId, false);

    // 2. Réacquérir l'état mis à jour du chat depuis le store
    const updatedChat = useStore.getState().chats.find(chat => chat.id === currentChat.id);
    if (!updatedChat) return;

    // 3. Trouver l'index du message modifié dans l'état actualisé
    const index = updatedChat.messages.findIndex(m => m.id === msgId);
    if (index === -1) return;

    // 4. Tronquer les messages postérieurs au message modifié
    const trimmedMessages = updatedChat.messages.slice(0, index + 1);
    updateChat(updatedChat.id, { messages: trimmedMessages });

    // 5. Réinitialiser l'état local d'édition si nécessaire
    setEditingContent('');

    // 6. Générer une nouvelle réponse de l'IA basée sur le message modifié
    await generateResponseForLastUser();
  }


  function handleCancelEdit(msgId: string) {
    if (!currentChat) {
      setError('Aucune conversation sélectionnée');
      return;
    }
    setMessageEditing(currentChat.id, msgId, false);
  }

  // ─────────────────────────────────────────────────────────────────────────────
  // Regenerate
  // ─────────────────────────────────────────────────────────────────────────────
  async function regenerateMessage(assistantMsgId: string) {
    if (!currentChat) {
      setError('Aucune conversation sélectionnée');
      return;
    }
    const idx = currentChat.messages.findIndex(m => m.id === assistantMsgId);
    if (idx === -1) return;

    // Vider le contenu du message existant avant régénération
    updateMessage(currentChat.id, assistantMsgId, '');

    // Trouver l'index du message utilisateur précédent
    const userIdx = idx - 1;
    if (userIdx < 0 || currentChat.messages[userIdx].role !== 'user') return;

    const userMsg = currentChat.messages[userIdx].content;
    setInput('');
    setIsLoading(true);

    try {
      const apiKey = apiKeys[currentChat.model.id];
      if (!apiKey) {
        setError(`Veuillez entrer une clé API pour ${currentChat.model.name}`);
        return;
      }

      // Construction du message système
      const systemBase = "Tu es Georges, un assistant IA. Réponds brièvement.\n";
      const fullSystem = systemPrompt ? systemBase + "\n" + systemPrompt : systemBase;
      const systemMsg = { role: 'system' as const, content: fullSystem };

      // Préparation de l'historique et récupération des X derniers messages
      const visibleHistory = currentChat.messages.filter(m => m.role !== 'system');
      const lastMessages = visibleHistory.slice(0, idx).slice(-historySize);

      // Intégration des descriptions d'images dans le message utilisateur si nécessaire
      let userForAI = userMsg;
      for (const img of localImages) {
        const mention = '@' + img.name;
        if (userForAI.includes(mention)) {
          userForAI = userForAI.replace(mention, mention + ` (${img.description})`);
        }
      }

      const finalMessages = [
        systemMsg,
        ...lastMessages.map(m => ({ role: m.role, content: m.content })),
        { role: 'user' as const, content: userForAI }
      ];

      if (streamingEnabled && currentChat.model.supportsStreaming) {
        const finalToolCalls: Record<number, { name: string; arguments: string }> = {};
        const streamGen = streamResponse(currentChat.model, apiKey, finalMessages, finalToolCalls);

        let accum = '';
        for await (const chunk of streamGen) {
          accum += chunk;
          // Mise à jour directe du message existant pendant le streaming
          updateMessage(currentChat.id, assistantMsgId, accum);
        }

        const addRes = await handleFunctionCallsAndRespond(
          currentChat.model,
          apiKey,
          [...finalMessages, { role: 'assistant', content: accum }],
          finalToolCalls
        );

        let finalAnswer = accum.trim();
        if (addRes.trim()) finalAnswer += '\n\n' + addRes.trim();

        if (finalAnswer) {
          // Mise à jour finale du message avec la réponse complète
          updateMessage(currentChat.id, assistantMsgId, finalAnswer);
        }
      } else {
        const resp = await sendMessage(
          currentChat.model,
          apiKey,
          finalMessages,
          currentChat.images,
          false
        );
        updateMessage(currentChat.id, assistantMsgId, resp);
      }
    } catch (err: any) {
      const msg = err.message || 'Une erreur est survenue';
      setError(msg);
      updateMessage(currentChat.id, assistantMsgId, `⚠️ ${msg}`);
    } finally {
      setIsLoading(false);
    }
  }

  async function generateResponseForLastUser() {
    // Rechercher le chat actuel directement depuis le store pour obtenir la version mise à jour
    const updatedChat = useStore.getState().chats.find(chat => chat.id === currentChatId);
    if (!updatedChat) return;

    const lastMsg = updatedChat.messages[updatedChat.messages.length - 1];
    if (!lastMsg || lastMsg.role !== 'user') return;

    const apiKey = apiKeys[updatedChat.model.id];
    if (!apiKey) {
      setError(`Veuillez entrer une clé API pour ${updatedChat.model.name}`);
      return;
    }

    setError(null);
    setIsLoading(true);
    setCurrentResponse('');

    // Construction du message système et préparation de l’historique
    const systemBase = "Tu es Georges, un assistant IA. Réponds brièvement.\n";
    const fullSystem = systemPrompt ? systemBase + "\n" + systemPrompt : systemBase;
    const systemMsg = { role: 'system' as const, content: fullSystem };

    // Utiliser updatedChat pour construire l'historique
    const visibleHistory = updatedChat.messages.filter(m => m.role !== 'system');
    const lastMessages = visibleHistory.slice(-historySize);

    // Préparation du message utilisateur pour l’IA (intégration des descriptions d’images si nécessaire)
    let msgForAI = lastMsg.content;
    for (const img of localImages) {
      const mention = '@' + img.name;
      if (msgForAI.includes(mention)) {
        msgForAI = msgForAI.replace(mention, mention + ` (${img.description})`);
      }
    }

    const finalMessages = [
      systemMsg,
      ...lastMessages.map(m => ({ role: m.role, content: m.content })),
      { role: 'user' as const, content: msgForAI }
    ];

    try {
      if (streamingEnabled && updatedChat.model.supportsStreaming) {
        const finalToolCalls: Record<number, { name: string; arguments: string }> = {};
        const streamGen = streamResponse(updatedChat.model, apiKey, finalMessages, finalToolCalls);

        let accum = '';
        for await (const chunk of streamGen) {
          accum += chunk;
          setCurrentResponse(accum);
        }

        const addRes = await handleFunctionCallsAndRespond(
          updatedChat.model,
          apiKey,
          [...finalMessages, { role: 'assistant', content: accum }],
          finalToolCalls
        );

        let finalAnswer = accum.trim();
        if (addRes.trim()) finalAnswer += '\n\n' + addRes.trim();

        if (finalAnswer) {
          addMessage(updatedChat.id, 'assistant', finalAnswer);
        }
      } else {
        const resp = await sendMessage(updatedChat.model, apiKey, finalMessages, updatedChat.images, false);
        addMessage(updatedChat.id, 'assistant', resp);
      }
    } catch (err: any) {
      const msg = err.message || 'Une erreur est survenue';
      setError(msg);
      addMessage(updatedChat.id, 'assistant', `⚠️ ${msg}`);
    } finally {
      setIsLoading(false);
      setCurrentResponse('');
    }
  }



  // ─────────────────────────────────────────────────────────────────────────────
  // handleInputKeyDown + handleInputChange
  // ─────────────────────────────────────────────────────────────────────────────
  function handleInputKeyDown(e: React.KeyboardEvent<HTMLTextAreaElement>) {
    if (e.key === 'Enter' && e.shiftKey) {
      e.stopPropagation();
      return;
    }
    if (e.key === 'Enter' && !e.shiftKey) {
      if (showImageSuggestions) {
        e.preventDefault();
        const arr = getFilteredImages();
        if (arr.length > 0) {
          insertImageMention(arr[0]);
        }
        return;
      }
      e.preventDefault();
      handleSubmit(e);
    }
  }
  function handleInputChange(e: React.ChangeEvent<HTMLTextAreaElement>) {
    const val = e.target.value;
    const pos = e.target.selectionStart || 0;
    setInput(val);
    setCursorPosition(pos);

    // auto-resize
    e.currentTarget.style.height = 'auto';
    const maxHeight = 200;
    e.currentTarget.style.height = Math.min(e.currentTarget.scrollHeight, maxHeight) + 'px';
    if (e.currentTarget.scrollHeight > maxHeight) {
      e.currentTarget.style.overflowY = 'auto';
    } else {
      e.currentTarget.style.overflowY = 'hidden';
    }

    // suggestions
    const textBefore = val.substring(0, pos);
    const lastAt = textBefore.lastIndexOf('@');
    if (lastAt !== -1 && !textBefore.includes(' ', lastAt)) {
      const term = textBefore.substring(lastAt + 1).toLowerCase();
      const found = localImages.some(i => i.name.toLowerCase().includes(term));
      setShowImageSuggestions(found);
    } else {
      setShowImageSuggestions(false);
    }
  }

  // Mentions
  function insertImageMention(img: ChatImage) {
    if (!textareaRef.current) return;
    const text = textareaRef.current.value;
    const lastAtSymbol = text.lastIndexOf('@');
    if (lastAtSymbol !== -1) {
      const before = text.substring(0, lastAtSymbol);
      const after = text.substring(lastAtSymbol);
      const spaceIndex = after.indexOf(' ');
      const newText = before + `@${img.name}` + (spaceIndex >= 0 ? after.substring(spaceIndex) : '');
      setInput(newText);
      setTimeout(() => textareaRef.current?.focus(), 0);
    } else {
      setInput(text + `@${img.name}`);
    }
    setSelectedImages(prev => {
      if (!prev.find(i => i.id === img.id)) {
        return [...prev, img];
      }
      return prev;
    });
    setShowImageSuggestions(false);
  }

  function getFilteredImages() {
    const txt = input.substring(0, cursorPosition);
    const lastAt = txt.lastIndexOf('@');
    if (lastAt === -1) return localImages;
    const searchTerm = txt.substring(lastAt + 1).toLowerCase();
    return localImages.filter(i => i.name.toLowerCase().includes(searchTerm));
  }

  // ─────────────────────────────────────────────────────────────────────────────
  // Drag & drop
  // ─────────────────────────────────────────────────────────────────────────────
  function handleDragOver(e: React.DragEvent) {
    e.preventDefault();
    setIsDragging(true);
  }
  function handleDragLeave(e: React.DragEvent) {
    e.preventDefault();
    setIsDragging(false);
  }
  async function handleDrop(e: React.DragEvent) {
    e.preventDefault();
    setIsDragging(false);
    const items = Array.from(e.dataTransfer.items);
    const files = items
      .filter(i => i.kind === 'file')
      .map(i => i.getAsFile())
      .filter((f): f is File => f !== null);
    for (const file of files) {
      await processImage(file);
    }
  }

  // handleModelChange
  function handleModelChange(model: AIModel) {
    if (!currentChat) {
      setError('Aucune conversation sélectionnée');
      return;
    }
    updateChat(currentChat.id, { model });
    setIsModelDropdownOpen(false);
  }

  // Handle history size
  function handleHistorySizeChange(size: number) {
    setHistorySize(size);
    setIsHistoryDropdownOpen(false);
  }

  // ─────────────────────────────────────────────────────────────────────────────
  // Rendu
  // ─────────────────────────────────────────────────────────────────────────────
  return (
    <div
      ref={chatContainerRef}
      className="flex flex-col h-full bg-gray-800 relative overflow-hidden"
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
    >
      {/* Barre d'en-tête */}
      <div className="flex items-center justify-between px-6 py-4 border-b border-gray-700">
        <h1 className="text-xl font-semibold text-white">{currentChat.title}</h1>

        <div className="flex items-center gap-4 relative">
          {/* Switch streaming */}
          {currentChat.model.id === 'gpt' && (
            <button
              onClick={handleStreamingToggle}
              className="flex items-center gap-2 px-4 py-2 bg-gray-700 
                         hover:bg-gray-600 rounded-lg text-sm text-white transition-colors"
              title={streamingEnabled ? 'Désactiver le streaming' : 'Activer le streaming'}
            >
              {streamingEnabled ? (
                <ToggleRight size={16} className="text-blue-500" />
              ) : (
                <ToggleLeft size={16} />
              )}
              <span>Streaming</span>
            </button>

          )}

          {/* Choix du modèle */}
          <div className="relative" ref={dropdownRef}>
            <button
              onClick={() => setIsModelDropdownOpen(!isModelDropdownOpen)}
              className="flex items-center gap-2 px-4 py-2 bg-gray-700 
                         hover:bg-gray-600 rounded-lg text-sm text-white transition-colors"
            >
              <span>{currentChat.model.name}</span>
              <ChevronDown
                size={16}
                className={`text-gray-400 transition-transform ${isModelDropdownOpen ? 'rotate-180' : ''
                  }`}
              />
            </button>
            {isModelDropdownOpen && (
              <div
                className="absolute right-0 mt-2 w-48 bg-gray-700 rounded-lg shadow-lg
                           border border-gray-600 py-1 z-50"
              >
                {AI_MODELS.map((m) => (
                  <button
                    key={m.id}
                    onClick={() => handleModelChange(m)}
                    className={`w-full px-4 py-2 text-left hover:bg-gray-600 transition-colors ${currentChat.model.id === m.id ? 'bg-gray-600 text-white' : 'text-gray-200'
                      }`}
                  >
                    {m.name}
                  </button>
                ))}
              </div>
            )}
          </div>


          {/* Choix de la taille d'historique */}
          <div className="relative" ref={historyDropdownRef}>
            <button
              onClick={() => setIsHistoryDropdownOpen(!isHistoryDropdownOpen)}
              className="flex items-center gap-2 px-4 py-2 bg-gray-700 
                         hover:bg-gray-600 rounded-lg text-sm text-white transition-colors"
              title="Nombre de messages de l'historique"
            >
              <span>Hist: {historySize}</span>
              <ChevronDown
                size={16}
                className={`text-gray-400 transition-transform ${isHistoryDropdownOpen ? 'rotate-180' : ''
                  }`}
              />
            </button>
            {isHistoryDropdownOpen && (
              <div
                className="absolute right-0 mt-2 w-20 bg-gray-700 rounded-lg shadow-lg
                           border border-gray-600 py-1 z-50 max-h-48 overflow-y-auto"
              >
                {[...Array(29)].map((_, i) => i + 2).map((num) => (
                  <button
                    key={num}
                    onClick={() => handleHistorySizeChange(num)}
                    className={`w-full px-4 py-1 text-left hover:bg-gray-600 transition-colors ${historySize === num ? 'bg-gray-600 text-white' : 'text-gray-200'
                      }`}
                  >
                    {num}
                  </button>
                ))}
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Overlay drag & drop */}
      {isDragging && (
        <div className="absolute inset-0 bg-blue-500/10 border-2 border-blue-500 border-dashed
                       rounded-lg flex items-center justify-center z-50"
        >
          <div className="text-blue-500 text-lg font-medium">
            Déposez votre image ici
          </div>
        </div>
      )}

      {/* Overlay chargement d'image */}
      {isImageLoading && (
        <div className="absolute inset-0 bg-black/50 flex items-center justify-center z-50">
          <div className="bg-gray-800 rounded-lg p-4 flex items-center gap-3">
            <Loader className="animate-spin text-blue-500" size={24} />
            <span className="text-white">Analyse de l'image en cours...</span>
          </div>
        </div>
      )}

      {/* Erreur */}
      {error && (
        <div className="m-4 bg-red-500/10 border border-red-500/50 text-red-500 px-4 py-2 rounded-lg">
          {error}
        </div>
      )}

      {/* Liste de messages */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {currentChat.messages.map((message, idx) => {
          // On ignore role=system visuellement
          if (message.role === 'system') return null;

          const isLastAssistant = (message.role === 'assistant') && (idx === currentChat.messages.length - 1);
          const senderName = (message.role === 'user') ? 'Vous' : currentChat.model.name;

          // On convertit en HTML
          const html = toHtml(message.content);
          // Images mentionnées
          const mentionImages = getMentionedImages(message.content);

          return (
            <div
              key={message.id}
              className={`group max-w-2xl ${message.role === 'user' ? 'ml-auto' : 'mr-auto'}`}
            >
              <div
                className={`
                  rounded-lg p-4 relative
                  ${message.role === 'user' ? 'bg-blue-600 text-white' : 'bg-gray-700 text-white'}
                `}
                style={{ paddingTop: '3rem' }}
              >
                {/* Nom + actions */}
                <div className="absolute top-2 left-2 flex items-center gap-2">
                  <span className="font-bold text-sm text-gray-100">{senderName}</span>
                  {message.role === 'user' && message.offline && (
                    <span className="text-red-500" title="Message non synchronisé">&#x26A0;</span>
                  )}
                </div>
                <div className="absolute top-2 right-2 flex items-center gap-2">
                  <button
                    onClick={() => handleEdit(message)}
                    className="text-gray-300 hover:text-white transition-colors"
                    title="Éditer ce message"
                  >
                    <Edit2 size={16} />
                  </button>
                  {isLastAssistant && message.role === 'assistant' && (
                    <button
                      onClick={() => regenerateMessage(message.id)}
                      className="text-gray-300 hover:text-white transition-colors"
                      title="Regénérer ce message"
                    >
                      <RotateCw size={16} />
                    </button>
                  )}
                </div>

                {message.isEditing ? (
                  <div className="space-y-2">
                    <textarea
                      value={editingContent}
                      onChange={e => setEditingContent(e.target.value)}
                      className="w-full bg-gray-800 text-white rounded p-2 min-h-[100px]"
                    />
                    <div className="flex justify-end gap-2">
                      <button
                        onClick={() => handleSaveEdit(message.id)}
                        className="text-green-500 hover:text-green-400"
                      >
                        <Check size={20} />
                      </button>
                      <button
                        onClick={() => handleCancelEdit(message.id)}
                        className="text-red-500 hover:text-red-400"
                      >
                        <X size={20} />
                      </button>
                    </div>
                  </div>
                ) : (
                  <div
                    dangerouslySetInnerHTML={{ __html: html }}
                    className="prose prose-invert max-w-none"
                  />
                )}
              </div>

              {/* Miniatures d'images mentionnées */}
              {mentionImages.length > 0 && (
                <div className={`flex gap-2 mt-2 ${message.role === 'user' ? 'justify-end' : ''}`}>
                  {mentionImages.map(img => (
                    <div key={img.id} className="w-12 h-12 rounded-lg overflow-hidden">
                      <img
                        src={img.base64}
                        alt={img.description}
                        className="w-full h-full object-cover"
                      />
                    </div>
                  ))}
                </div>
              )}
            </div>
          );
        })}

        {/* Affichage streaming */}
        {isLoading && currentResponse && (
          <div className="group max-w-2xl mr-auto">
            <div className="rounded-lg p-4 bg-gray-700 text-white">
              {currentResponse}
            </div>
          </div>
        )}

        <div ref={messagesEndRef} />
      </div>

      {/* Galerie images en bas */}
      {localImages.length > 0 && (
        <div className="p-2 border-t border-gray-700 bg-gray-850">
          <div className="flex items-center gap-2 overflow-x-auto pb-2 scrollbar-thin scrollbar-thumb-gray-700">
            {localImages.map((img) => (
              <div
                key={img.id}
                className={`
                  flex-shrink-0 group relative w-12 h-12 rounded-lg overflow-hidden
                  ${selectedImages.find(i => i.id === img.id) ? 'ring-2 ring-blue-500' : ''}
                `}
              >
                <div
                  onClick={() => insertImageMention(img)}
                  className="w-full h-full cursor-pointer"
                  title={img.description}
                >
                  <img
                    src={img.base64}
                    alt={img.description}
                    className="w-full h-full object-cover"
                  />
                </div>
                <button
                  onClick={() => {
                    deleteImageFromChat(currentChat.id, img.id);
                    setLocalImages(prev => prev.filter(i => i.id !== img.id));
                    setSelectedImages(prev => prev.filter(i => i.id !== img.id));
                  }}
                  className="absolute top-0.5 right-0.5 p-0.5 bg-red-500
                             text-white rounded-full transition-opacity"
                >
                  <X size={10} />
                </button>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Formulaire de saisie */}
      <form onSubmit={handleSubmit} className="relative p-4 border-t border-gray-700">
        {showImageSuggestions && (
          <div
            ref={suggestionRef}
            className="absolute bottom-full mb-2 w-full bg-gray-800
                       rounded-lg border border-gray-700 shadow-lg
                       max-h-48 overflow-y-auto"
          >
            {getFilteredImages().map(img => (
              <div
                key={img.id}
                onClick={() => insertImageMention(img)}
                className="flex items-center gap-2 p-2 hover:bg-gray-700 cursor-pointer"
              >
                <div className="w-8 h-8 rounded overflow-hidden flex-shrink-0">
                  <img
                    src={img.base64}
                    alt={img.description}
                    className="w-full h-full object-cover"
                  />
                </div>
                <div className="flex flex-col">
                  <span className="text-sm text-white font-medium">{img.name}</span>
                  <span className="text-xs text-gray-400 truncate">{img.description}</span>
                </div>
              </div>
            ))}
          </div>
        )}

        <div className="flex gap-4">
          <textarea
            ref={textareaRef}
            value={input}
            onChange={handleInputChange}
            onKeyDown={handleInputKeyDown}
            placeholder="Écrivez votre message... (Shift+Entrée pour une nouvelle ligne, Entrée pour envoyer)"
            className="flex-1 bg-gray-700 text-white rounded-lg px-4 py-3 focus:outline-none focus:ring-2 focus:ring-blue-500"
            style={{
              minHeight: '50px',
              maxHeight: '200px',
              resize: 'vertical',
              overflowY: 'hidden'
            }}
            rows={1}
            disabled={isLoading}
          />
          {webcamSupported ? (
            <button
              type="button"
              onClick={() => setIsWebcamOpen(true)}
              className="bg-gray-700 text-white rounded-lg px-4 py-3 hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
              title="Prendre une photo avec la webcam"
            >
              <Camera size={20} />
            </button>
          ) : (
            <button
              type="button"
              disabled
              className="bg-gray-500 text-gray-300 rounded-lg px-4 py-3 cursor-not-allowed"
              title="Votre navigateur ne supporte pas la webcam"
            >
              <Camera size={20} />
            </button>
          )}

          {/* Bouton Carte */}
          {geolocationSupported ? (
            <button
              type="button"
              onClick={() => setIsMapOpen(true)}
              className="bg-gray-700 text-white rounded-lg px-4 py-3 hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
              title="Ouvrir la carte"
            >
              <MapPin size={20} />
            </button>
          ) : (
            <button
              type="button"
              disabled
              className="bg-gray-500 text-gray-300 rounded-lg px-4 py-3 cursor-not-allowed"
              title="La géolocalisation n'est pas supportée sur ce navigateur"
            >
              <MapPin size={20} />
            </button>
          )}
          <button
            type="submit"
            disabled={isLoading || (!input.trim() && selectedImages.length === 0)}
            className="bg-blue-600 text-white rounded-lg px-6 py-3 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50 disabled:hover:bg-blue-600"
          >
            <Send size={20} className={isLoading ? 'animate-spin' : ''} />
          </button>
        </div>
      </form>
      {isWebcamOpen && (
        <WebcamCapture
          onCapture={(file: File) => {
            processImage(file).then(() => {
              triggerNotification("Photo prise avec la webcam");
            });
          }}
          onClose={() => setIsWebcamOpen(false)}
        />
      )}
      {isMapOpen && (
        <MapCapture
          onCapture={(file: File) => {
            processImage(file).then(() => {
              triggerNotification("Photo prise depuis la carte");
            });
          }}
          onClose={() => setIsMapOpen(false)}
        />
      )}


    </div>
  );
}
```

src\components\Editor.tsx:
```
import { Editor as MonacoEditor } from '@monaco-editor/react';

interface EditorProps {
  value: string;
  language: string;
  onChange: (value: string) => void;
}

export function Editor({ value, language, onChange }: EditorProps) {
  return (
    <MonacoEditor
      height="100%"
      language={language}
      value={value}
      onChange={(value) => onChange(value || '')}
      theme="vs-dark"
      options={{
        minimap: { enabled: true },
        fontSize: 14,
        wordWrap: 'on',
        automaticLayout: true,
        tabSize: 2,
        scrollBeyondLastLine: false,
        renderWhitespace: 'selection',
        formatOnPaste: true,
        formatOnType: true
      }}
    />
  );
}
```

src\components\EmojiPicker.tsx:
```
import { X } from 'lucide-react';

const EMOJI_CATEGORIES = {
  'Récents': ['💬', '🤖', '💡', '📝', '🎯', '🔍', '📚', '💻'],
  'Visages': ['😊', '🤔', '🤓', '🧐', '🤖', '👾', '🤯', '🥳'],
  'Objets': ['💡', '📝', '📚', '💻', '🔍', '🎯', '🎨', '🎮'],
  'Symboles': ['✨', '💫', '🌟', '⭐', '💭', '🗨️', '💬', '🔆']
};

interface EmojiPickerProps {
  onSelect: (emoji: string) => void;
  onClose: () => void;
}

export function EmojiPicker({ onSelect, onClose }: EmojiPickerProps) {
  return (
    <div className="absolute left-0 top-0 z-50 bg-gray-800 rounded-lg shadow-lg border border-gray-700 p-4 w-64">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-sm font-medium text-gray-200">Choisir un émoji</h3>
        <button
          onClick={onClose}
          className="text-gray-400 hover:text-white transition-colors"
        >
          <X size={16} />
        </button>
      </div>

      <div className="space-y-4">
        {Object.entries(EMOJI_CATEGORIES).map(([category, emojis]) => (
          <div key={category}>
            <h4 className="text-xs font-medium text-gray-400 mb-2">{category}</h4>
            <div className="grid grid-cols-8 gap-1">
              {emojis.map((emoji) => (
                <button
                  key={emoji}
                  onClick={() => {
                    onSelect(emoji);
                    onClose();
                  }}
                  className="w-6 h-6 flex items-center justify-center hover:bg-gray-700 rounded transition-colors"
                >
                  {emoji}
                </button>
              ))}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
```

src\components\FileContextMenu.tsx:
```
import { File, FolderOpen, Edit2, Trash2 } from 'lucide-react';

interface FileContextMenuProps {
  path: string;
  isDirectory: boolean;
  onCreateFile: (path: string) => void;
  onCreateDirectory: (path: string) => void;
  onRename: (path: string) => void;
  onDelete: (path: string) => void;
  onMove: (oldPath: string, newPath: string) => void;  // Ajout de cette ligne
  onCopy: (sourcePath: string, destPath: string) => void;  // Ajout de cette ligne
  position: { x: number; y: number };
}


export function FileContextMenu({
  path,
  isDirectory,
  onCreateFile,
  onCreateDirectory,
  onRename,
  onDelete,
  position
}: FileContextMenuProps) {
  return (
    <div
      className="fixed z-50 w-56 bg-gray-800 rounded-lg shadow-lg border border-gray-700 py-1"
      style={{ top: position.y, left: position.x }}
    >
      {isDirectory && (
        <>
          <button
            className="flex items-center w-full px-4 py-2 text-sm text-gray-300 hover:bg-gray-700"
            onClick={() => onCreateFile(`${path}/nouveau-fichier.txt`)}
          >
            <File size={16} className="mr-2" />
            Nouveau fichier
          </button>
          <button
            className="flex items-center w-full px-4 py-2 text-sm text-gray-300 hover:bg-gray-700"
            onClick={() => onCreateDirectory(`${path}/nouveau-dossier`)}
          >
            <FolderOpen size={16} className="mr-2" />
            Nouveau dossier
          </button>
          <div className="border-t border-gray-700 my-1" />
        </>
      )}
      <button
        className="flex items-center w-full px-4 py-2 text-sm text-gray-300 hover:bg-gray-700"
        onClick={() => onRename(path)}
      >
        <Edit2 size={16} className="mr-2" />
        Renommer
      </button>
      <button
        className="flex items-center w-full px-4 py-2 text-sm text-red-400 hover:bg-gray-700"
        onClick={() => onDelete(path)}
      >
        <Trash2 size={16} className="mr-2" />
        Supprimer
      </button>
    </div>
  );
}
```

src\components\FileTree.tsx:
```
import { useState, useEffect, useRef } from 'react';
import { File, FolderOpen, ChevronRight, Search } from 'lucide-react';
import { FileContextMenu } from './FileContextMenu';

interface FileTreeProps {
  tree: any;
  basePath?: string;
  onFileSelect: (path: string) => void;
  onCreateFile: (path: string) => void;
  onCreateDirectory: (path: string) => void;
  onRename: (path: string) => void;
  onDelete: (path: string) => void;
  onMove: (oldPath: string, newPath: string) => void;
  onCopy: (sourcePath: string, destPath: string) => void;
  expandedFolders: Set<string>;
  onToggleFolder: (path: string) => void;
  rootDirectory?: string;
  fileStats?: Record<string, { size: number; lastModified: number; type: string }>;
  onSearch?: (query: string) => void;
  searchResults?: string[];
  selectedFiles: Set<string>;
  onFileSelectionChange: (path: string, selected: boolean, isDirectory?: boolean) => void;
}

export function FileTree({
  tree,
  basePath = '',
  onFileSelect,
  onCreateFile,
  onCreateDirectory,
  onRename,
  onDelete,
  onMove,
  onCopy,
  expandedFolders,
  onToggleFolder,
  rootDirectory,
  onSearch,
  searchResults,
  selectedFiles,
  onFileSelectionChange
}: FileTreeProps) {
  const [contextMenu, setContextMenu] = useState<{
    path: string;
    isDirectory: boolean;
    position: { x: number; y: number };
  } | null>(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [isDragging, setIsDragging] = useState(false);
  const [draggedItem, setDraggedItem] = useState<string | null>(null);
  const [dropTarget, setDropTarget] = useState<string | null>(null);

  const searchInputRef = useRef<HTMLInputElement>(null);
  const treeRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleClickOutside = () => setContextMenu(null);
    window.addEventListener('click', handleClickOutside);
    return () => window.removeEventListener('click', handleClickOutside);
  }, []);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
        e.preventDefault();
        searchInputRef.current?.focus();
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);

  const handleContextMenu = (e: React.MouseEvent, path: string, isDirectory: boolean) => {
    e.preventDefault();
    setContextMenu({
      path,
      isDirectory,
      position: { x: e.clientX, y: e.clientY }
    });
  };

  const handleDragStart = (e: React.DragEvent, path: string) => {
    setDraggedItem(path);
    setIsDragging(true);
    e.dataTransfer.setData('text/plain', path);
    e.dataTransfer.effectAllowed = 'copyMove';
  };

  const handleDragOver = (e: React.DragEvent, path: string) => {
    e.preventDefault();
    setDropTarget(path);
    e.dataTransfer.dropEffect = e.ctrlKey || e.metaKey ? 'copy' : 'move';
  };

  const handleDrop = async (e: React.DragEvent, targetPath: string) => {
    e.preventDefault();
    setIsDragging(false);
    setDropTarget(null);

    if (!draggedItem) return;

    const sourcePath = draggedItem;
    if (sourcePath === targetPath) return;

    if (e.ctrlKey || e.metaKey) {
      await onCopy(sourcePath, `${targetPath}/${sourcePath.split('/').pop()}`);
    } else {
      await onMove(sourcePath, `${targetPath}/${sourcePath.split('/').pop()}`);
    }

    setDraggedItem(null);
  };

  const handleSearch = (query: string) => {
    setSearchQuery(query);
    onSearch?.(query);
  };

  const renderFileEntry = (name: string, path: string) => (
    <div
      key={path}
      className={`group flex items-center px-2 py-1.5 hover:bg-gray-800/50 rounded-md cursor-pointer transition-colors ${
        dropTarget === path ? 'bg-blue-500/10 border border-blue-500/50' : ''
      }`}
      onClick={(e) => {
        e.stopPropagation();
        onFileSelect(path);
      }}
      onContextMenu={(e) => handleContextMenu(e, path, false)}
      draggable
      onDragStart={(e) => handleDragStart(e, path)}
      onDragOver={(e) => handleDragOver(e, path)}
      onDrop={(e) => handleDrop(e, path)}
    >
      <input
        type="checkbox"
        className="mr-2 h-3 w-3 rounded border-gray-500 text-blue-500 focus:ring-blue-500/50"
        checked={selectedFiles.has(path)}
        onChange={(e) => {
          e.stopPropagation();
          onFileSelectionChange(path, e.target.checked, false);
        }}
        onClick={(e) => e.stopPropagation()}
      />
      <File size={14} className="text-gray-400 flex-shrink-0 mr-2" />
      <span className="truncate text-xs text-gray-200">{name}</span>
    </div>
  );

  const renderFolderContent = (content: any, path: string) => (
    <div className="ml-4 space-y-0.5">
      {Object.entries(content).map(([childName, childValue]) => {
        const childPath = `${path}/${childName}`;
        const isDirectory = typeof childValue === 'object';
        const isChildExpanded = expandedFolders.has(childPath);

        return isDirectory
          ? renderFolderEntry(childName, childPath, childValue, isChildExpanded)
          : renderFileEntry(childName, childPath);
      })}
    </div>
  );

  const renderFolderEntry = (name: string, path: string, content: any, isExpanded: boolean) => (
    <div key={path} className="space-y-0.5">
      <div
        className={`group flex items-center px-2 py-1.5 hover:bg-gray-800/50 rounded-md cursor-pointer transition-colors ${
          dropTarget === path ? 'bg-blue-500/10 border border-blue-500/50' : ''
        }`}
        onClick={(e) => {
          e.stopPropagation();
          onToggleFolder(path);
        }}
        onContextMenu={(e) => handleContextMenu(e, path, true)}
        draggable
        onDragStart={(e) => handleDragStart(e, path)}
        onDragOver={(e) => handleDragOver(e, path)}
        onDrop={(e) => handleDrop(e, path)}
      >
        <input
          type="checkbox"
          className="mr-2 h-3 w-3 rounded border-gray-500 text-blue-500 focus:ring-blue-500/50"
          checked={selectedFiles.has(path)}
          onChange={(e) => {
            e.stopPropagation();
            onFileSelectionChange(path, e.target.checked, true);
          }}
          onClick={(e) => e.stopPropagation()}
        />
        <ChevronRight
          size={14}
          className={`text-gray-400 transition-transform ${isExpanded ? 'rotate-90' : ''} mr-1`}
        />
        <FolderOpen size={14} className="text-yellow-500 mr-2" />
        <span className="truncate text-xs text-gray-200">{name}</span>
      </div>
      {isExpanded && renderFolderContent(content, path)}
    </div>
  );

  return (
    <div className="h-full flex flex-col bg-gray-900" ref={treeRef}>
      {/* Barre de recherche */}
      <div className="sticky top-0 z-10 bg-gray-900/95 backdrop-blur-sm border-b border-gray-700/50 p-3">
        <div className="relative">
          <Search size={14} className="absolute left-2.5 top-1/2 transform -translate-y-1/2 text-gray-400" />
          <input
            ref={searchInputRef}
            type="text"
            value={searchQuery}
            onChange={(e) => handleSearch(e.target.value)}
            placeholder="Rechercher... (Ctrl+F)"
            className="w-full bg-gray-800/50 text-white rounded-md pl-8 pr-3 py-1.5 text-xs focus:outline-none focus:ring-1 focus:ring-blue-500/50"
          />
        </div>
      </div>

      {/* Titre du dossier racine */}
      {rootDirectory && (
        <div className="px-3 pt-3">
          <h2 className="text-sm font-medium text-gray-300">{rootDirectory}</h2>
        </div>
      )}
      
      {/* Liste des fichiers */}
      <div className="flex-1 overflow-y-auto p-3 space-y-0.5">
        {searchQuery ? (
          searchResults && searchResults.length > 0 ? (
            <div className="space-y-0.5">
              {searchResults.map((path) => {
                const name = path.split('/').pop() || '';
                return renderFileEntry(name, path);
              })}
            </div>
          ) : (
            <div className="flex items-center justify-center h-32 text-xs text-gray-400">
              Aucun résultat pour "{searchQuery}"
            </div>
          )
        ) : rootDirectory ? (
          <div className="space-y-0.5">
            {renderFolderContent(tree, rootDirectory)}
          </div>
        ) : (
          Object.entries(tree).map(([name, value]) => {
            const path = name;
            const isDirectory = typeof value === 'object';
            const isExpanded = expandedFolders.has(path);

            return isDirectory
              ? renderFolderEntry(name, path, value, isExpanded)
              : renderFileEntry(name, path);
          })
        )}
      </div>

      {/* Menu contextuel */}
      {contextMenu && (
        <FileContextMenu
          path={contextMenu.path}
          isDirectory={contextMenu.isDirectory}
          onCreateFile={onCreateFile}
          onCreateDirectory={onCreateDirectory}
          onRename={onRename}
          onDelete={onDelete}
          onMove={onMove}
          onCopy={onCopy}
          position={contextMenu.position}
        />
      )}
    </div>
  );
}
```

src\components\ImageGallery.tsx:
```
import React from 'react';
import { X } from 'lucide-react';
import { ChatImage } from '../types';

interface ImageGalleryProps {
  images: ChatImage[];
  selectedImages?: string[];
  onImageSelect?: (imageId: string) => void;
  onImageDelete?: (imageId: string) => void;
  isSelectable?: boolean;
}

export function ImageGallery({
  images,
  selectedImages = [],
  onImageSelect,
  onImageDelete,
  isSelectable = false
}: ImageGalleryProps) {
  const handleImageClick = (imageId: string) => {
    if (isSelectable && onImageSelect) {
      onImageSelect(imageId);
      const textArea = document.querySelector('textarea, input[type="text"]') as HTMLTextAreaElement | HTMLInputElement | null;
      if (textArea) {
        const imageRef = `[Image ${imageId}]`;
        const cursorPos = textArea.selectionStart || 0;
        const textBefore = textArea.value.substring(0, cursorPos);
        const textAfter = textArea.value.substring(cursorPos);
        textArea.value = textBefore + imageRef + textAfter;
        textArea.focus();
        textArea.selectionStart = textArea.selectionEnd = cursorPos + imageRef.length;
      }
    }
  };

  if (images.length === 0) return null;

  return (
    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4">
      {images.map((image) => (
        <div
          key={image.id}
          className={`relative group ${
            isSelectable ? 'cursor-pointer' : ''
          } ${
            selectedImages.includes(image.id)
              ? 'ring-2 ring-blue-500'
              : ''
          }`}
          onClick={() => handleImageClick(image.id)}
        >
          <div className="aspect-square relative overflow-hidden rounded-lg">
            <img
              src={image.base64}
              alt={image.description}
              className="object-cover w-full h-full"
            />
            {onImageDelete && (
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  onImageDelete(image.id);
                }}
                className="absolute top-2 right-2 p-1 bg-red-500 text-white rounded-full opacity-0 group-hover:opacity-100 transition-opacity"
              >
                <X size={14} />
              </button>
            )}
          </div>
          <div className="mt-2 text-sm text-gray-300 line-clamp-2">
            {image.description}
          </div>
        </div>
      ))}
    </div>
  );
}
```

src\components\ImageUploader.tsx:
```
import React from 'react';
import { Upload, X } from 'lucide-react';
import { generateImageDescription } from '../services/ai';

interface ImageUploaderProps {
  onImageUpload: (image: { base64: string; description: string; name: string }) => void;
  apiKey: string;
}

export function ImageUploader({ onImageUpload, apiKey }: ImageUploaderProps) {
  const [isDragging, setIsDragging] = React.useState(false);
  const [isUploading, setIsUploading] = React.useState(false);
  const [error, setError] = React.useState<string | null>(null);

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(true);
  };

  const handleDragLeave = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
  };

  const convertToBase64 = (file: File): Promise<string> => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.readAsDataURL(file);
      reader.onload = () => resolve(reader.result as string);
      reader.onerror = error => reject(error);
    });
  };

  const processImage = async (file: File) => {
    try {
      setIsUploading(true);
      setError(null);

      if (!file.type.startsWith('image/')) {
        throw new Error('Le fichier doit être une image');
      }

      if (file.size > 5 * 1024 * 1024) {
        throw new Error('L\'image ne doit pas dépasser 5MB');
      }

      // Convertir l'image en base64
      const base64 = await convertToBase64(file);

      // Générer la description avec GPT-4 Vision
      const description = await generateImageDescription(apiKey, base64);

      // Envoyer l'image et sa description
      onImageUpload({ base64, description, name: file.name });
    } catch (error: any) {
      setError(error.message);
      console.error('Erreur lors du traitement de l\'image:', error);
    } finally {
      setIsUploading(false);
      setIsDragging(false);
    }
  };

  const handleDrop = async (e: React.DragEvent) => {
    e.preventDefault();
    const file = e.dataTransfer.files[0];
    if (file) {
      await processImage(file);
    }
  };

  const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      await processImage(file);
    }
  };

  return (
    <div className="relative">
      <div
        className={`p-4 border-2 border-dashed rounded-lg transition-colors ${
          isDragging
            ? 'border-blue-500 bg-blue-500/10'
            : 'border-gray-700 hover:border-gray-600'
        }`}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
      >
        <input
          type="file"
          accept="image/*"
          onChange={handleFileSelect}
          className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
          disabled={isUploading}
        />
        <div className="flex flex-col items-center justify-center text-gray-400">
          <Upload size={24} className={`mb-2 ${isUploading ? 'animate-bounce' : ''}`} />
          <p className="text-sm text-center">
            {isUploading
              ? 'Analyse de l\'image en cours...'
              : 'Cliquez ou glissez une image ici'}
          </p>
        </div>
      </div>

      {error && (
        <div className="mt-2 p-2 bg-red-500/10 border border-red-500/50 text-red-500 rounded text-sm flex items-center gap-2">
          <X size={14} />
          {error}
        </div>
      )}
    </div>
  );
}
```

src\components\MapCapture.tsx:
```
import React, { useEffect, useState, useRef } from 'react';
import { X, Check } from 'lucide-react';
import { MapContainer, TileLayer, Marker, useMap } from 'react-leaflet';
import { LatLngExpression } from 'leaflet';
import 'leaflet/dist/leaflet.css';
import html2canvas from 'html2canvas';
import L from 'leaflet';

// Correction des icônes par défaut de Leaflet
L.Icon.Default.mergeOptions({
  iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon-2x.png',
  iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png',
  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png'
});

interface MapCaptureProps {
  onCapture: (file: File) => void;
  onClose: () => void;
}

const DEFAULT_POSITION: LatLngExpression = [46.603354, 1.888333]; // Centre de la France

// Composant pour mettre à jour la vue de la carte
function SetMapView({ position, zoom }: { position: LatLngExpression; zoom: number }) {
  const map = useMap();
  useEffect(() => {
    map.setView(position, zoom);
  }, [position, zoom, map]);
  return null;
}

export function MapCapture({ onCapture, onClose }: MapCaptureProps) {
  const [position, setPosition] = useState<LatLngExpression>(DEFAULT_POSITION);
  const [zoom, setZoom] = useState(13);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const mapRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          setPosition([pos.coords.latitude, pos.coords.longitude]);
          setZoom(16); // Zoom plus important pour se rapprocher
          setLoading(false);
        },
        (err) => {
          console.error("Erreur de géolocalisation :", err);
          setError("Impossible de récupérer votre position, utilisation du centre de la France.");
          setLoading(false);
        }
      );
    } else {
      setError("La géolocalisation n'est pas supportée par votre navigateur.");
      setLoading(false);
    }
  }, []);

  // Capture de la carte via html2canvas avec options CORS
  const handleCapture = async () => {
    if (mapRef.current) {
      try {
        const canvas = await html2canvas(mapRef.current, { useCORS: true, allowTaint: false });
        canvas.toBlob(blob => {
          if (blob) {
            const file = new File([blob], 'map.png', { type: 'image/png' });
            onCapture(file);
            onClose();
          }
        }, 'image/png');
      } catch (err) {
        console.error("Erreur lors de la capture de la carte :", err);
      }
    }
  };

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-gray-900 p-4 rounded-lg relative w-full max-w-2xl">
        <button onClick={onClose} className="absolute top-2 right-2 text-gray-400 hover:text-white">
          <X size={20} />
        </button>
        <h2 className="text-xl text-white mb-4">Sélectionnez une zone sur la carte</h2>
        {loading ? (
          <div className="text-white">Chargement de la carte...</div>
        ) : (
          <div ref={mapRef} className="h-96 w-full">
            <MapContainer center={position} zoom={zoom} style={{ height: '100%', width: '100%' }}>
              <TileLayer
                attribution="&copy; <a href='http://osm.org/copyright'>OpenStreetMap</a> contributors"
                url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
              />
              <SetMapView position={position} zoom={zoom} />
              <Marker position={position} />
            </MapContainer>
          </div>
        )}
        {error && <div className="text-red-500 mt-2">{error}</div>}
        <div className="mt-4 flex justify-end gap-4">
          <button
            onClick={handleCapture}
            className="flex items-center gap-2 bg-blue-600 hover:bg-blue-700 text-white rounded px-4 py-2 transition-colors"
          >
            <Check size={20} />
            Valider la zone
          </button>
        </div>
      </div>
    </div>
  );
}

```

src\components\ProjectModal.tsx:
```
import React from 'react';
import { X } from 'lucide-react';

interface ProjectModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (data: { name: string; description: string; systemPrompt: string }) => void;
  initialData?: {
    name: string;
    description: string;
    systemPrompt: string;
    selectedFiles?: Set<string>;
    fileContents?: Record<string, string>;
  };
  title: string;
}

export function ProjectModal({ isOpen, onClose, onSubmit, initialData, title }: ProjectModalProps) {
  const [formData, setFormData] = React.useState({
    name: initialData?.name || '',
    description: initialData?.description || '',
    systemPrompt: initialData?.systemPrompt || ''
  });

  // Générer le prompt système complet avec les fichiers sélectionnés
  const fullSystemPrompt = React.useMemo(() => {
    let prompt = formData.systemPrompt;

    if (initialData?.selectedFiles?.size && initialData.fileContents) {
      prompt += '\n\nVoici les fichiers du projet :\n';
      
      initialData.selectedFiles.forEach(path => {
        const content = initialData.fileContents ? initialData.fileContents[path] : '';
        if (content) {
          const fileName = path.split('/').pop();
          prompt += `\n\`\`${fileName}\`\`\n\`\`\`\n${content}\n\`\`\`\n`;
        }
      });
    }

    return prompt;
  }, [formData.systemPrompt, initialData?.selectedFiles, initialData?.fileContents]);

  if (!isOpen) return null;

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!formData.name.trim()) return;
    onSubmit(formData);
    onClose();
  };

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-gray-900 rounded-lg w-full max-w-4xl p-6">
        <div className="flex items-center justify-between mb-6">
          <h2 className="text-xl font-semibold text-white">{title}</h2>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-white transition-colors"
          >
            <X size={20} />
          </button>
        </div>

        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-300 mb-1">
              Nom du projet *
            </label>
            <input
              type="text"
              value={formData.name}
              onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
              className="w-full bg-gray-800 text-white rounded-lg p-2.5 border border-gray-700 focus:border-blue-500 focus:ring-1 focus:ring-blue-500"
              required
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-300 mb-1">
              Description
            </label>
            <textarea
              value={formData.description}
              onChange={(e) => setFormData(prev => ({ ...prev, description: e.target.value }))}
              className="w-full bg-gray-800 text-white rounded-lg p-2.5 border border-gray-700 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 min-h-[100px]"
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-300 mb-1">
              Prompt système
            </label>
            <textarea
              value={formData.systemPrompt}
              onChange={(e) => setFormData(prev => ({ ...prev, systemPrompt: e.target.value }))}
              placeholder="Instructions générales pour l'IA concernant ce projet..."
              className="w-full bg-gray-800 text-white rounded-lg p-2.5 border border-gray-700 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 min-h-[100px]"
            />
          </div>

          {initialData?.selectedFiles?.size ? (
            <div>
              <label className="block text-sm font-medium text-gray-300 mb-1">
                Prompt système complet (avec fichiers sélectionnés)
              </label>
              <pre className="w-full bg-gray-800 text-white rounded-lg p-2.5 border border-gray-700 overflow-auto max-h-[400px] text-xs">
                {fullSystemPrompt}
              </pre>
            </div>
          ) : null}

          <div className="flex justify-end gap-4 pt-4">
            <button
              type="button"
              onClick={onClose}
              className="px-4 py-2 text-gray-300 hover:text-white transition-colors"
            >
              Annuler
            </button>
            <button
              type="submit"
              className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors disabled:opacity-50"
              disabled={!formData.name.trim()}
            >
              {initialData ? 'Mettre à jour' : 'Créer le projet'}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}
```

src\components\ProjectPanel.tsx:
```
import { useStore } from '../store';
import { useFileSystem } from '../hooks/useFileSystem';
import { FileTree } from './FileTree';
import { File, Settings, Plus, Trash2, MessageSquare, Upload, Edit2, Check, X, FolderOpen } from 'lucide-react';
import { ProjectFile } from '../types';
import { Editor } from './Editor';
import { ProjectModal } from './ProjectModal';
import { ChatWindow } from './ChatWindow';
import { AI_MODELS } from '../services/ai';
import { EmojiPicker } from './EmojiPicker';
import { useState, useEffect, useRef } from 'react';

export function ProjectPanel() {
  const {
    projects,
    currentProjectId,
    updateProject,
    addFile,
    updateFile,
    deleteFile,
    chats,
    addChat,
    deleteChat,
    currentChatId,
    setCurrentChat,
    setCurrentProject,
    updateChat,
    updateChatEmoji
  } = useStore();

  const [selectedFile, setSelectedFile] = useState<ProjectFile | null>(null);
  const [isProjectSettingsOpen, setIsProjectSettingsOpen] = useState(false);
  const [showingChat, setShowingChat] = useState(false);
  const [isDragging, setIsDragging] = useState(false);
  const [editingChatId, setEditingChatId] = useState<string | null>(null);
  const [editingChatTitle, setEditingChatTitle] = useState('');
  const [editingEmoji, setEditingEmoji] = useState<string | null>(null);
  const [expandedFolders, setExpandedFolders] = useState<Set<string>>(new Set());
  const [isRenaming, setIsRenaming] = useState<string | null>(null);
  const [newName, setNewName] = useState('');
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const [autoSaveInterval, setAutoSaveInterval] = useState<number | null>(null);
  const [lastSavedContent, setLastSavedContent] = useState<string>('');
  const [selectedFiles, setSelectedFiles] = useState<Set<string>>(new Set());
  const [fileContents, setFileContents] = useState<Record<string, string>>({});

  const renameInputRef = useRef<HTMLInputElement>(null);

  const {
    isPWA,
    hasFileSystemAccess,
    fileTree,
    isLoading,
    requestFileSystemAccess,
    readFileContent,
    writeFileContent,
    createFile,
    createDirectory,
    deleteEntry,
    renameEntry,
    refreshFileTree,
    watchFileChanges,
    moveEntry,
    copyEntry,
    fileStats,
    rootDirectory,
    getAllFilesInDirectory
  } = useFileSystem();

  const currentProject = projects.find(p => p.id === currentProjectId);
  const projectChats = chats.filter(chat => chat.projectId === currentProjectId);

  // Reset du chat courant quand on change de projet
  useEffect(() => {
    setCurrentChat(null);
  }, [currentProjectId, setCurrentChat]);

  // Surveillance des changements de fichiers
  useEffect(() => {
    if (hasFileSystemAccess) {
      const unwatch = watchFileChanges(async (path) => {
        if (selectedFile && path === selectedFile.path) {
          const content = await readFileContent(path);
          setSelectedFile(prev => prev ? { ...prev, content } : null);
        }
        refreshFileTree();
      });
      return unwatch;
    }
  }, [hasFileSystemAccess, selectedFile, watchFileChanges, readFileContent, refreshFileTree]);

  // Auto-save
  useEffect(() => {
    if (hasUnsavedChanges && selectedFile) {
      const interval = window.setInterval(async () => {
        try {
          await handleSaveFile();
          console.log('Auto-saved:', selectedFile.path);
        } catch (error) {
          console.error('Auto-save failed:', error);
        }
      }, 30000);

      setAutoSaveInterval(interval);
      return () => clearInterval(interval);
    }
    return () => {};
  }, [hasUnsavedChanges, selectedFile]);

  // Nettoyage de l'intervalle d'auto-save
  useEffect(() => {
    return () => {
      if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
      }
    };
  }, [autoSaveInterval]);

  // Gestion des raccourcis clavier
  useEffect(() => {
    const handleKeyDown = async (e: KeyboardEvent) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 's' && selectedFile) {
        e.preventDefault();
        await handleSaveFile();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [selectedFile]);

  // Mise à jour des fichiers sélectionnés dans le projet
  useEffect(() => {
    if (currentProject && currentProject.selectedFiles) {
      // Convertir l'objet Set sérialisé en véritable Set
      const files = Array.isArray(currentProject.selectedFiles) 
        ? new Set(currentProject.selectedFiles)
        : new Set();
      setSelectedFiles(files);
    } else {
      setSelectedFiles(new Set());
    }
  }, [currentProject]);

  // Chargement du contenu des fichiers sélectionnés
  useEffect(() => {
    const loadSelectedFilesContent = async () => {
      const contents: Record<string, string> = {};
      for (const path of selectedFiles) {
        try {
          contents[path] = await readFileContent(path);
        } catch (error) {
          console.error(`Error loading content for ${path}:`, error);
        }
      }
      setFileContents(contents);
    };

    if (selectedFiles.size > 0) {
      loadSelectedFilesContent();
    }
  }, [selectedFiles, readFileContent]);

  // Gestion des chats
  const handleCreateChat = () => {
    if (!currentProject) return;
    addChat(AI_MODELS[0], currentProject.id);
    setShowingChat(true);
  };

  const handleEditChat = (chatId: string, title: string) => {
    setEditingChatId(chatId);
    setEditingChatTitle(title);
  };

  const handleEditChatEmoji = (chatId: string) => {
    setEditingEmoji(chatId);
  };

  const handleSaveChatTitle = (chatId: string) => {
    if (editingChatTitle.trim()) {
      updateChat(chatId, { title: editingChatTitle.trim() });
    }
    setEditingChatId(null);
    setEditingChatTitle('');
  };

  // Gestion des fichiers
  const handleFileSelect = async (path: string) => {
    if (!hasFileSystemAccess) return;

    if (hasUnsavedChanges) {
      const confirm = window.confirm('Vous avez des modifications non sauvegardées. Voulez-vous continuer ?');
      if (!confirm) return;
    }

    try {
      const content = await readFileContent(path);
      const extension = path.split('.').pop()?.toLowerCase() || '';

      let language = 'plaintext';
      switch (extension) {
        case 'js': language = 'javascript'; break;
        case 'ts':
        case 'tsx': language = 'typescript'; break;
        case 'jsx': language = 'javascript'; break;
        case 'html': language = 'html'; break;
        case 'css': language = 'css'; break;
        case 'json': language = 'json'; break;
        case 'md': language = 'markdown'; break;
        case 'py': language = 'python'; break;
      }

      const file: ProjectFile = {
        id: path,
        name: path.split('/').pop() || '',
        path,
        content,
        language,
        lastModified: Date.now()
      };

      setSelectedFile(file);
      setLastSavedContent(content);
      setHasUnsavedChanges(false);
    } catch (error) {
      console.error('Erreur lors de la lecture du fichier:', error);
    }
  };

  const handleFileChange = async (content: string) => {
    if (!selectedFile) return;
    setSelectedFile(prev => prev ? { ...prev, content } : null);
    setHasUnsavedChanges(content !== lastSavedContent);
  };

  const handleSaveFile = async () => {
    if (!selectedFile || !hasUnsavedChanges) return;

    try {
      await writeFileContent(selectedFile.path, selectedFile.content);
      setLastSavedContent(selectedFile.content);
      setHasUnsavedChanges(false);
      console.log('File saved:', selectedFile.path);
    } catch (error) {
      console.error('Error saving file:', error);
    }
  };

  const handleCreateFile = async (path: string) => {
    try {
      await createFile(path);
      await refreshFileTree();
      handleFileSelect(path);
    } catch (error) {
      console.error('Error creating file:', error);
    }
  };

  const handleCreateDirectory = async (path: string) => {
    try {
      await createDirectory(path);
      await refreshFileTree();
      setExpandedFolders(prev => new Set([...prev, path]));
    } catch (error) {
      console.error('Error creating directory:', error);
    }
  };

  const handleDeleteEntry = async (path: string) => {
    const confirm = window.confirm('Êtes-vous sûr de vouloir supprimer cet élément ?');
    if (!confirm) return;

    try {
      if (selectedFile?.path === path) {
        setSelectedFile(null);
      }
      await deleteEntry(path);
      await refreshFileTree();
    } catch (error) {
      console.error('Error deleting entry:', error);
    }
  };

  const handleRename = (path: string) => {
    setIsRenaming(path);
    setNewName(path.split('/').pop() || '');
    setTimeout(() => renameInputRef.current?.focus(), 0);
  };

  const handleRenameSubmit = async (oldPath: string) => {
    if (!newName.trim()) return;

    try {
      const parts = oldPath.split('/');
      parts.pop();
      const newPath = [...parts, newName].join('/');

      await renameEntry(oldPath, newPath);

      if (selectedFile?.path === oldPath) {
        setSelectedFile(prev => prev ? { ...prev, path: newPath, name: newName } : null);
      }

      setIsRenaming(null);
      setNewName('');
      await refreshFileTree();
    } catch (error) {
      console.error('Error renaming entry:', error);
    }
  };

  const toggleFolder = (path: string) => {
    setExpandedFolders(prev => {
      const next = new Set(prev);
      if (next.has(path)) {
        next.delete(path);
      } else {
        next.add(path);
      }
      return next;
    });
  };

  const handleFileSelectionChange = async (path: string, selected: boolean, isDirectory?: boolean) => {
    const newSelectedFiles = new Set(selectedFiles);
    
    if (isDirectory) {
      try {
        const files = await getAllFilesInDirectory(path);
        if (selected) {
          files.forEach(file => newSelectedFiles.add(file));
          for (const file of files) {
            try {
              const content = await readFileContent(file);
              setFileContents(prev => ({ ...prev, [file]: content }));
            } catch (error) {
              console.error(`Error loading content for ${file}:`, error);
            }
          }
        } else {
          files.forEach(file => {
            newSelectedFiles.delete(file);
            setFileContents(prev => {
              const next = { ...prev };
              delete next[file];
              return next;
            });
          });
        }
      } catch (error) {
        console.error(`Error processing directory ${path}:`, error);
      }
    } else {
      if (selected) {
        newSelectedFiles.add(path);
        try {
          const content = await readFileContent(path);
          setFileContents(prev => ({ ...prev, [path]: content }));
        } catch (error) {
          console.error(`Error loading content for ${path}:`, error);
        }
      } else {
        newSelectedFiles.delete(path);
        setFileContents(prev => {
          const next = { ...prev };
          delete next[path];
          return next;
        });
      }
    }
    
    setSelectedFiles(newSelectedFiles);
    
    if (currentProject) {
      updateProject(currentProject.id, { selectedFiles: newSelectedFiles });
    }
  };

  // Drag & drop
  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(true);
  };

  const handleDragLeave = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
  };

  const handleDrop = async (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);

    if (!hasFileSystemAccess) {
      alert('Veuillez d\'abord sélectionner un dossier de travail');
      return;
    }

    const items = Array.from(e.dataTransfer.items);
    for (const item of items) {
      if (item.kind === 'file') {
        const file = item.getAsFile();
        if (!file) continue;

        try {
          const content = await file.text();
          await createFile(file.name, content);
        } catch (error) {
          console.error('Error processing dropped file:', error);
        }
      }
    }

    await refreshFileTree();
  };

  if (!currentProject) {
    return (
      <div className="flex-1 flex items-center justify-center bg-gray-800">
        <div className="text-center">
          <p className="text-xl text-gray-300 font-medium">Aucun projet sélectionné</p>
          <p className="mt-2 text-gray-400">Sélectionnez ou créez un projet pour commencer</p>
        </div>
      </div>
    );
  }

  return (
    <div className="flex flex-1 h-screen overflow-hidden">
      {/* Sidebar gauche */}
      <div className="w-64 border-r border-gray-700 flex flex-col">
        {/* En-tête du projet */}
        <div className="p-4 border-b border-gray-700">
          <div className="flex items-center justify-between mb-4">
            <h1 className="text-xl font-semibold text-white">{currentProject.name}</h1>
            <button
              onClick={() => setIsProjectSettingsOpen(true)}
              className="p-2 text-gray-400 hover:text-white rounded-lg transition-colors"
            >
              <Settings size={20} />
            </button>
          </div>
          <p className="text-gray-400 text-sm mb-4">{currentProject.description}</p>
        </div>

        {/* Sélecteur de vue (Chats/Fichiers) */}
        <div className="p-4 border-b border-gray-700">
          <div className="flex gap-2">
            <button
              onClick={() => setShowingChat(true)}
              className={`flex-1 px-3 py-2 rounded-lg transition-colors ${
                showingChat
                  ? 'bg-blue-600 text-white'
                  : 'bg-gray-800 text-gray-300 hover:bg-gray-700'
              }`}
            >
              Chats
            </button>
            <button
              onClick={() => setShowingChat(false)}
              className={`flex-1 px-3 py-2 rounded-lg transition-colors ${
                !showingChat
                  ? 'bg-blue-600 text-white'
                  : 'bg-gray-800 text-gray-300 hover:bg-gray-700'
              }`}
            >
              Fichiers
            </button>
          </div>
        </div>

        {/* Contenu de la sidebar */}
        <div className="flex-1 overflow-y-auto">
          {showingChat ? (
            <div className="p-4 space-y-2">
              <button
                onClick={handleCreateChat}
                className="flex items-center gap-2 w-full bg-gray-800 hover:bg-gray-700 text-white rounded-lg p-2.5 transition-colors"
              >
                <Plus size={20} />
                Nouveau chat
              </button>

              {projectChats.map((chat) => (
                <div
                  key={chat.id}
                  className={`group flex items-center justify-between p-3 rounded-lg cursor-pointer transition-colors ${
                    chat.id === currentChatId
                      ? 'bg-gray-800 text-white'
                      : 'text-gray-300 hover:bg-gray-800/50'
                  }`}
                  onClick={() => setCurrentChat(chat.id)}
                >
                  {editingChatId === chat.id ? (
                    <div className="flex items-center gap-2 flex-1" onClick={e => e.stopPropagation()}>
                      <input
                        type="text"
                        value={editingChatTitle}
                        onChange={(e) => setEditingChatTitle(e.target.value)}
                        className="flex-1 bg-gray-700 text-white rounded px-2 py-1"
                        autoFocus
                      />
                      <button
                        onClick={() => handleSaveChatTitle(chat.id)}
                        className="text-green-500 hover:text-green-400"
                      >
                        <Check size={16} />
                      </button>
                      <button
                        onClick={() => setEditingChatId(null)}
                        className="text-red-500 hover:text-red-400"
                      >
                        <X size={16} />
                      </button>
                    </div>
                  ) : (
                    <>
                      <div className="flex items-center gap-2 flex-1 min-w-0">
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            handleEditChatEmoji(chat.id);
                          }}
                          className="w-6 h-6 flex items-center justify-center hover:bg-gray-700 rounded transition-colors"
                        >
                          {chat.emoji}
                        </button>
                        {editingEmoji === chat.id && (
                          <div onClick={(e) => e.stopPropagation()}>
                            <EmojiPicker
                              onSelect={(emoji) => {
                                updateChatEmoji(chat.id, emoji);
                                setEditingEmoji(null);
                              }}
                              onClose={() => setEditingEmoji(null)}
                            />
                          </div>
                        )}
                        <span className="truncate">{chat.title}</span>
                      </div>
                      <div className="hidden group-hover:flex items-center gap-2">
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            handleEditChat(chat.id, chat.title);
                          }}
                          className="text-gray-400 hover:text-white transition-colors"
                        >
                          <Edit2 size={14} />
                        </button>
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            deleteChat(chat.id);
                          }}
                          className="text-gray-400 hover:text-red-500 transition-colors"
                        >
                          <Trash2 size={14} />
                        </button>
                      </div>
                    </>
                  )}
                </div>
              ))}
            </div>
          ) : (
            <div className="p-4 space-y-2">
              {isPWA ? (
                hasFileSystemAccess ? (
                  <div
                    className="space-y-2"
                    onDragOver={handleDragOver}
                    onDragLeave={handleDragLeave}
                    onDrop={handleDrop}
                  >
                    {isDragging && (
                      <div className="absolute inset-0 bg-blue-500/10 border-2 border-blue-500 border-dashed rounded-lg flex items-center justify-center z-50">
                        <div className="text-blue-500 text-lg font-medium">
                          Déposez vos fichiers ici
                        </div>
                      </div>
                    )}

                    {fileTree && (
                      <FileTree
                        tree={fileTree}
                        onFileSelect={handleFileSelect}
                        onCreateFile={handleCreateFile}
                        onCreateDirectory={handleCreateDirectory}
                        onRename={handleRename}
                        onDelete={handleDeleteEntry}
                        onMove={moveEntry}
                        onCopy={copyEntry}
                        expandedFolders={expandedFolders}
                        onToggleFolder={toggleFolder}
                        fileStats={fileStats}
                        rootDirectory={rootDirectory}
                        selectedFiles={selectedFiles}
                        onFileSelectionChange={handleFileSelectionChange}
                      />
                    )}
                  </div>
                ) : (
                  <button
                    onClick={requestFileSystemAccess}
                    disabled={isLoading}
                    className="flex items-center gap-2 w-full bg-blue-600 hover:bg-blue-700 text-white rounded-lg p-2.5 transition-colors disabled:opacity-50"
                  >
                    <FolderOpen size={20} />
                    {isLoading ? 'Chargement...' : 'Sélectionner un dossier'}
                  </button>
                )
              ) : (
                <div className="text-center p-4 bg-gray-800 rounded-lg">
                  <p className="text-gray-300 mb-2">
                    Pour accéder aux fichiers de votre système, veuillez installer l'application.
                  </p>
                  <p className="text-sm text-gray-400">
                    Cliquez sur l'icône d'installation dans la barre d'adresse de votre navigateur.
                  </p>
                </div>
              )}
            </div>
          )}
        </div>
      </div>

      {/* Zone principale */}
      <div className="flex-1 h-full overflow-hidden">
        {showingChat ? (
          <ChatWindow
            projectFiles={currentProject.files}
            systemPrompt={currentProject.systemPrompt}
          />
        ) : selectedFile ? (
          <div className="flex flex-col h-full">
            <div className="p-4 border-b border-gray-700">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <File size={16} className="text-gray-400" />
                  <span className="text-white font-medium">{selectedFile.path}</span>
                  {hasUnsavedChanges && (
                    <span className="text-yellow-500 text-sm">•</span>
                  )}
                </div>
                <div className="flex items-center gap-4">
                  {hasUnsavedChanges && (
                    <button
                      onClick={handleSaveFile}
                      className="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white rounded transition-colors text-sm"
                    >
                      Sauvegarder
                    </button>
                  )}
                </div>
              </div>
            </div>
            <div className="flex-1 overflow-hidden">
              <Editor
                value={selectedFile.content}
                language={selectedFile.language}
                onChange={handleFileChange}
              />
            </div>
          </div>
        ) : (
          <div className="flex-1 flex items-center justify-center bg-gray-800">
            <div className="text-center">
              <p className="text-xl text-gray-300 font-medium">Aucun fichier sélectionné</p>
              <p className="mt-2 text-gray-400">
                {isPWA
                  ? hasFileSystemAccess
                    ? 'Sélectionnez un fichier dans l\'arborescence pour commencer à éditer'
                    : 'Sélectionnez un dossier pour accéder à vos fichiers'
                  : 'Installez l\'application pour accéder à vos fichiers'}
              </p>
            </div>
          </div>
        )}
      </div>

      {/* Modal des paramètres du projet */}
      <ProjectModal
        isOpen={isProjectSettingsOpen}
        onClose={() => setIsProjectSettingsOpen(false)}
        onSubmit={(data) => {
          updateProject(currentProject.id, data);
          setIsProjectSettingsOpen(false);
        }}
        initialData={{
          ...currentProject,
          selectedFiles,
          fileContents
        }}
        title="Paramètres du projet"
      />
    </div>
  );
}
```

src\components\SearchModal.tsx:
```
import React from 'react';
import { Search, File, MessageSquare, FolderOpen } from 'lucide-react';
import { useStore } from '../store';

interface SearchResult {
  id: string;
  type: 'chat' | 'project' | 'file';
  title: string;
  subtitle?: string;
}

export function SearchModal({ isOpen, onClose }: { isOpen: boolean; onClose: () => void }) {
  const { chats, projects } = useStore();
  const [query, setQuery] = React.useState('');
  const [results, setResults] = React.useState<SearchResult[]>([]);

  React.useEffect(() => {
    if (!query.trim()) {
      setResults([]);
      return;
    }

    const searchResults: SearchResult[] = [];
    const searchTerm = query.toLowerCase();

    // Recherche dans les chats
    chats.forEach(chat => {
      if (chat.title.toLowerCase().includes(searchTerm)) {
        searchResults.push({
          id: chat.id,
          type: 'chat',
          title: chat.title,
          subtitle: `Chat - ${chat.model.name}`
        });
      }
    });

    // Recherche dans les projets et leurs fichiers
    projects.forEach(project => {
      if (project.name.toLowerCase().includes(searchTerm)) {
        searchResults.push({
          id: project.id,
          type: 'project',
          title: project.name,
          subtitle: 'Projet'
        });
      }

      project.files.forEach(file => {
        if (file.name.toLowerCase().includes(searchTerm)) {
          searchResults.push({
            id: file.id,
            type: 'file',
            title: file.name,
            subtitle: `Fichier - ${project.name}`
          });
        }
      });
    });

    setResults(searchResults);
  }, [query, chats, projects]);

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/50 flex items-start justify-center pt-[20vh] z-50 animate-fade-in">
      <div className="w-full max-w-2xl bg-zinc-900 rounded-lg shadow-xl border border-zinc-800">
        <div className="p-4 border-b border-zinc-800">
          <div className="flex items-center gap-3">
            <Search className="text-zinc-400" size={20} />
            <input
              type="text"
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              placeholder="Rechercher..."
              className="flex-1 bg-transparent text-white placeholder-zinc-400 focus:outline-none"
              autoFocus
            />
          </div>
        </div>

        <div className="max-h-[60vh] overflow-y-auto">
          {results.length > 0 ? (
            <div className="p-2">
              {results.map((result) => (
                <div
                  key={result.id}
                  className="flex items-center gap-3 p-3 rounded-lg hover:bg-zinc-800 cursor-pointer"
                >
                  {result.type === 'chat' && <MessageSquare size={18} className="text-zinc-400" />}
                  {result.type === 'project' && <FolderOpen size={18} className="text-zinc-400" />}
                  {result.type === 'file' && <File size={18} className="text-zinc-400" />}
                  <div>
                    <div className="text-white">{result.title}</div>
                    {result.subtitle && (
                      <div className="text-sm text-zinc-400">{result.subtitle}</div>
                    )}
                  </div>
                </div>
              ))}
            </div>
          ) : query ? (
            <div className="p-4 text-center text-zinc-400">
              Aucun résultat trouvé pour "{query}"
            </div>
          ) : (
            <div className="p-4 text-center text-zinc-400">
              Commencez à taper pour rechercher
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
```

src\components\SettingsModal.tsx:
```
import { X } from 'lucide-react';
import { useStore } from '../store';
import { AI_MODELS } from '../services/ai';

interface SettingsModalProps {
  isOpen: boolean;
  onClose: () => void;
}

export function SettingsModal({ isOpen, onClose }: SettingsModalProps) {
  const { apiKeys, setApiKey } = useStore();

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-gray-900 rounded-lg w-full max-w-md p-6 relative">
        <button
          onClick={onClose}
          className="absolute top-4 right-4 text-gray-400 hover:text-white"
        >
          <X size={20} />
        </button>

        <h2 className="text-xl font-semibold text-white mb-6">Paramètres</h2>

        <div className="space-y-6">
          <div className="space-y-4">
            <h3 className="text-lg font-medium text-white">Clés API</h3>
            {AI_MODELS.map((model) => (
              <div key={model.id} className="space-y-2">
                <label className="block text-sm font-medium text-gray-300">
                  {model.name}
                </label>
                <input
                  type="password"
                  value={apiKeys[model.id] || ''}
                  onChange={(e) => setApiKey(model.id, e.target.value)}
                  className="w-full bg-gray-800 text-white rounded-lg p-2.5 border border-gray-700 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 transition-colors"
                  placeholder={`Clé API ${model.name}`}
                />
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
  );
}
```

src\components\Sidebar.tsx:
```
import React from 'react';
import { Plus, Trash2, Edit2, Check, X, FolderOpen } from 'lucide-react';
import { useStore } from '../store';
import { AI_MODELS } from '../services/ai';
import { ProjectModal } from './ProjectModal';
import { EmojiPicker } from './EmojiPicker';

interface SidebarProps {
  onViewChange: (view: 'chat' | 'project') => void;
  currentView: 'chat' | 'project';
  isCollapsed: boolean;
}

export function Sidebar({ currentView, onViewChange, isCollapsed }: SidebarProps) {
  const {
    chats,
    currentChatId,
    addChat,
    deleteChat,
    setCurrentChat,
    updateChatTitle,
    updateChatEmoji,
    projects,
    currentProjectId,
    addProject,
    deleteProject,
    setCurrentProject,
    updateProject
  } = useStore();

  const [editingTitle, setEditingTitle] = React.useState<string | null>(null);
  const [tempTitle, setTempTitle] = React.useState('');
  const [selectedModel, setSelectedModel] = React.useState(AI_MODELS[0]);
  const [isProjectModalOpen, setIsProjectModalOpen] = React.useState(false);
  const [editingProject, setEditingProject] = React.useState<string | null>(null);
  const [editingEmoji, setEditingEmoji] = React.useState<string | null>(null);

  const generalChats = chats.filter(chat => !chat.projectId);

  const handleEditTitle = (id: string, title: string) => {
    setEditingTitle(id);
    setTempTitle(title);
  };

  const handleSaveTitle = (id: string) => {
    if (tempTitle.trim()) {
      updateChatTitle(id, tempTitle.trim());
    }
    setEditingTitle(null);
  };

  const handleCreateProject = (data: { name: string; description: string; systemPrompt: string }) => {
    addProject(data.name, data.description, data.systemPrompt);
    onViewChange('project');
  };

  const handleUpdateProject = (data: { name: string; description: string; systemPrompt: string }) => {
    if (editingProject) {
      updateProject(editingProject, data);
      setEditingProject(null);
    }
  };

  const handleEditProject = (projectId: string) => {
    const project = projects.find(p => p.id === projectId);
    if (project) {
      setEditingProject(projectId);
      setIsProjectModalOpen(true);
    }
  };

  return (
    <div className="flex flex-col h-full">
      {currentView === 'chat' ? (
        <>
          <div className={`flex items-center ${isCollapsed ? 'justify-center p-2' : 'justify-between p-4'}`}>
            {isCollapsed ? (
              <button
                onClick={() => addChat(selectedModel)}
                className="w-12 h-12 bg-blue-600 hover:bg-blue-700 text-white rounded-lg flex items-center justify-center transition-colors"
                title="Nouvelle conversation"
              >
                <Plus size={24} />
              </button>
            ) : (
              <button
                onClick={() => addChat(selectedModel)}
                className="flex items-center gap-2 w-full bg-blue-600 hover:bg-blue-700 text-white rounded-lg p-2.5 transition-colors"
              >
                <Plus size={20} />
                Nouvelle conversation
              </button>
            )}
          </div>

          <div className="flex-1 overflow-y-auto space-y-2 p-4">
            {isCollapsed ? (
              <div className="flex flex-col items-center gap-2">
                {generalChats.map((chat) => (
                  <button
                    key={chat.id}
                    onClick={() => setCurrentChat(chat.id)}
                    className={`w-10 h-10 flex items-center justify-center rounded-lg transition-colors ${
                      chat.id === currentChatId
                        ? 'bg-blue-600 text-white'
                        : 'bg-gray-800 text-gray-300 hover:bg-gray-700'
                    }`}
                    title={chat.title}
                  >
                    {chat.emoji}
                  </button>
                ))}
              </div>
            ) : (
              generalChats.map((chat) => (
                <div
                  key={chat.id}
                  className={`group flex items-center justify-between p-3 rounded-lg cursor-pointer transition-colors ${
                    chat.id === currentChatId
                      ? 'bg-gray-800 text-white'
                      : 'text-gray-300 hover:bg-gray-800/50'
                  }`}
                  onClick={() => setCurrentChat(chat.id)}
                >
                  <div className="flex items-center gap-3 flex-1 min-w-0">
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        setEditingEmoji(chat.id);
                      }}
                      className="w-6 h-6 flex items-center justify-center hover:bg-gray-700 rounded transition-colors"
                    >
                      {chat.emoji}
                    </button>
                    {editingEmoji === chat.id && (
                      <div onClick={(e) => e.stopPropagation()}>
                        <EmojiPicker
                          onSelect={(emoji) => {
                            updateChatEmoji(chat.id, emoji);
                            setEditingEmoji(null);
                          }}
                          onClose={() => setEditingEmoji(null)}
                        />
                      </div>
                    )}
                    {editingTitle === chat.id ? (
                      <div className="flex items-center gap-2 flex-1">
                        <input
                          type="text"
                          value={tempTitle}
                          onChange={(e) => setTempTitle(e.target.value)}
                          className="flex-1 bg-gray-700 text-white rounded px-2 py-1"
                          onClick={(e) => e.stopPropagation()}
                        />
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            handleSaveTitle(chat.id);
                          }}
                          className="text-green-500 hover:text-green-400"
                        >
                          <Check size={16} />
                        </button>
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            setEditingTitle(null);
                          }}
                          className="text-red-500 hover:text-red-400"
                        >
                          <X size={16} />
                        </button>
                      </div>
                    ) : (
                      <div className="flex items-center gap-2 flex-1 min-w-0">
                        <span className="truncate">{chat.title}</span>
                        <div className="hidden group-hover:flex items-center gap-2">
                          <button
                            onClick={(e) => {
                              e.stopPropagation();
                              handleEditTitle(chat.id, chat.title);
                            }}
                            className="text-gray-400 hover:text-white transition-colors"
                          >
                            <Edit2 size={14} />
                          </button>
                          <button
                            onClick={(e) => {
                              e.stopPropagation();
                              deleteChat(chat.id);
                            }}
                            className="text-gray-400 hover:text-red-500 transition-colors"
                          >
                            <Trash2 size={14} />
                          </button>
                        </div>
                      </div>
                    )}
                  </div>
                </div>
              ))
            )}
          </div>
        </>
      ) : (
        <div className="flex-1 overflow-y-auto p-4 space-y-2">
          {!isCollapsed && (
            <button
              onClick={() => setIsProjectModalOpen(true)}
              className="flex items-center gap-2 w-full bg-blue-600 hover:bg-blue-700 text-white rounded-lg p-2.5 transition-colors mb-4"
            >
              <Plus size={20} />
              Nouveau projet
            </button>
          )}

          {!isCollapsed && projects.map((project) => (
            <div
              key={project.id}
              className={`group flex items-center justify-between p-3 rounded-lg cursor-pointer transition-colors ${
                project.id === currentProjectId
                  ? 'bg-gray-800 text-white'
                  : 'text-gray-300 hover:bg-gray-800/50'
              }`}
              onClick={() => setCurrentProject(project.id)}
            >
              <div className="flex items-center gap-2 flex-1 min-w-0">
                <FolderOpen size={18} />
                <span className="truncate">{project.name}</span>
              </div>
              <div className="hidden group-hover:flex items-center gap-2">
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    handleEditProject(project.id);
                  }}
                  className="text-gray-400 hover:text-white transition-colors"
                >
                  <Edit2 size={14} />
                </button>
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    deleteProject(project.id);
                  }}
                  className="text-gray-400 hover:text-red-500 transition-colors"
                >
                  <Trash2 size={14} />
                </button>
              </div>
            </div>
          ))}
        </div>
      )}
      
      <ProjectModal
        isOpen={isProjectModalOpen}
        onClose={() => {
          setIsProjectModalOpen(false);
          setEditingProject(null);
        }}
        onSubmit={editingProject ? handleUpdateProject : handleCreateProject}
        initialData={editingProject ? projects.find(p => p.id === editingProject) : undefined}
        title={editingProject ? 'Modifier le projet' : 'Nouveau projet'}
      />
    </div>
  );
}
```

src\components\WebcamCapture.tsx:
```
import React, { useRef, useEffect, useState } from 'react';
import { X, Camera } from 'lucide-react';

interface WebcamCaptureProps {
  onCapture: (file: File) => void;
  onClose: () => void;
}

export function WebcamCapture({ onCapture, onClose }: WebcamCaptureProps) {
  const videoRef = useRef<HTMLVideoElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function startVideo() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        if (videoRef.current) {
          videoRef.current.srcObject = stream;
          videoRef.current.play();
        }
      } catch (err: any) {
        setError('Impossible d\'accéder à la webcam');
        console.error(err);
      }
    }
    startVideo();

    return () => {
      if (videoRef.current && videoRef.current.srcObject) {
        const stream = videoRef.current.srcObject as MediaStream;
        stream.getTracks().forEach(track => track.stop());
      }
    };
  }, []);

  const handleCapture = () => {
    if (!videoRef.current || !canvasRef.current) return;
    const video = videoRef.current;
    const canvas = canvasRef.current;
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const ctx = canvas.getContext('2d');
    if (ctx) {
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      canvas.toBlob(blob => {
        if (blob) {
          const file = new File([blob], 'webcam.png', { type: 'image/png' });
          onCapture(file);
          onClose();
        }
      }, 'image/png');
    }
  };

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-gray-900 p-4 rounded-lg relative">
        <button onClick={onClose} className="absolute top-2 right-2 text-gray-400 hover:text-white">
          <X size={20} />
        </button>
        {error ? (
          <p className="text-red-500">{error}</p>
        ) : (
          <>
            <video ref={videoRef} className="w-full max-w-md rounded" autoPlay muted />
            <canvas ref={canvasRef} className="hidden" />
            <div className="mt-4 flex justify-center">
              <button
                onClick={handleCapture}
                className="flex items-center gap-2 bg-blue-600 hover:bg-blue-700 text-white rounded px-4 py-2 transition-colors"
              >
                <Camera size={20} />
                Prendre la photo
              </button>
            </div>
          </>
        )}
      </div>
    </div>
  );
}

```

src\hooks\useFileSystem.ts:
```
import { useState, useEffect, useCallback } from 'react';
import { useStore } from '../store';

// Types pour l'API File System Access
interface FileSystemPermissionDescriptor {
  mode?: 'read' | 'readwrite';
}

interface FileSystemHandle {
  kind: 'file' | 'directory';
  name: string;
  queryPermission?: (desc: FileSystemPermissionDescriptor) => Promise<PermissionState>;
  requestPermission?: (desc: FileSystemPermissionDescriptor) => Promise<PermissionState>;
}

export interface FileSystemDirectoryHandle extends FileSystemHandle {
  kind: 'directory';
  values: () => AsyncIterableIterator<FileSystemHandle>;
  getDirectoryHandle: (name: string, options?: { create?: boolean }) => Promise<FileSystemDirectoryHandle>;
  getFileHandle: (name: string, options?: { create?: boolean }) => Promise<FileSystemFileHandle>;
  removeEntry: (name: string, options?: { recursive?: boolean }) => Promise<void>;
}

interface FileSystemFileHandle extends FileSystemHandle {
  kind: 'file';
  getFile: () => Promise<File>;
  createWritable: () => Promise<FileSystemWritableFileStream>;
}

interface FileSystemWritableFileStream extends WritableStream {
  write: (content: string) => Promise<void>;
  close: () => Promise<void>;
}

// Déclaration des APIs manquantes
declare global {
  interface Window {
    showDirectoryPicker: (options?: {
      mode?: 'read' | 'readwrite'
    }) => Promise<FileSystemDirectoryHandle>;
  }
  interface Navigator {
    standalone?: boolean;
  }
}

interface FileSystemState {
  isPWA: boolean;
  hasFileSystemAccess: boolean;
  fileTree: any;
  isLoading: boolean;
  rootDirectory: string;
  fileStats: Record<string, { size: number; lastModified: number; type: string }>;
  searchResults: string[];
  requestFileSystemAccess: () => Promise<void>;
  readFileContent: (path: string) => Promise<string>;
  writeFileContent: (path: string, content: string) => Promise<void>;
  createFile: (path: string, content?: string) => Promise<void>;
  createDirectory: (path: string) => Promise<void>;
  deleteEntry: (path: string) => Promise<void>;
  renameEntry: (oldPath: string, newPath: string) => Promise<void>;
  refreshFileTree: () => Promise<void>;
  watchFileChanges: (callback: (path: string) => void) => () => void;
  searchFiles: (query: string) => Promise<void>;
  getFileStats: (path: string) => Promise<{ size: number; lastModified: number; type: string }>;
  moveEntry: (oldPath: string, newPath: string) => Promise<void>;
  copyEntry: (sourcePath: string, destPath: string) => Promise<void>;
  getGitIgnoredFiles: () => Promise<Set<string>>;
  getAllFilesInDirectory: (path: string) => Promise<string[]>;
}

const REFRESH_INTERVAL = 1000; // 1 seconde

export function useFileSystem(projectId?: string): FileSystemState {
  const [isPWA, setIsPWA] = useState(false);
  const [hasFileSystemAccess, setHasFileSystemAccess] = useState(false);
  const [fileTree, setFileTree] = useState<any>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [directoryHandle, setDirectoryHandle] = useState<FileSystemDirectoryHandle | null>(null);
  const [rootDirectory, setRootDirectory] = useState<string>('');
  const [fileWatcher, setFileWatcher] = useState<number | null>(null);
  const [fileStats, setFileStats] = useState<Record<string, { size: number; lastModified: number; type: string }>>({});
  const [searchResults, setSearchResults] = useState<string[]>([]);
  const [gitIgnoredFiles, setGitIgnoredFiles] = useState<Set<string>>(new Set());

  const { projects, setProjectDirectory } = useStore();
  const currentProject = projectId ? projects.find(p => p.id === projectId) : null;

  // Vérifier si l'application est en mode PWA
  useEffect(() => {
    const isPWACheck = 
      window.matchMedia('(display-mode: standalone)').matches ||
      (navigator as Navigator).standalone ||
      document.referrer.includes('android-app://');
    setIsPWA(isPWACheck);
  }, []);

  // Restaurer le handle du dossier au démarrage
  useEffect(() => {
    const restoreDirectoryHandle = async () => {
      if (currentProject?.directoryHandle) {
        try {
          const handle = currentProject.directoryHandle as FileSystemDirectoryHandle;
          const permissionState = await handle.queryPermission?.({ mode: 'readwrite' });
          
          if (permissionState === 'granted') {
            setDirectoryHandle(handle);
            setHasFileSystemAccess(true);
            setRootDirectory(handle.name);
            const tree = await buildFileTree(handle);
            setFileTree(tree);
            await loadGitIgnore(handle);
            await updateAllFileStats(handle);
          } else {
            const newPermission = await handle.requestPermission?.({ mode: 'readwrite' });
            if (newPermission === 'granted') {
              setDirectoryHandle(handle);
              setHasFileSystemAccess(true);
              setRootDirectory(handle.name);
              const tree = await buildFileTree(handle);
              setFileTree(tree);
              await loadGitIgnore(handle);
              await updateAllFileStats(handle);
            }
          }
        } catch (error) {
          console.error('Erreur lors de la restauration du handle:', error);
          if (projectId) {
            setProjectDirectory(projectId, null);
          }
        }
      }
    };

    restoreDirectoryHandle();
  }, [currentProject?.directoryHandle, projectId, setProjectDirectory]);

  // Construire l'arborescence des fichiers
  const buildFileTree = async (handle: FileSystemDirectoryHandle, path: string = ''): Promise<any> => {
    const tree: any = {};
    
    for await (const entry of handle.values()) {
      const entryPath = path ? `${path}/${entry.name}` : entry.name;
      
      if (gitIgnoredFiles.has(entryPath)) continue;
      
      if (entry.kind === 'directory') {
        const dirHandle = await handle.getDirectoryHandle(entry.name);
        tree[entry.name] = await buildFileTree(dirHandle, entryPath);
      } else {
        tree[entry.name] = entryPath;
      }
    }
    
    return tree;
  };

  // Charger et parser le .gitignore
  const loadGitIgnore = async (handle: FileSystemDirectoryHandle) => {
    try {
      const gitignoreHandle = await handle.getFileHandle('.gitignore');
      const file = await gitignoreHandle.getFile();
      const content = await file.text();
      
      const patterns = content
        .split('\n')
        .map(line => line.trim())
        .filter(line => line && !line.startsWith('#'));
      
      const ignored = new Set<string>();
      setGitIgnoredFiles(ignored);
    } catch {
      setGitIgnoredFiles(new Set());
    }
  };

  // Mettre à jour les stats de tous les fichiers
  const updateAllFileStats = async (handle: FileSystemDirectoryHandle, path: string = '') => {
    const stats: Record<string, { size: number; lastModified: number; type: string }> = {};
    
    const processEntry = async (entry: FileSystemHandle, entryPath: string) => {
      if (entry.kind === 'file') {
        const fileHandle = entry as FileSystemFileHandle;
        const file = await fileHandle.getFile();
        stats[entryPath] = {
          size: file.size,
          lastModified: file.lastModified,
          type: file.type || 'text/plain'
        };
      } else {
        const dirHandle = entry as FileSystemDirectoryHandle;
        for await (const childEntry of dirHandle.values()) {
          const childPath = entryPath ? `${entryPath}/${childEntry.name}` : childEntry.name;
          await processEntry(childEntry, childPath);
        }
      }
    };
    
    await processEntry(handle, path);
    setFileStats(stats);
  };

  // Obtenir les stats d'un fichier
  const getFileStats = async (path: string) => {
    const handle = await getHandleFromPath(path);
    if (handle.kind !== 'file') {
      throw new Error('Ce n\'est pas un fichier');
    }
    const fileHandle = handle as FileSystemFileHandle;
    const file = await fileHandle.getFile();
    return {
      size: file.size,
      lastModified: file.lastModified,
      type: file.type || 'text/plain'
    };
  };

  // Rechercher des fichiers
  const searchFiles = async (query: string) => {
    if (!query.trim()) {
      setSearchResults([]);
      return;
    }

    const results: string[] = [];
    const searchTerm = query.toLowerCase();
    
    const searchInDirectory = async (handle: FileSystemDirectoryHandle, path: string = '') => {
      for await (const entry of handle.values()) {
        const entryPath = path ? `${path}/${entry.name}` : entry.name;
        
        if (gitIgnoredFiles.has(entryPath)) continue;
        
        if (entry.name.toLowerCase().includes(searchTerm)) {
          results.push(entryPath);
        }
        
        if (entry.kind === 'directory') {
          const dirHandle = await handle.getDirectoryHandle(entry.name);
          await searchInDirectory(dirHandle, entryPath);
        }
      }
    };
    
    if (directoryHandle) {
      await searchInDirectory(directoryHandle);
    }
    
    setSearchResults(results);
  };

  // Obtenir tous les fichiers dans un dossier
  const getAllFilesInDirectory = async (path: string): Promise<string[]> => {
    const handle = await getHandleFromPath(path);
    if (handle.kind !== 'directory') {
      throw new Error('Ce n\'est pas un dossier');
    }

    const files: string[] = [];
    const processDirectory = async (dirHandle: FileSystemDirectoryHandle, currentPath: string) => {
      for await (const entry of dirHandle.values()) {
        const entryPath = `${currentPath}/${entry.name}`;
        if (entry.kind === 'file') {
          files.push(entryPath);
        } else {
          const childHandle = await dirHandle.getDirectoryHandle(entry.name);
          await processDirectory(childHandle, entryPath);
        }
      }
    };

    await processDirectory(handle as FileSystemDirectoryHandle, path);
    return files;
  };

  // Copier un fichier ou dossier
  const copyEntry = async (sourcePath: string, destPath: string) => {
    const sourceHandle = await getHandleFromPath(sourcePath);
    
    if (sourceHandle.kind === 'file') {
      const content = await readFileContent(sourcePath);
      await createFile(destPath, content);
    } else {
      const copyDirectory = async (
        sourceHandle: FileSystemDirectoryHandle,
        targetPath: string
      ) => {
        await createDirectory(targetPath);
        
        for await (const entry of sourceHandle.values()) {
          const newPath = `${targetPath}/${entry.name}`;
          
          if (entry.kind === 'file') {
            const fileHandle = await sourceHandle.getFileHandle(entry.name);
            const content = await (await fileHandle.getFile()).text();
            await createFile(newPath, content);
          } else {
            const dirHandle = await sourceHandle.getDirectoryHandle(entry.name);
            await copyDirectory(dirHandle, newPath);
          }
        }
      };

      await copyDirectory(sourceHandle as FileSystemDirectoryHandle, destPath);
    }
  };

  // Déplacer un fichier ou dossier
  const moveEntry = async (oldPath: string, newPath: string) => {
    await copyEntry(oldPath, newPath);
    await deleteEntry(oldPath);
  };

  // Obtenir un handle à partir d'un chemin
  const getHandleFromPath = async (path: string): Promise<FileSystemHandle> => {
    if (!directoryHandle) throw new Error('Pas d\'accès au système de fichiers');

    const parts = path.split('/').filter(Boolean);
    let currentHandle: FileSystemHandle = directoryHandle;

    for (const part of parts) {
      if (currentHandle.kind !== 'directory') {
        throw new Error('Chemin invalide');
      }
      const dirHandle = currentHandle as FileSystemDirectoryHandle;
      const isLastPart = part === parts[parts.length - 1];
      if (isLastPart) {
        try {
          currentHandle = await dirHandle.getFileHandle(part);
        } catch {
          currentHandle = await dirHandle.getDirectoryHandle(part);
        }
      } else {
        currentHandle = await dirHandle.getDirectoryHandle(part);
      }
    }

    return currentHandle;
  };

  // Lire le contenu d'un fichier
  const readFileContent = async (path: string): Promise<string> => {
    const handle = await getHandleFromPath(path);
    if (handle.kind !== 'file') {
      throw new Error('Ce n\'est pas un fichier');
    }
    const fileHandle = handle as FileSystemFileHandle;
    const file = await fileHandle.getFile();
    return await file.text();
  };

  // Écrire dans un fichier
  const writeFileContent = async (path: string, content: string): Promise<void> => {
    const handle = await getHandleFromPath(path);
    if (handle.kind !== 'file') {
      throw new Error('Ce n\'est pas un fichier');
    }
    const fileHandle = handle as FileSystemFileHandle;
    const writable = await fileHandle.createWritable();
    await writable.write(content);
    await writable.close();
    await refreshFileTree();
    await updateAllFileStats(directoryHandle!);
  };

  // Créer un nouveau fichier
  const createFile = async (path: string, content: string = ''): Promise<void> => {
    if (!directoryHandle) throw new Error('Pas d\'accès au système de fichiers');

    const parts = path.split('/');
    const fileName = parts.pop()!;
    let currentHandle: FileSystemDirectoryHandle = directoryHandle;

    for (const part of parts) {
      if (part) {
        currentHandle = await currentHandle.getDirectoryHandle(part, { create: true });
      }
    }

    const fileHandle = await currentHandle.getFileHandle(fileName, { create: true });
    const writable = await fileHandle.createWritable();
    await writable.write(content);
    await writable.close();
    await refreshFileTree();
    await updateAllFileStats(directoryHandle);
  };

  // Créer un nouveau dossier
  const createDirectory = async (path: string): Promise<void> => {
    if (!directoryHandle) throw new Error('Pas d\'accès au système de fichiers');

    const parts = path.split('/');
    let currentHandle: FileSystemDirectoryHandle = directoryHandle;

    for (const part of parts) {
      if (part) {
        currentHandle = await currentHandle.getDirectoryHandle(part, { create: true });
      }
    }

    await refreshFileTree();
    await updateAllFileStats(directoryHandle);
  };

  // Supprimer un fichier ou dossier
  const deleteEntry = async (path: string): Promise<void> => {
    if (!directoryHandle) throw new Error('Pas d\'accès au système de fichiers');

    const parts = path.split('/');
    const name = parts.pop()!;
    let currentHandle: FileSystemDirectoryHandle = directoryHandle;

    for (const part of parts) {
      if (part) {
        currentHandle = await currentHandle.getDirectoryHandle(part);
      }
    }

    await currentHandle.removeEntry(name, { recursive: true });
    await refreshFileTree();
    await updateAllFileStats(directoryHandle);
  };

  // Renommer un fichier ou dossier
  const renameEntry = async (oldPath: string, newPath: string): Promise<void> => {
    await copyEntry(oldPath, newPath);
    await deleteEntry(oldPath);
    await refreshFileTree();
    await updateAllFileStats(directoryHandle!);
  };

  // Rafraîchir l'arborescence
  const refreshFileTree = async () => {
    if (!directoryHandle) return;
    const tree = await buildFileTree(directoryHandle);
    setFileTree(tree);
  };

  // Observer les changements de fichiers
  const watchFileChanges = useCallback((callback: (path: string) => void) => {
    if (fileWatcher) {
      clearInterval(fileWatcher);
    }

    const watcherId = window.setInterval(async () => {
      if (!directoryHandle) return;
      
      try {
        const newTree = await buildFileTree(directoryHandle);
        const stringifiedOldTree = JSON.stringify(fileTree);
        const stringifiedNewTree = JSON.stringify(newTree);
        
        if (stringifiedOldTree !== stringifiedNewTree) {
          setFileTree(newTree);
          await updateAllFileStats(directoryHandle);
          callback(rootDirectory);
        }
      } catch (error) {
        console.error('Erreur lors de la surveillance des fichiers:', error);
      }
    }, REFRESH_INTERVAL);

    setFileWatcher(watcherId);

    return () => {
      if (watcherId) {
        clearInterval(watcherId);
      }
    };
  }, [directoryHandle, fileTree, rootDirectory]);

  // Demander l'accès au système de fichiers
  const requestFileSystemAccess = async () => {
    try {
      setIsLoading(true);
      
      const handle = await window.showDirectoryPicker({
        mode: 'readwrite'
      });
      
      setDirectoryHandle(handle);
      setHasFileSystemAccess(true);
      setRootDirectory(handle.name);
      
      if (projectId) {
        setProjectDirectory(projectId, handle);
      }
      
      const tree = await buildFileTree(handle);
      setFileTree(tree);
      await loadGitIgnore(handle);
      await updateAllFileStats(handle);
    } catch (error) {
      console.error('Erreur lors de la demande d\'accès aux fichiers:', error);
    } finally {
      setIsLoading(false);
    }
  };

  // Nettoyer le watcher quand le composant est démonté
  useEffect(() => {
    return () => {
      if (fileWatcher) {
        clearInterval(fileWatcher);
      }
    };
  }, [fileWatcher]);

  // Obtenir la liste des fichiers ignorés par git
  const getGitIgnoredFiles = async () => {
    return gitIgnoredFiles;
  };

  return {
    isPWA,
    hasFileSystemAccess,
    fileTree,
    isLoading,
    rootDirectory,
    fileStats,
    searchResults,
    requestFileSystemAccess,
    readFileContent,
    writeFileContent,
    createFile,
    createDirectory,
    deleteEntry,
    renameEntry,
    refreshFileTree,
    watchFileChanges,
    searchFiles,
    getFileStats,
    moveEntry,
    copyEntry,
    getGitIgnoredFiles,
    getAllFilesInDirectory
  };
}
```

src\hooks\useKeyboardShortcuts.ts:
```
import { useEffect } from 'react';
import { useStore } from '../store';

export function useKeyboardShortcuts() {
  const { addChat, addProject } = useStore();

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Ctrl/Cmd + K : Recherche globale
      if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
        e.preventDefault();
        // TODO: Ouvrir la recherche globale
      }

      // Ctrl/Cmd + N : Nouveau chat
      if ((e.ctrlKey || e.metaKey) && e.key === 'n') {
        e.preventDefault();
        // TODO: Ouvrir le modal de création de chat
      }

      // Ctrl/Cmd + P : Nouveau projet
      if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
        e.preventDefault();
        // TODO: Ouvrir le modal de création de projet
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [addChat, addProject]);
}
```

src\index.css:
```
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  color-scheme: dark;
}

/* Thème global */
body {
  @apply bg-[#0A0A0A] text-white;
}

/* Styles des composants communs */
.btn {
  @apply px-4 py-2 rounded-lg transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-white/20;
}

.btn-primary {
  @apply bg-white text-black hover:bg-white/90;
}

.btn-secondary {
  @apply bg-zinc-800 text-white hover:bg-zinc-700;
}

.input {
  @apply bg-zinc-900 border border-zinc-800 rounded-lg px-4 py-2 text-white placeholder-zinc-400
         focus:outline-none focus:ring-2 focus:ring-white/20 focus:border-transparent
         transition-all duration-200;
}

.card {
  @apply bg-zinc-900 rounded-lg border border-zinc-800;
}

/* Scrollbar personnalisée */
::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

::-webkit-scrollbar-track {
  @apply bg-zinc-900;
}

::-webkit-scrollbar-thumb {
  @apply bg-zinc-700 rounded-full hover:bg-zinc-600 transition-colors;
}

/* Styles pour le markdown */
.prose {
  @apply prose-invert max-w-none;
}

.prose pre {
  @apply bg-black rounded-lg border border-zinc-800 !important;
}

.prose code {
  @apply bg-zinc-800 text-zinc-200 px-1.5 py-0.5 rounded text-sm !important;
}

.prose pre code {
  @apply bg-transparent p-0 !important;
}

/* Animations */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.animate-fade-in {
  animation: fadeIn 0.2s ease-out;
}

/* Transitions */
.transition-smooth {
  @apply transition-all duration-200 ease-in-out;
}
```

src\main.tsx:
```
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import App from './App.tsx';
import './index.css';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>
);

```

src\services\ai.ts:
```
import OpenAI from 'openai';
import { AIModel } from '../types';

const AI_MODELS: AIModel[] = [
  {
    id: 'gpt',
    name: 'GPT-4o',
    apiEndpoint: 'https://api.openai.com/v1/chat/completions',
    defaultModel: 'gpt-4o',
    supportsStreaming: true,
    supportsFunctionCalling: true
  },
  {
    id: 'claude',
    name: 'Claude',
    apiEndpoint: 'https://api.anthropic.com/v1/messages',
    defaultModel: 'claude-3-opus-20240229',
    supportsStreaming: false,
    supportsFunctionCalling: false
  },
  {
    id: 'mistral',
    name: 'Mistral',
    apiEndpoint: 'https://api.mistral.ai/v1/chat/completions',
    defaultModel: 'mistral-large-latest',
    supportsStreaming: false,
    supportsFunctionCalling: false
  }
];

export async function generateImageDescription(apiKey: string, base64Image: string): Promise<string> {
  if (!apiKey) {
    throw new Error("Clé API GPT-4 requise pour l'analyse d'images");
  }

  const openai = new OpenAI({ 
    apiKey,
    dangerouslyAllowBrowser: true
  });

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "user",
          content: [
            { 
              type: "text", 
              text: `Décris cette image de manière très précise. La première phrase est obligatoirement une phrase concise qui résume l'image, commençant par "Tu vois une image qui représente" et de moins de 15 mots. Ensuite tu décris très précisément l'image. S'il y a du texte d'indiqué, tu le répète entièrement. Si l'image est uniquement un screen d'un fichier de code, après la première phrase de ta réponse tu indiqueras uniquement "Code :" suivi de l'entièreté du code affiché sur l'image.` 
            },
            {
              type: "image_url",
              image_url: {
                url: base64Image
              }
            }
          ],
        },
      ],
      max_tokens: 150,
    });

    return response.choices[0]?.message?.content || 'Description non disponible';
  } catch (error: any) {
    console.error('Erreur lors de la génération de la description:', error);
    throw new Error(`Erreur lors de l'analyse de l'image: ${error.message}`);
  }
}

// Définition des outils avec additionalProperties: false
const tools = [
  {
    type: "function",
    function: {
      name: "get_current_time",
      description: "Get the current time in a specific timezone",
      parameters: {
        type: "object",
        properties: {
          timezone: {
            type: "string",
            description: "The timezone to get the time for (e.g. 'Europe/Paris')"
          }
        },
        required: ["timezone"],
        additionalProperties: false
      },
      strict: true
    }
  }
];

function get_current_time(timezone: string): string {
  try {
    const now = new Date();
    const formatter = new Intl.DateTimeFormat('fr-FR', { 
      timeZone: timezone, 
      timeStyle: 'medium', 
      dateStyle: 'long' 
    });
    return formatter.format(now);
  } catch (e) {
    return "Fuseau horaire invalide.";
  }
}

/**
 * streamResponse
 * 
 * - Retourne un générateur asynchrone qui envoie les morceaux de texte renvoyés par GPT en streaming.
 * - Accumule également les appels de fonction (function calling) dans finalToolCalls.
 * - À la fin du flux, finalToolCalls contiendra la liste des appels de fonction complétés (arguments JSON reconstitués).
 */
export async function* streamResponse(
  model: AIModel,
  apiKey: string,
  messages: { role: string; content: string }[],
  finalToolCalls: Record<number, { name: string; arguments: string }>
) {
  if (model.id !== 'gpt') {
    throw new Error('Le streaming n\'est supporté que pour GPT-4');
  }

  const openai = new OpenAI({
    apiKey,
    dangerouslyAllowBrowser: true
  });

  const stream = await openai.chat.completions.create({
    model: model.defaultModel,
    messages: messages.map(m => ({
      role: m.role === 'assistant' ? 'assistant' : 'user',
      content: m.content
    })),
    stream: true,
    tools: tools,
    store: true,
  });

  for await (const chunk of stream) {
    const choice = chunk.choices[0];
    
    // Si on reçoit du texte
    if (choice?.delta?.content) {
      const contentPart = choice.delta.content;
      console.log(`Chunk: ${contentPart}`);
      yield contentPart;
    }

    // Si on reçoit un (ou plusieurs) appels de fonction
    if (choice?.delta?.tool_calls) {
      const calls = choice.delta.tool_calls;
      const callArray = Array.isArray(calls) ? calls : [calls];
      for (const singleCall of callArray) {
        const index = singleCall.index;
        if (index === undefined) continue;

        // Initialisation de la structure de stockage si besoin
        if (!finalToolCalls[index]) {
          finalToolCalls[index] = {
            name: singleCall?.function?.name || '',
            arguments: singleCall?.function?.arguments || ''
          };
        } else {
          // Accumulation des arguments (ils arrivent en fragments)
          finalToolCalls[index].arguments += singleCall?.function?.arguments || '';
        }

        // Mise à jour du nom de fonction si on le reçoit plus tard
        if (!finalToolCalls[index].name && singleCall?.function?.name) {
          finalToolCalls[index].name = singleCall.function.name;
        }
      }
    }
  }
}

/**
 * Exécute un éventuel appel de fonction en local,
 * puis renvoie la réponse finale. 
 */
export async function handleFunctionCallsAndRespond(
  model: AIModel,
  apiKey: string,
  conversationSoFar: { role: string; content: string }[],
  finalToolCalls: Record<number, { name: string; arguments: string }>
): Promise<string> {
  console.log('DEBUG: handleFunctionCallsAndRespond -> finalToolCalls =', finalToolCalls);

  // On exécute pour chaque fonction identifiée
  const callsResults: string[] = [];
  for (const indexString in finalToolCalls) {
    const call = finalToolCalls[indexString];
    console.log(`DEBUG: Traitement de l'appel de fonction index=${indexString}, name=${call.name}, args="${call.arguments}"`);
    
    if (call.name === 'get_current_time') {
      try {
        const params = JSON.parse(call.arguments || '{}');
        const timezone = params.timezone || 'UTC';
        const result = get_current_time(timezone);
        callsResults.push(`Pour le fuseau "${timezone}", l'heure est: ${result}`);
        console.log(`DEBUG: Résultat get_current_time("${timezone}") = ${result}`);
      } catch (e) {
        const errMsg = `Erreur de parsing pour get_current_time: ${e}`;
        callsResults.push(errMsg);
        console.log('DEBUG:', errMsg);
      }
    } else {
      console.log(`DEBUG: Appel de fonction non géré: ${call.name}`);
    }
  }

  if (callsResults.length === 0) {
    console.log('DEBUG: Aucune fonction valide n’a été appelée ou finalisée (callsResults vide).');
    return '';
  }

  const newAssistantMessage = `
Voici les résultats des fonctions appelées :

${callsResults.join('\n')}

Tu dois IMPÉRATIVEMENT intégrer ces informations (sans t'en excuser ou les ignorer) dans ta réponse finale. 
`.trim();

  console.log('DEBUG: Envoi d’un nouveau message (ROLE=system) à GPT avec le résultat des fonctions:\n', newAssistantMessage);

  const openai = new OpenAI({ apiKey, dangerouslyAllowBrowser: true });

  // Remplacez le rôle "assistant" par "system" pour imposer plus fortement la directive 
  const newConversation = [
    ...conversationSoFar,
    { role: 'system', content: newAssistantMessage }
  ];

  const completion = await openai.chat.completions.create({
    model: model.defaultModel,
    messages: newConversation,
    store: true,
    stream: false
  });

  const finalContent = completion.choices[0]?.message?.content || '';
  console.log('DEBUG: GPT renvoie (après fonction) =', finalContent);
  return finalContent;
}


/**
 * sendMessage
 * 
 * Fonction pour l'appel unique (sans streaming) ou usage standard. 
 * Si useStreaming = true, la fonction n'est plus appelée
 * (vous utilisez handleSubmit dans ChatWindow qui appelle streamResponse).
 */
export async function sendMessage(
  model: AIModel,
  apiKey: string,
  messages: { role: string; content: string; selectedImages?: string[] }[],
  chatImages?: { id: string; description: string }[],
  useStreaming: boolean = false
) {
  if (!apiKey) {
    throw new Error(`Veuillez fournir une clé API pour ${model.name}`);
  }

  const processedMessages = messages.map(msg => {
    if (msg.selectedImages?.length && chatImages) {
      let content = msg.content;
      msg.selectedImages.forEach(imgId => {
        const image = chatImages.find(img => img.id === imgId);
        if (image) {
          const imageRef = `[Image ${image.id}]`;
          content = content.replace(imageRef, `[Image: ${image.description}]`);
        }
      });
      return { role: msg.role, content };
    }
    return { role: msg.role, content: msg.content };
  });

  if (useStreaming && model.supportsStreaming) {
    // On n'utilise plus sendMessage en streaming dans l'exemple,
    // handleSubmit de ChatWindow.tsx appelle directement streamResponse.
    // Vous pourriez néanmoins l'adapter si besoin.
    throw new Error('Le streaming direct n’est plus géré ici. Utilisez streamResponse et handleFunctionCallsAndRespond.');
  }

  switch (model.id) {
    case 'gpt': {
      const openai = new OpenAI({
        apiKey,
        dangerouslyAllowBrowser: true
      });
      const response = await openai.chat.completions.create({
        model: model.defaultModel,
        messages: processedMessages.map(m => ({
          role: m.role === 'assistant' ? 'assistant' : 'user',
          content: m.content
        })),
        tools: model.supportsFunctionCalling ? tools : undefined,
        store: true,
        stream: false,
      });
      return response.choices[0]?.message?.content || '';
    }
    case 'claude': {
      const headers: Record<string, string> = {
        'Content-Type': 'application/json',
        'x-api-key': apiKey,
        'anthropic-version': '2023-06-01'
      };
      const body = {
        model: model.defaultModel,
        messages: processedMessages.map(m => ({
          role: m.role === 'assistant' ? 'assistant' : 'user',
          content: m.content
        }))
      };
      const response = await fetch(model.apiEndpoint, {
        method: 'POST',
        headers,
        body: JSON.stringify(body)
      });
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data.error?.message || `Erreur avec ${model.name}`);
      }
      return data.content[0]?.text || '';
    }
    case 'mistral': {
      const headers: Record<string, string> = {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      };
      const body = {
        model: model.defaultModel,
        messages: processedMessages.map(m => ({
          role: m.role === 'assistant' ? 'assistant' : 'user',
          content: m.content
        }))
      };
      const response = await fetch(model.apiEndpoint, {
        method: 'POST',
        headers,
        body: JSON.stringify(body)
      });
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data.error?.message || `Erreur avec ${model.name}`);
      }
      return data.choices[0]?.message?.content || '';
    }
    default:
      throw new Error('Modèle d\'IA non supporté');
  }
}

export { AI_MODELS };

```

src\store.ts:
```
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { AppState, Chat, AIModel, Project, ProjectFile, ChatImage, Message } from './types';

export const useStore = create<AppState>()(
  persist(
    (set, get) => ({
      chats: [],
      projects: [],
      currentChatId: null,
      currentProjectId: null,
      apiKeys: {},

      addChat: (model: AIModel, projectId?: string) => {
        const newChat: Chat = {
          id: crypto.randomUUID(),
          title: 'Nouvelle conversation',
          messages: [],
          model,
          projectId,
          emoji: '💬',
          images: [],
          streamingEnabled: true,
          systemPrompt: '' // ou une valeur par défaut
        };

        set((state) => ({
          chats: [...state.chats, newChat],
          currentChatId: newChat.id
        }));
      },

      deleteChat: (id: string) => {
        set((state) => ({
          chats: state.chats.filter((chat) => chat.id !== id),
          currentChatId: state.currentChatId === id ? null : state.currentChatId
        }));
      },

      setCurrentChat: (id: string | null) => {
        set({ currentChatId: id });
      },

      updateChat: (id: string, updates: Partial<Chat>) => {
        set((state) => ({
          chats: state.chats.map((chat) =>
            chat.id === id ? { ...chat, ...updates } : chat
          )
        }));
      },

      addMessage: (
        chatId: string,
        role: Message['role'],
        content: string,
        selectedImages?: string[],
        messageId?: string,
        offline?: boolean
      ) => {
        const id = messageId || crypto.randomUUID();
        const message: Message = {
          id,
          role,
          content,
          timestamp: Date.now(),
          isEditing: false,
          selectedImages,
          offline: offline || false
        };

        set((state) => ({
          chats: state.chats.map((chat) =>
            chat.id === chatId
              ? { ...chat, messages: [...chat.messages, message] }
              : chat
          )
        }));
      },


      clearOfflineFlag: (chatId: string, messageId: string) => {
        set(state => ({
          chats: state.chats.map(chat => {
            if (chat.id === chatId) {
              return {
                ...chat,
                messages: chat.messages.map(msg =>
                  msg.id === messageId ? { ...msg, offline: false } : msg
                )
              };
            }
            return chat;
          })
        }));
      },

      updateMessage: (chatId: string, messageId: string, content: string) => {
        set((state) => ({
          chats: state.chats.map((chat) =>
            chat.id === chatId
              ? {
                ...chat,
                messages: chat.messages.map((msg) =>
                  msg.id === messageId
                    ? { ...msg, content, isEditing: false }
                    : msg
                )
              }
              : chat
          )
        }));
      },

      setMessageEditing: (chatId: string, messageId: string, isEditing: boolean) => {
        set((state) => ({
          chats: state.chats.map((chat) =>
            chat.id === chatId
              ? {
                ...chat,
                messages: chat.messages.map((msg) =>
                  msg.id === messageId ? { ...msg, isEditing } : msg
                )
              }
              : chat
          )
        }));
      },

      updateChatTitle: (chatId: string, title: string) => {
        set((state) => ({
          chats: state.chats.map((chat) =>
            chat.id === chatId ? { ...chat, title } : chat
          )
        }));
      },

      updateChatEmoji: (chatId: string, emoji: string) => {
        set((state) => ({
          chats: state.chats.map((chat) =>
            chat.id === chatId ? { ...chat, emoji } : chat
          )
        }));
      },

      addImageToChat: (chatId: string, image: Omit<ChatImage, 'id'>) => {
        const newImage: ChatImage = {
          ...image,
          id: crypto.randomUUID()
        };

        set((state) => ({
          chats: state.chats.map((chat) =>
            chat.id === chatId
              ? {
                ...chat,
                images: Array.isArray(chat.images)
                  ? [...chat.images, newImage]
                  : [newImage]
              }
              : chat
          )
        }));

        return newImage.id;
      },

      deleteImageFromChat: (chatId: string, imageId: string) => {
        set((state) => ({
          chats: state.chats.map((chat) =>
            chat.id === chatId
              ? {
                ...chat,
                images: Array.isArray(chat.images)
                  ? chat.images.filter((img) => img.id !== imageId)
                  : [],
                messages: chat.messages.map((msg) => ({
                  ...msg,
                  selectedImages: msg.selectedImages?.filter((id) => id !== imageId)
                }))
              }
              : chat
          )
        }));
      },

      getCurrentChat: () => {
        const state = get();
        return state.currentChatId ? (state.chats.find(c => c.id === state.currentChatId) || null) : null;
      },

      addProject: (name: string, description: string, systemPrompt: string) => {
        const newProject: Project = {
          id: crypto.randomUUID(),
          name,
          description,
          systemPrompt,
          files: [],
          created: Date.now(),
          lastModified: Date.now(),
          selectedFiles: new Set<string>(),
          directoryHandle: null
        };

        set((state) => ({
          projects: [...state.projects, newProject],
          currentProjectId: newProject.id
        }));
      },

      deleteProject: (id: string) => {
        set((state) => ({
          projects: state.projects.filter((project) => project.id !== id),
          currentProjectId: state.currentProjectId === id ? null : state.currentProjectId,
          chats: state.chats.filter((chat) => chat.projectId !== id)
        }));
      },

      setCurrentProject: (id: string | null) => {
        set({ currentProjectId: id });
      },

      updateProject: (id: string, updates: Partial<Project>) => {
        set((state) => ({
          projects: state.projects.map((project) =>
            project.id === id
              ? { ...project, ...updates, lastModified: Date.now() }
              : project
          )
        }));
      },

      addFile: (projectId: string, file: Omit<ProjectFile, 'id'>) => {
        const newFile: ProjectFile = {
          ...file,
          id: crypto.randomUUID()
        };

        set((state) => ({
          projects: state.projects.map((project) =>
            project.id === projectId
              ? {
                ...project,
                files: [...project.files, newFile],
                lastModified: Date.now()
              }
              : project
          )
        }));
      },

      updateFile: (projectId: string, fileId: string, content: string) => {
        set((state) => ({
          projects: state.projects.map((project) =>
            project.id === projectId
              ? {
                ...project,
                files: project.files.map((file) =>
                  file.id === fileId
                    ? { ...file, content, lastModified: Date.now() }
                    : file
                ),
                lastModified: Date.now()
              }
              : project
          )
        }));
      },

      deleteFile: (projectId: string, fileId: string) => {
        set((state) => ({
          projects: state.projects.map((project) =>
            project.id === projectId
              ? {
                ...project,
                files: project.files.filter((file) => file.id !== fileId),
                lastModified: Date.now()
              }
              : project
          )
        }));
      },

      setApiKey: (modelId: string, apiKey: string) => {
        set((state) => ({
          apiKeys: { ...state.apiKeys, [modelId]: apiKey }
        }));
      },

      setProjectDirectory: (projectId: string, handle: FileSystemDirectoryHandle | null) => {
        set((state) => ({
          projects: state.projects.map((project) =>
            project.id === projectId
              ? { ...project, directoryHandle: handle }
              : project
          )
        }));
      }
    }),
    {
      name: 'ai-chat-storage',
      partialize: (state) => ({
        chats: state.chats,
        projects: state.projects.map(project => ({
          ...project,
          directoryHandle: undefined // Ne pas persister le handle
        })),
        apiKeys: state.apiKeys
      })
    }
  )
);
```

src\sw-custom.js:
```
// src/sw-custom.js

import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst } from 'workbox-strategies';

// Pré-cachez tous les assets générés par Vite
precacheAndRoute(self.__WB_MANIFEST || []);

// Mise en cache à la volée pour l’API OpenAI (vous pouvez ajouter d’autres règles si besoin)
registerRoute(
  ({ url }) => url.origin === 'https://api.openai.com',
  new NetworkFirst({
    cacheName: 'openai-api-cache',
    plugins: []
  })
);

// Lors d'un background sync, nous ne faisons pas l'appel nous-mêmes
// mais nous informons le client pour qu'il procède à la synchronisation.
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-messages') {
    event.waitUntil(
      self.clients.matchAll().then((clients) => {
        for (const client of clients) {
          client.postMessage({ type: 'SYNC_OFFLINE_MESSAGES' });
        }
      })
    );
  }
});

```

src\types.ts:
```
export interface Message {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: number;
  isEditing?: boolean;
  selectedImages?: string[];
  offline?: boolean;
}

export interface ChatImage {
  id: string;
  base64: string;
  description: string;
  name: string;
  timestamp: number;
}

export interface ProjectFile {
  id: string;
  name: string;
  path: string;
  content: string;
  language: string;
  lastModified: number;
}

export interface Project {
  id: string;
  name: string;
  description: string;
  systemPrompt: string;
  files: ProjectFile[];
  created: number;
  lastModified: number;
  selectedFiles: Set<string>;
  directoryHandle?: any;
}

export interface HistoryBranch {
  baseMessageId: string;
  branchIndex: number;
  messages: Message[];
}

export interface Chat {
  id: string;
  title: string;
  messages: Message[];
  model: AIModel;
  projectId?: string;
  emoji: string;
  images: ChatImage[];
  streamingEnabled: boolean;
  systemPrompt?: string;
}

export interface AIModel {
  id: 'gpt' | 'claude' | 'mistral';
  name: string;
  apiEndpoint: string;
  defaultModel: string;
  supportsStreaming?: boolean;
  supportsFunctionCalling?: boolean;
}

export interface AppState {
  chats: Chat[];
  projects: Project[];
  currentChatId: string | null;
  currentProjectId: string | null;
  apiKeys: Record<string, string>;

  getCurrentChat: () => Chat | null;

  addChat: (model: AIModel, projectId?: string) => void;
  deleteChat: (id: string) => void;
  setCurrentChat: (id: string | null) => void;
  updateChat: (id: string, updates: Partial<Chat>) => void;
  addMessage: (
    chatId: string,
    role: Message['role'],
    content: string,
    selectedImages?: string[],
    messageId?: string,
    offline?: boolean
  ) => void;
  clearOfflineFlag: (chatId: string, messageId: string) => void;
  updateMessage: (chatId: string, messageId: string, content: string) => void;
  setMessageEditing: (chatId: string, messageId: string, isEditing: boolean) => void;
  updateChatTitle: (chatId: string, title: string) => void;
  updateChatEmoji: (chatId: string, emoji: string) => void;
  addImageToChat: (chatId: string, image: Omit<ChatImage, 'id'>) => string;
  deleteImageFromChat: (chatId: string, imageId: string) => void;

  addProject: (name: string, description: string, systemPrompt: string) => void;
  deleteProject: (id: string) => void;
  setCurrentProject: (id: string | null) => void;
  updateProject: (id: string, updates: Partial<Project>) => void;
  addFile: (projectId: string, file: Omit<ProjectFile, 'id'>) => void;
  updateFile: (projectId: string, fileId: string, content: string) => void;
  deleteFile: (projectId: string, fileId: string) => void;

  setApiKey: (modelId: string, apiKey: string) => void;
  setProjectDirectory: (projectId: string, handle: any | null) => void;
}
```

src\utils\format.ts:
```
export function formatFileSize(bytes: number): string {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }
  
  export function formatDate(timestamp: number): string {
    const date = new Date(timestamp);
    const now = new Date();
    const diff = now.getTime() - date.getTime();
    
    // Moins d'une minute
    if (diff < 60000) {
      return 'À l\'instant';
    }
    
    // Moins d'une heure
    if (diff < 3600000) {
      const minutes = Math.floor(diff / 60000);
      return `Il y a ${minutes} minute${minutes > 1 ? 's' : ''}`;
    }
    
    // Moins d'un jour
    if (diff < 86400000) {
      const hours = Math.floor(diff / 3600000);
      return `Il y a ${hours} heure${hours > 1 ? 's' : ''}`;
    }
    
    // Moins d'une semaine
    if (diff < 604800000) {
      const days = Math.floor(diff / 86400000);
      return `Il y a ${days} jour${days > 1 ? 's' : ''}`;
    }
    
    // Format standard
    return date.toLocaleDateString('fr-FR', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  }
```

src\utils\offlineMessages.ts:
```
// src/utils/offlineMessages.ts

const DB_NAME = 'offlineMessages';
const STORE_NAME = 'messages';

export function openDB(): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, 1);
    request.onupgradeneeded = () => {
      request.result.createObjectStore(STORE_NAME, { keyPath: 'id' });
    };
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

export async function storePendingMessage(message: any): Promise<void> {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    const request = store.add(message);
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}

export async function getPendingMessages(): Promise<any[]> {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);
    const request = store.getAll();
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

export async function removePendingMessage(id: string): Promise<void> {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    const request = store.delete(id);
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}

```

src\utils\processOfflineMessages.ts:
```
import { sendMessage } from '../services/ai';
import { useStore } from '../store';
import { getPendingMessages, removePendingMessage } from './offlineMessages';

export async function processOfflineMessages() {
  const pendingMessages = await getPendingMessages();
  if (!pendingMessages.length) return;
  const store = useStore.getState();

  // Grouper les messages pending par chatId
  const messagesByChat = pendingMessages.reduce((acc: Record<string, any[]>, msg) => {
    acc[msg.chatId] = acc[msg.chatId] || [];
    acc[msg.chatId].push(msg);
    return acc;
  }, {} as Record<string, any[]>);

  // Pour chaque chat avec des messages offline
  for (const chatId in messagesByChat) {
    try {
      const chat = store.chats.find(c => c.id === chatId);
      if (!chat) continue;
      const apiKey = store.apiKeys[chat.model.id];
      if (!apiKey) continue;

      // Pour chaque message offline pending, on retire l'indicateur offline dans le store
      for (const offlineMsg of messagesByChat[chatId]) {
        store.clearOfflineFlag(chatId, offlineMsg.id);
      }

      // Construire l'historique complet du chat
      const finalMessages = [
        { role: 'system', content: chat.systemPrompt || '' },
        ...chat.messages.filter(m => m.role !== 'system').map(m => ({
          role: m.role,
          content: m.content
        }))
      ];

      // Effectuer une seule requête API pour ce chat
      const response = await sendMessage(chat.model, apiKey, finalMessages, chat.images, false);
      // Ajouter la réponse de l'IA dans le chat
      store.addMessage(chatId, 'assistant', response);

      // Supprimer les messages pending pour ce chat de l'IndexedDB
      for (const offlineMsg of messagesByChat[chatId]) {
        await removePendingMessage(offlineMsg.id);
      }
    } catch (error) {
      console.error('Erreur lors de la synchronisation des messages offline:', error);
    }
  }
}

```

src\vite-env.d.ts:
```
/// <reference types="vite/client" />

```

tailwind.config.js:
```
import typography from '@tailwindcss/typography';

/** @type {import('tailwindcss').Config} */
export default {
  content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],
  theme: {
    extend: {
      colors: {
        background: '#0A0A0A',
        surface: '#1A1A1A',
        'surface-light': '#2A2A2A',
        primary: '#FFFFFF',
        secondary: '#A1A1AA',
        accent: '#F5F5F5'
      },
      animation: {
        'fade-in': 'fadeIn 0.2s ease-out',
        'slide-up': 'slideUp 0.3s ease-out',
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' },
        },
        slideUp: {
          '0%': { transform: 'translateY(10px)', opacity: '0' },
          '100%': { transform: 'translateY(0)', opacity: '1' },
        },
      },
    },
  },
  plugins: [typography],
};
```

tsconfig.app.json:
```
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"]
}

```

tsconfig.json:
```
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

```

tsconfig.node.json:
```
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}

```

vite.config.ts:
```
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { VitePWA } from 'vite-plugin-pwa';

export default defineConfig({
  plugins: [
    react(),
    VitePWA({
      // On passe en mode injectManifest pour utiliser notre SW personnalisé.
      strategies: 'injectManifest',
      srcDir: 'src',
      filename: 'sw-custom.js',
      registerType: 'autoUpdate',
      includeAssets: ['icon-192x192.png', 'icon-512x512.png'],
      manifest: {
        name: 'AI Chat App',
        short_name: 'AI Chat',
        description: 'Application de chat avec différentes IAs',
        theme_color: '#0A0A0A',
        background_color: '#0A0A0A',
        display: 'standalone',
        icons: [
          {
            src: '/icon-192x192.png',
            sizes: '192x192',
            type: 'image/png',
            purpose: 'any maskable'
          },
          {
            src: '/icon-512x512.png',
            sizes: '512x512',
            type: 'image/png',
            purpose: 'any maskable'
          }
        ]
      },
      workbox: {
        globPatterns: ['**/*.{js,css,html,ico,png,svg,woff,woff2}'],
        runtimeCaching: [
          {
            urlPattern: /^https:\/\/api\.openai\.com\/.*/i,
            handler: 'NetworkFirst',
            options: {
              cacheName: 'api-cache',
              expiration: {
                maxEntries: 50,
                maxAgeSeconds: 60 * 60 * 24 // 24 heures
              }
            }
          }
        ]
      }
    })
  ],
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          'lucide-react': ['lucide-react']
        }
      }
    }
  }
});

```

